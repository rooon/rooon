[{"title":"重学JavaScript之基本概念(中) => 操作符","date":"2019-06-18T05:03:00.000Z","path":"2019/06/18/重学JavaScript之基本概念-中-操作符.html","text":"注意： 本文章为 《重学js之JavaScript高级程序设计》系列第三章第二部分【操作符】。关于《重学js之JavaScript高级程序设计》是重新回顾js基础的学习。 1. 操作符 用于描述一组可以操作数据值的概念叫做操作符。包括 算术操作符（加号和减号）、位操作符、关系操作符和相等操作符。ES的操作符和其他不同的在于它能够适用于很多值，如：字符串、数字值、布尔值、甚至对象。在应用于对象的时候，需要调用对象的 valueOf() 和 toString()方法。 1.1 一元操作符 只能操作一个值的操作符叫做一元操作符。 1.1.1 递增和递减操作符 分为两种类型：前置和后置型，前置位于要操作的变量之前。后置则在要操作的变量之后。如下： var age = 29 ++age // 30 等于 age = age + 1 --age // 28 等于 age = age - 1 注意：执行前置递增或递减的时候，变量的值都是在语句被求值以前改变的。 var age = 29 var a = --age + 2 age // 28 a // 30 // 由于前置递增和递减与执行语句的优先级相等， 所以整个语句会被从左到右求值。 var num1 = 2 var num2 = 20 var num3 = --num1 + num2 // 21 var num4 = num1 + ++num3 // 23 后置型递增和递减操作语法不变，只不过由前面放到了后面，而且最重要的是：后置型递增和递减的操作都是在变量执行之后在操作的。如下： var num = 3 var age = 4 num-- + age-- // 7 num // 2 age // 4 总结： 以上4个操作符对任何值都适用，不限于数字还可以用于字符串、布尔值、浮点数值和对象，规则如下： 1、应用于数字字符的字符串时候，先将其转换为数字值， 在执行加减 1 的操作，字符串变量变成数值变量。 2、应用于不包含有效数字的字符串时，将其变量的值设置 位NaN，字符串变量变成数值变量 3、用于布尔值false的时候，将其转换为0，在执行加减1的 操作，布尔值变成数值 4、用于布尔值true的时候，将其转换为1，在执行加减1的操 作，布尔值变成数值 5、用于浮点数，执行加减1的操作 6、用于对象，先调用对象的valueOf()方法，如果返回的结果 是NaN在调用toString()方法，对象的变量变成数值变量。 上面的说明如下： var s1 = &apos;2&apos; var s2 = &apos;z&apos; var s3 = false var s4 = 1.1 var s5 = { valueOf: function(){ return -1 } } s1++ // 3 s2++ // NaN s3++ // 1 s4-- // 0.10000000000009 s5-- // -2 1.1.2 一元加和减操作符 一元加操作符放在变量之前是没有任何变化的，而一元减操作符放在变量之前则变量是个负数 var num = 25 num = +num // 25 num = -num // -25 注意：还是遵循之前的规则，对于字符串的变量使用加减操作符 则变成 NaN 其他的则相应变成指定规则的数值。 一元加减操作符主要用于基本的算术运算，也可以用于转换数据类型。 1.2 位操作符 位操作符是用于内存中表示数值的位来操作数值。ES中所有的值都是按照64位格式存储，但位操作符并直接操作64位值，而是先将64位的值转换成32位整数，然后执行操作，最后在将结果转换位64位。 对于有符号的整数，32位中的前31位用于表示整数的值，第32位表示数值的符号，0表示整数，1表示负数。这个表示符号的位叫做符号位。符号位的值决定了其他位数值的格式。其中，正数以纯二进制格式存储，31位中的每一位都表示2的幂，第一位表示 2的0次方以此类推。没有用到的用0填充忽略不计。也就是2进制表示法。 负数同样可以以二进制存储，但是使用的格式是二进制补码，计算一个数值的二进制补码步骤如下： 1、求这个数值绝对值的二进制码 2、求二进制反码 3、得到的二进制反码 +1 如下：求 -18的二进制码 0000 0000 0000 0000 0000 0001 0010 求反码 0 1 互换 1111 1111 1111 1111 1111 1110 1101 然后 加 1 1111 1111 1111 1111 1111 1110 1110 在ES中，ES会尽力向我们隐藏所有这些信息，也就是说，在二进制字符串形式输出一个负数时，我们看到的只是这个负数绝对值的二进制码之前加了一个负号，如下： var num = -18 num.toString(2) // &apos;-10010&apos; 注意：默认情况下，ES中所有的整数都是有符号整数，当然也存在无符号整数，对于无符号整数来说，第32位不再表示符号，因为无符号整数只能是正数，而且无符号整数的值可以更大，因为多出来的一位不再表示符号，可以用来表示数值。 在ES中当对应数值应用位操作符时，后台会发生如下转换过程:64位的数值被转换成32位数值，然后执行位操作，最后再将32位数值转换回64位数值。这样表面上看起来好像是在操作 32 位数值，另外有个问题，这样的操作导致在特殊值 如 NaN 和 Infinity值应用位操作的时候，这两个值会被当成0来处理。 注意：如果对非数值进行位操作符，那么会先使用 Number() 函数将该值转换为一个数值，在应用位操作，得到的结果是一个数值。 按位非（NOT） 按位非操作符由一个波浪线(~)表示，执行按位非的结果就是返回数值的反码并减一，如下： var num = 25 // 二进制 0001 1001 var num1 = ~num // 二进制 1110 0110 // -26 按位与 按位与操作符由一个和字符号(&amp;)表示，它有两个操作符数。从本质上来讲，按位与操作就是将两个数值的每一位对齐，根据以下规则，对相同位置上的两个数执行AND操作： 结果：全1才为1，有0返回0 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 0 0 1 0 0 0 0 按位或(OR) 按位或由一个竖线符号（|）表示，同样也有两个操作数，操作结果遵循下表。 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 1 0 1 1 0 0 0 结果：有1返回1，全0返回0 按位异或(XOR) 按位异或操作符由一个插入符号 (^)表示，也是两个操作数，结果遵循下表： 第一个数值的位 第二个数值的位 结果 1 1 0 1 0 1 0 1 1 0 0 0 结果：两个数只有1个为1的时候才返回1，同时为1或同时为0 则返回0 左移 左移操作符由两个小于号（&lt;&lt;）表示，这个操作符会将数值的所有位向左移动指定的位数。如下： // 将数值2向左移动5位，结果就是64位 var oldnum = 2 // 二进制 10 var newnum = oldnum &lt;&lt; 5 // 二进制 1000000 ， 十进制 64 注意： 在向左移位后，原数值的右侧多出了 5 个空位，左移操作 会以0来填充这些空位，以便得到的结果是一个完整的32位的二进制数。 有符号的右移 有符号的右移操作符由两个大于号（&gt;&gt;）表示，这个操作符会将数值向右移动，但保留符号位（即正负号标记），有符号的右移操作与左移操作恰好相反，即如果将64向右移动5位，结果将变回2.如下： var oldnum = 64 // 二进制 1000000 var newnum = oldnum &gt;&gt; 5 // 二进制 10 2 注意：在移位的过程中，原数值也会出现空位，只不过这次 空位出现在原数值的左侧、符号位的右侧，这时候ES就会用 符号位的值来填充所有的空位，以便得到一个完整的值。 无符号右移 无符号右移操作符右三个大于号（&gt;&gt;&gt;）组成，这个操作符会将数值的所有32位都向右移动，对于正数来说，无符号右移的结果与有符号右移相同，如下 var oldnum = 64 // 二进制 1000000 var newnum = oldnum &gt;&gt;&gt; 5 // 二进制 10 十进制 2 注意：在负数下情况就不一样了，首先，无符号右移是以0来填充空位，而不是像有符号右移那样以符号位来填充空位。所以，对正数的无符号右移与有符号右移结果相同，但对负数的结果就不一样了。其次无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值补码形式表示，因此就会导致无符号右移后的结果非常之大。如下： var oldnum = -64 // 二进制 11111111111111111111111111000000 var newnum = oldnum &gt;&gt;&gt; 5 // 十进制 134217726 欢迎关注 公众号【小夭同学】 重学js系列 重学js之JavaScript简介 重学 JS 之在 HTML 中使用 JavaScript 重学js之JavaScript基本概念（上）=&gt; 数据类型 ES6入门系列 ES6入门之let、cont ES6入门之变量的解构赋值 ES6入门之字符串的扩展 ES6入门之正则的扩展 ES6入门之数值的扩展 ES6入门之函数的扩展 ES6入门之数组的扩展 ES6入门之对象的扩展 Git教程 前端Git基础教程","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiaopianjun.cc/tags/JavaScript/"}]},{"title":"JavaScript之继承（未完待续）","date":"2019-06-11T14:28:00.000Z","path":"2019/06/11/JavaScript之继承（未完待续）.html","text":"微信图片_20190611223220.jpg # 1. 原型链继承 从父级上继承，但是有个问题，如果有多个子类同时继承一个父类，如果改变其中一个子类，其余子类也会跟着改变，这种情况就和数组对象的浅拷贝一样。 function parents(){ this.name = [&apos;fuqin&apos;] } parents.prototype.getName = function() { console.log(this.name) } function child(){} child.prototype = new parents() let child1 = new child() child1.getName() // [&apos;fuqin&apos;] let child2 = new child() child1.name.push(&apos;haha&apos;) let child3 = new child() child1.getName() // =&gt; [&apos;fuqin&apos;, &apos;haha&apos;] child2.getName() // =&gt; [&apos;fuqin&apos;, &apos;haha&apos;] child3.getName() // =&gt; [&apos;fuqin&apos;, &apos;haha&apos;] 2. 构造函数继承 改进了原型链继承的缺点，不会因为某个实例的更改而导致所有继承实例的变化，但是也有它的缺点就是每次创建实例都会创建一遍方法。 function parents(){ this.name = [&apos;brother&apos;] } function child(){ parents.call(this) } let child1 = new child() let child2 = new child() child1.name.push(&apos;haah&apos;) let child3 = new child() console.log(child1.name) // =&gt; [&apos;brother&apos;, &apos;haah&apos;] console.log(child2.name) // =&gt; [&apos;brother&apos;] console.log(child3.name) // =&gt; [&apos;brother&apos;] // 在构造函数继承中还可以通过call()传递参数 function parents(name){ this.name = name } function child(name){ parents.call(this,name) } let child1 = new child(&apos;hh,我是1&apos;) let child2 = new child(&apos;hh,我是2&apos;) child1.name // =&gt; &apos;hh,我是1&apos; child2.name // =&gt; &apos;hh,我是2&apos;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiaopianjun.cc/tags/JavaScript/"}]},{"title":"周末闲逛","date":"2019-06-11T07:49:17.000Z","path":"2019/06/11/周末闲逛.html","text":"","tags":[]},{"title":"重学JavaScript之基本概念(上) => 数据类型","date":"2019-06-02T13:30:00.000Z","path":"2019/06/02/重学JavaScript之基本概念(上) = 数据类型.html","text":"前提：任何语言的核心都会描述这门语言最基本的工作原理，通常描述的内容会涉及到这门语言的语法 、操作符、数据类型、内置功能等用于构建复杂解决方案的基本概念。 1. 语法1、js 中的变量、函数名和操作符都区分大小写， 2、另外一些像typeof这些关键字也不能使用 2. 标识符 所谓标识符就是指变量、函数、属性的名字，或者函数的参数。 标识符的写法标准如下： 1、第一个字符必须是一个字母、下划线或者一个美元符号 2、其他字符可以是字母、下划线、美元符号或数字 3、标识符中的字母采用驼峰大小写格式，例如：firstSecond、myCar 3. 注释 js的注释包括单行注释和块级注释，单行注释两个反斜杠开头，块级注释则是以（/）开始以（/）结束 单行注释 // 注释 块级注释 /* 块级注释 */ 4. 语句 在js中语句是以分毫结尾但是不是必须的，但是推荐还是写上分号。因为这样在压缩代码的时候就不会出现不必要的问题。 5. 关键字和保留字 在js中有一些特定的关键字，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作等，关键字是语言特地保留的，所以不能用作标识符。另外在js中还有另外一些保留字，也是不能用来当作标识符。 6. 变量 因为js的变量是松散类型的，松散类型就是可以用来保存任何类型的数据。每个变量仅仅是用来保存值的占位符而已，定义变量需要用到var，在之后的ES6中增加了let和const关键字来定义变量。 var a = 10 // 定义一个变量a 给它赋值 10 注意：虽然省略 var 操作符可以定义全局变量，但是并不推荐这种做法，因为在局部作用域中定义全局变量会使得代码很难维护。 7. 数据类型 在js中有5种基本数据类型：Undefined、Null、Boolean、Number和String，复杂类型 Object。Object是一组由无序的名值对组成的。在ES中不支持任何创建自定义类型的机制。 8. typeof操作符 用来检测给定变量的数据类型，检测的返回值如下： undefined -- 值未定义 Boolean -- 布尔值 string -- 字符串 number -- 数值 object -- 对象或者null function -- 函数 typeof操作符的操作数可以是变量，也可以是数值字面量，typeof是一个操作符而不是函数。 9. undefined 它只有一个特殊类型的值即undefined，如果变量在var后没有赋值，那么这个变量的值就是 undefined。 var message; message // undefined 注意：未初始化的变量和未赋值的变量 typeof之后都是undefined，所以为了更好的判断undefined的来源到底是未赋值还是未初始化，建议所有的值都声明在使用。 10. null类型 null 是第二个只有一个值的数据类型，值为 null，从表面看 null 表示的是一个空对象指针，而这个真是typeof 检测 null 返回值为 “object”的原因。 如果你想定义一个变量用来保存对象，那么最好的做法就是将变量赋值 null 这样检测 null 就知道 相应的变量是否保存了一个对象的引用。 注意：null == undefined 为 true，尽管这样两者的用途并不相同。无论任何情况下都没有必要将一个变量的值显式的设置为 undefined，而null则是如果保存对象的变量没有真正保存对象，那么就应该明确的让变量保存null值。这样可以进一步的区分 null 和 undefined。 11. Boolean类型 boolean类型有两个字面值：ture 和 false,另外这两个值和数字值不是一回事，ture 不一定等于1，false也不一定等于0. 注意：true 和 false 是区分大小写的，True 和 Flase 只是标识符。 我们可以通过函数 Boolean() 将一个值转换为Boolean类型。 如下： var message = &apos;haha,nihao&apos;; var zh = Boolean(message) 各种类型的转换规则如下： 数据类型 转换为true的值 转换为false的值 Boolean true false String 任何非空字符串 “” (空字符串) Number 任何非零数字值（包括无穷大） 0 和 NaN Object 任何对象 null Undefined 不适用 undefined 12. number类型 在js中广泛使用的数据类型，有整数和浮点数值。可以通过十进制、八进制、十六进制的字面来表示。 var bjz = 070 // 八进制 56 var sjz = 56 // 十进制 56 var sljz = 0xA // 十六进制 10 12.1 浮点数值 就是该数值中必须包含一个小数点，并且小数点后面至少有一位数字。 var f = 1.1 注意：由于保存浮点数的内存空间是保存整数的两倍，所以以下情况会自动将浮点转换为整数保存，如下： var f = 1. // 小数点后没有数字 保存为 1 var b = 10.0 // 保存为 10 另外对于 过大 或者过小的值可以通过 e（科学计数法）表示，如下： var f = 3.125e7 // 3.125 * 10^7 =&gt; 31250000 var f = 3e-17 // js 会将小数点后面超过6个0的浮点数值转换为科学计数法 注意：0.1 + 0.2 ！= 0.3 12.2 数值范围 js中由于内存的限制并不能保存所有的数值，js能够表示的最小值为 5e-324,最大值为 1.7976931348623157e + 308。如果某次计算数值超过最大 就转换为Infinity，最小为 -Infinity。如果出现这两个值，那么该值就不能在参与之后的运算了。 12.3 NaN js 中的非数值，是一个特殊的值。主要是为了防止抛出错误，用来表示一个本来返回数值的操作数未返回数值的情况。 NaN 有两个特定，1、任何涉及NaN的操作都会返回NaN，2、NaN与任何值都不相等包括其本身。针对这两个特点，ES定义了isNaN() 函数，这个函数接受一个参数，该参数可以是任何类型，而该函数会帮我们确定这个参数是否 “不是数值”，isNaN()接受参数之后会尝试将这个值转换为数值，某些不是数值的值会直接转为数值。如下： isNaN(NaN) // true isNaN(10) // false (10是一个数值) isNaN(&quot;10&quot;) // false (可以被转换成数值10) isNaN(&apos;blue&apos;) // true (不能转换成数值) isNaN(true) // flase (可以被转换成数值 1) 注意：isNaN()也可以用于对象，在基于对象调用的时候，首先会调用 valueOf()方法，然后确定该方法的返回值是否可以转换为数值，如果不能则基于这个返回值在调用 toString() 方法,在测试返回值。 12.4 数值转换 有3个函数可以把非数值转换为数值：Number()、parseInt()、parseFloat()，第一个函数可以用于任何数据类型。另外两个函数用于将字符串转换为数值。 Number()转换规则如下： Boolean值 =&gt; true or flase =&gt; 1 or 0 number =&gt; 传入和返回 null =&gt; 返回 0 undefined =&gt; 返回null 字符串 如果包含十进制数值 则 &apos;123&apos; =&gt; 123 ，&apos;012&apos; =&gt; 12 如果是浮点字符串 则 &apos;1.1&apos; =&gt; 1.1 ， &apos;01.1&apos; =&gt; 1.1 如果包含十六进制 则 &apos;0xf&apos; =&gt; 相同的十进制 如果为空 则 &apos;&apos; =&gt; 0 如果包含除了上述格式 则 &apos;&apos; =&gt; NaN 如果是对象，则调用对象的 valueOf()方法，在按照之前的规则转换返回值， 如果转换对象是NaN，则调用对象的 toString() 方法，在按照之前的规则返回字符串 值。 parseInt()转换规则如下： 它会忽略字符串前面的空格，如果第一个字符不是数字或者负号则返回NaN。 如果是其他进制，则转换为响应的十进制数值。 var n = parseInt(&apos;1234blue&apos;) =&gt; 1234 var m = parseInt(&apos;&apos;) =&gt; NaN parseFloat()转换规则如下： 从第一个字符开始解析每个字符，知道遇到第一个无效的浮点数字字符为止 也就是说字符串中第一个小数点是有效的，第二个小数点就无效的了。因此 它后面的字符串就被忽略了。 var n = parseFloat(&apos;1234blue&apos;) =&gt; 1234 var m = parseFloat(&apos;0xA&apos;) =&gt; 0 var c = parseFloat(&apos;22.21.2&apos;) =&gt; 22.21 var b = parseFloat(&apos;22.4&apos;) =&gt; 22.4 13. string类型 用于表示由零或者多个16位 Unicode字符组成的字符序列，即字符串。由双引号（””）或者单引号 （’’）包裹而成 var a = &apos;124&apos; var b = &quot;123&quot; // 注意：双引号开头必须双引号结尾！ 13.1 字符字面量 一些特殊的字符字面量，即转义序列。用于表示非打印字符，或者具有其他用途的字符。 字面量 含义 \\n 换行 \\t 制表 \\b 空格 \\r 回车 \\f 进纸 \\ 斜杠 \\’ 单引号 \\” 双引号 这些字符可以出现在字符串冲的任意位置，而且也会被当作一个字符来解析。 任何字符串的长度都可以通过 length 属性来获取。 let b = &apos;1kljk&apos; b.length // 5 13.2 字符串的特点 在 ES 中字符串是不可变的。字符串一旦被创建，它的值将不能被改变。如果要改变某个字符串的值则需要销毁原本的值，在重新赋值 var lang = &apos;shanghai&apos; lang = lang + &apos;daxue&apos; // shanghaidaxue 13.3 转换为字符串 如果想将一个值转换为字符串有两种方法。一、通过toString(),如下： var age = 11; var agestring = age.toString() // &apos;11&apos; var b = true var bstring = b.toString() // &apos;true&apos; 大多数数据类型（数值、布尔值、对象和字符串值）都有 toString方法，但是 null 和 undefined 没有。大多数情况下 toString 是不需要传递参数的。默认是以十进制格式返回数值的字符串表示。但是其实是可以传递八进制、二进制、十六进制参数的。 var num = 10; num.toString() // &apos;10&apos; num.toString(2) // &apos;1010&apos; num.toString(8) // &apos;12&apos; num.toString(10) // &apos;10&apos; num.toString(16) // &apos;a&apos; 14. object类型 对象是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建的对象类型的名称来创建。创建的object类型的实例，可以为其添加属性和方法。 var o = new Object() 在ES中 Object类型是所有它的实例的基础，Object类型所具有的任何属性和方法也同样存在于更具体的对象中。 Object的每个实例都具有下列属性和方法：constructor =&gt; 保存用于创建当前对象的函数 hasOwnProperty（propertyName）=&gt; 用于检查给定的属性在当前对象实例中是否存在。propertyName必须以字符串形式指定。 isPrototypeOf(object) =&gt; 用于检查传入的对象是否是另一个对象的原型。 propertyIsEnumerable(propertyName) =&gt; 用于检查给的属性是否能够使用 for-in语句来枚举，与hasOwnProperty()方法一样，作为参数的属性名必须以字符串指定。 toString() =&gt; 返回对象的字符串表示 valueOf() =&gt; 返回对象的字符串、数值或布尔值表示。·","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiaopianjun.cc/tags/JavaScript/"}]},{"title":"周末，天气很棒，瞎溜达","date":"2019-06-02T08:14:58.000Z","path":"2019/06/02/天气很好，周末的瞎溜达.html","text":"周末天气很好呀，不能一直闷在家里，能得的好天气，肯定要出去玩耍的啦。 周围夏天的气息越来越浓烈，乘着温度还没有那么高，带着帐篷，与大自然来一次亲密的接触。 周围的风景也是很好，很安静，夕阳很美呀。 夕阳西下 夕阳西下 野花很漂亮呀 野花很漂亮呀 微信图片_20190611231511.jpg 微信图片_20190611231604.jpg 微信图片_20190611231534.jpg 微信图片_20190611231614.jpg 微信图片_20190611231519.jpg 微信图片_20190611231600.jpg 微信图片_20190611231543.jpg 微信图片_20190611231527.jpg 太阳快下山了 微信图片_20190611231552.jpg 回家吃晚饭啦 微信图片_20190611231504.jpg","tags":[{"name":"周末","slug":"周末","permalink":"https://jiaopianjun.cc/tags/周末/"},{"name":"郊游","slug":"郊游","permalink":"https://jiaopianjun.cc/tags/郊游/"}]},{"title":"Node.js内置模块","date":"2019-05-30T11:19:00.000Z","path":"2019/05/30/Node.js-内置模块.html","text":"1. http模块 用来搭建本地服务器 const http = require(&apos;http&apos;), http.createServer创建一个服务。 2. fs文件系统模块 赋予node读取本地文件的能力 const fs = require(&apos;fs&apos;); fs.writeFile(path, fileData, cb) // 写入文件 fs.readFile(path, cb) // 读取文件 3. path路径模块 用来处理路径相关 const path = require(&apos;path&apos;) let str = &apos;/c/dir/index.html&apos; console.log(path.dirname(str)) path.resolve() // 路径解析，用来拼合路径，返回一个绝对路径 4. ur模块 用来处理网址相关，或者用来获取地址路径或参数 const url = require(&apos;url&apos;) let site = &apos;http://www.a.cn/a/b/index.html?a=1&amp;b=2&apos; let {pathname, query} = url.parse(site, true) //解析网址 true就是将参数解析为对象 console.log(pathname, query) // &apos;/a/b/index.html&apos; {a: &apos;1&apos;, n: &apos;2&apos;} 5. querystring 查询字符串模块 主要用来将参数拼接字符串解析为对象 const queryString = require(&apos;querystring&apos;) let str = &apos;a=1&amp;b=2&amp;c=3&apos; let obj = queryString.parse(str) console.log(obj, obj.a) //{a:&apos;1&apos;,b:&apos;2&apos;,c:&apos;3&apos;}, &apos;1&apos; let o = queryString.stringify(obj) console.log(0) // &apos;a=1&amp;b=2&amp;c=3&apos; 6. assert 断言 判断条件是正确，如果正确则继续执行，如果错误则抛出异常 const assert = require(&apos;assert&apos;) // assert.deepEqual(变量，预期值，错误信息) 变量 == 预期值 // assert.deepStrictEqual(变量，预期值，错误信息) 变量 === 预期值 // 同样也是错误的时候抛出信息，正确的时候继续默默执行 const obj = {a: {b: 1}} const obj1 = {a: {b: 1}} assert.deepEqual(obj, obj1, &apos;不等&apos;) // true 7. stream 流 以工作流的模式，读取文件，使得文件的读取跟水流一样。一边读取一边使用。合理分配内存，避免内存爆掉的风险 const fs = require(&apos;fs&apos;) // 读取流：fs.createReadStream(); // 写入流：fs.createWriteStream(); let rs = fs.createReadStream(a.txt) // 读取的文件 let ws = fs.createWriteStream(a2.txt) // 写入的文件 rs.pipe(ws) // pipe将rs 和 ws 连接起来，使得读取流的数据传输到输出流 rs.on(&apos;error&apos;, err =&gt; { console.log(err); }); ws.on(&apos;finish&apos;, () =&gt; { console.log(&apos;成功&apos;); }) 8. zlib压缩 用来将文件压缩 const fs = require(&apos;fs&apos;) const zlib = require(&apos;zlib&apos;) let rs = fs.createReadStream(&apos;a.jpg&apos;) let gz = zlib.createGzip() let ws = fs.createWriteStream(&apos;a.jpg.gz&apos;) rs.pipe(gz).pipe(ws) // 原始文件 =&gt; 压缩 =&gt; 写入 rs.on(&apos;error&apos;, err =&gt; { console.log(err); }); ws.on(&apos;finish&apos;, () =&gt; { console.log(&apos;成功&apos;); })","tags":[{"name":"node学习","slug":"node学习","permalink":"https://jiaopianjun.cc/tags/node学习/"}]},{"title":"重学 JS 之在 HTML 中使用 JavaScript","date":"2019-05-27T13:32:00.000Z","path":"2019/05/27/重学 JS 之在 HTML 中使用 JavaScript.html","text":"# 1. 如何在页面中使用JavaScript 现在在HTML中使用JS 的方法主要是通过在页面插入 标签 引入外部文件，另外一种是为 指定type属性然后把js代码放在闭合标签中即可。如下： 参数： charset - 指定 src 属性的代码字符集，一般为utf-8 defer - 表示代码可以延迟到DOM完成加载之后在执行 src - 外部引入js文件的路径 type - 表示代码使用的脚本语言类型，一般为 text/javascript 外部引入： 元素内部使用方法： &lt;script type=&quot;text/javascript&quot;&gt; alert(&apos;abc&apos;) &lt;/script&gt; 注意事项：1、包含在 script 中的代码将依次从上往下依次执行 2、值得注意的是在js代码解析的过程中页面中其他内容将不会被加载和解析，直到该段js执行完成。 3、在书写的过程要注意，在script代码块中，不能在代码闭合标签 之前在出现闭合标签，这样会导致代码产生错误。 4、外部引用js的时候闭合标签可以省略，但是为了在IE中正确执行，建议不省略 5、如果你使用的是src引入外部js，那么在script标签之间不能再有内嵌js块 6、src引用外域js文件的时候要注意安全，因为这样可能会被替换js文件而导致安全问题。 7、js 代码块在页面中是顺序执行的，只有第一个全部执行完成之后才会顺序执行后面的。 2. 标签的位置 一般按照惯例js代码的引入应该放在 之中，但是由于 js 代码在执行的时候页面其他元素将不能被加载这样会导致页面的交互性很差，所以现在一般将js代码放在闭合标签之前，所有页面html 之后，这样可以不会因为js的加载而影响页面的加载。 &lt;html&gt; &lt;head&gt; &lt;title&gt;demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;a.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html 3. 延迟脚本 defer asyncdefer： 脚本在执行的时候不会影响页面的构造，因为js的执行会被延迟到页面全部加载之后才运行 async： 脚本和页面的加载将同步执行。 4. 总结 在页面中使用Javascript有两种方式，一种通过src引入外部脚本，一种是在script标签之间插入js代码。 1、 使用这两种方式都需要把 type 设置 为 text/javascript 2、 在包含外部js文件的时候，必须将src 设置为指向相应文件的url 3、 所有 script 代码会按照他们在页面的顺序按序执行，只有之前的被执行完成后续的才会被执行 4、 浏览器在呈现内容之前，必须先解析html之前的script代码，所以一定要将script代码放在页面的最后","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiaopianjun.cc/tags/JavaScript/"}]},{"title":"Node.js EventEmitter 和 Buffer","date":"2019-05-26T11:19:00.000Z","path":"2019/05/26/Node-js-EventEmitter-和-Buffer.html","text":"1. Node.js EventEmitter Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。Node.js 中许多对象都会分发事件。一个net.Server对象会在每次有新连接时触发一个事件，而另外一个 fs.readStream对象会在文件被打开的时候触发一个事件，所有的这些产生的事件对象都是 events.EventEmitter的实例。 EventEmitter 类 events 模块只提供了一个对象：events.EventEmitter。events.EventEmitter的核心就是事件触发和事件监听器功能的封装。你可以通过 require(‘events’)来使用该模块，如下： // 引入 events 模块 var events = require(&apos;events&apos;); // 创建 eventEmitter 对象 var eventEmitter = new events.EventEmitter(); EventEmitter对象如果在实例化的时候发生错误，将会触发 error 事件。当添加新的监听器的时候，newListener事件会被触发，当该监听器被移除的时候，removeListener 将会被触发。 案例： //event.js 文件 var EventEmitter = require(&apos;events&apos;).EventEmitter; var event = new EventEmitter(); event.on(&apos;some_event&apos;, function() { console.log(&apos;1s后 some_event 事件触发&apos;); }); setTimeout(function() { event.emit(&apos;some_event&apos;); }, 1000); // node event.js // 1s 后执行 EventEmitter 的每个事件由一个 事件名 和 若干个 参数 组成，事件名是一个字符串，通常表达一个的意思，对于每个事件，EventEmitter支持多个事件监听器。当事件触发的时候，注册到这个事件上的事件监听器将依次被调用，事件参数作为回调函数参数传递。如下： // event.js 文件 var events = require(&apos;events&apos;); var emitter = new events.EventEmitter(); emitter.on(&apos;someEvent&apos;, function(arg1, arg2) { console.log(&apos;listener1&apos;, arg1, arg2); }); emitter.on(&apos;someEvent&apos;, function(arg1, arg2) { console.log(&apos;listener2&apos;, arg1, arg2); }); emitter.emit(&apos;someEvent&apos;, &apos;arg1 参数&apos;, &apos;arg2 参数&apos;); // node event.js listener1 arg1 参数 arg2 参数 listener2 arg1 参数 arg2 参数 在上面例子中，emitter为事件someEvent注册了两个事件监听器，然后触发了someEvent事件，从运行结果中可以看到 两个事件监听器的回调函数 先后被调用。 EventEmitter提供了多个属性，如 on 和 emit 。 on 函数用来绑定事件函数，emit 用来触发一个事件，具体参数如下： 参数名 描述 addListener(event, listener) 为指定事件添加一个监听器到监听器数组的尾部 on(event, listener) 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数 once(event, listener) 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器 removeListener(event, listener) 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称 removeAllListeners([event]) 移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器 setMaxListeners(n) 用于提高监听器的默认限制的数量 listeners(event) 返回指定事件的监听器数组 emit(event, [arg1], [arg2], […]) 按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false listenerCount(emitter, event) 返回指定事件的监听器数量 newListener 该事件在添加新监听器时被触发 removeListener 当指定监听器被删除的时候触发，注意：该触发器之后的监听器 实例： var events = require(&apos;events&apos;); var eventEmitter = new events.EventEmitter(); // 监听器 #1 var listener1 = function listener1() { console.log(&apos;监听器 listener1 执行。&apos;); } // 监听器 #2 var listener2 = function listener2() { console.log(&apos;监听器 listener2 执行。&apos;); } // 绑定 connection 事件，处理函数为 listener1 eventEmitter.addListener(&apos;connection&apos;, listener1); // 绑定 connection 事件，处理函数为 listener2 eventEmitter.on(&apos;connection&apos;, listener2); var eventListeners = eventEmitter.listenerCount(&apos;connection&apos;); console.log(eventListeners + &quot; 个监听器监听连接事件。&quot;); // 处理 connection 事件 eventEmitter.emit(&apos;connection&apos;); // 移除监绑定的 listener1 函数 eventEmitter.removeListener(&apos;connection&apos;, listener1); console.log(&quot;listener1 不再受监听。&quot;); // 触发连接事件 eventEmitter.emit(&apos;connection&apos;); eventListeners = eventEmitter.listenerCount(&apos;connection&apos;); console.log(eventListeners + &quot; 个监听器监听连接事件。&quot;); console.log(&quot;程序执行完毕。&quot;); // 执行结果： $ node main.js 2 个监听器监听连接事件。 监听器 listener1 执行。 监听器 listener2 执行。 listener1 不再受监听。 监听器 listener2 执行。 1 个监听器监听连接事件。 程序执行完毕 error 事件 执行error事件，当error被触发的时候，EventEmitter 规定如果没有响应的监听器，那么node.js就将它当作异常，退出程序并输出错误信息。所以我们要为error设置监听器，避免因为错误导致程序崩溃。如下： var events = require(&apos;events&apos;); var emitter = new events.EventEmitter(); emitter.emit(&apos;error&apos;); 继承 EventEmitter 大多数时候不会在node中直接使用EventEmitter，而是在对象中继承去使用它，例如 fs、net、http等，只要是支持事件响应的核心模块都是EventEmitter的子类这样做的原因有两点，如下： 1、具有某个实体功能的对象实现事件符合语义，事件的监听和发生应该是一个对象的方法 2、另外，因为JavaScript的对象机制是基于原型的，支持部分多重继承，继承EventEmitter不会打乱对象原有的继承关系 2. Node.js Buffer(缓冲区) 因为JavaScript只有字符串数据类型没有二进制数据类型。但是在处理TCP流或文件流时，必须使用二进制数据。所以在node.js定义了一个Buffer类，该类用来创建一个专门存放二进制数据的缓存区。 在node.js中,Buffer类是随Node内核一起发布的核心库，Buffer库可以让nodejs处理二进制数据，一个Buffer类似一个整数数组。 Buffer与字符编码 Buffer实例一般用于表示编码字符的序列，比如 UTF-8, Base64, 或十六进制编码的数据，通过使用显示的字符编码，就可以在Buffer实例与普通的JavaScript字符串之间进行相互转换。如下： const buf = Buffer.from(&apos;runoob&apos;, &apos;ascii&apos;); // 输出 72756e6f6f62 console.log(buf.toString(&apos;hex&apos;)); // 输出 cnVub29i console.log(buf.toString(&apos;base64&apos;)); nodejs支持的字符编码： ascii -- 仅支持7位ASCII数据 utf8 -- 多字节编码的Unicode字符 utf16le -- 2 或 4 个字节 ucs2 base64 latin1 binary hex 创建 Buffer类 Buffer提供下面多个api来创建Buffer类 Api类名 说明 Buffer.alloc(size[, fill[, encoding]]) 返回一个指定大小的 Buffer 实例 Buffer.allocUnsafe(size) 返回一个指定大小的 Buffer 实例 Buffer.allocUnsafeSlow(size) Buffer.from(array) 返回一个被 array 的值初始化的新的 Buffer 实例 Buffer.from(arrayBuffer[, byteOffset[, length]]) 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer Buffer.from(buffer) 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例 Buffer.from(string[, encoding]) 返回一个被 string 的值初始化的新的 Buffer 实例 案例： // 创建一个长度为 10、且用 0 填充的 Buffer。 const buf1 = Buffer.alloc(10); // 创建一个长度为 10、且用 0x1 填充的 Buffer。 const buf2 = Buffer.alloc(10, 1); // 创建一个长度为 10、且未初始化的 Buffer。 // 这个方法比调用 Buffer.alloc() 更快， // 但返回的 Buffer 实例可能包含旧数据， // 因此需要使用 fill() 或 write() 重写。 const buf3 = Buffer.allocUnsafe(10); // 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。 const buf4 = Buffer.from([1, 2, 3]); // 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。 const buf5 = Buffer.from(&apos;tést&apos;); // 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。 const buf6 = Buffer.from(&apos;tést&apos;, &apos;latin1&apos;); 写入缓冲区语法： 写入node缓冲区的语法如下： bur.write(string[, offset[, length]][, encoding]) 参数： string - 写入缓冲区的字符串 offset - 缓冲区开始写入的索引值，默认为0 length - 写入的字节数，默认为buffer.length encoding - 使用的编码，默认 ‘utf8’ 根据encoding的字符编码写入 string 到 buf中 offset位置，length参数是写入的字节数，如果buf没有足够的空间保存整个字符串，那么只会写入string的一部分，只部分解码的字符不会被写入。 返回值：返回值实际写入的大小，如果buffer空间不足，则只会写入部分字符串 实例 buf = Buffer.alloc(256); len = buf.write(&quot;www.runoob.com&quot;); console.log(&quot;写入字节数 : &quot;+ len); // 结果 $node main.js 写入字节数 : 14 从缓冲区读取数据语法： buf.toString([encoding[, start[, end]]]) 参数： encoding - 使用的编码 start - 指定开始读取的索引位置 end - 结束位置，默认为缓冲区的末尾 返回值：解码缓冲区数据并使用指定的编码返回字符串 实例： buf = Buffer.alloc(26); for (var i = 0 ; i &lt; 26 ; i++) { buf[i] = i + 97; } console.log( buf.toString(&apos;ascii&apos;)); // 输出: abcdefghijklmnopqrstuvwxyz console.log( buf.toString(&apos;ascii&apos;,0,5)); // 输出: abcde console.log( buf.toString(&apos;utf8&apos;,0,5)); // 输出: abcde console.log( buf.toString(undefined,0,5)); // 使用 &apos;utf8&apos; 编码, 并输出: abcde // 结果 $ node main.js abcdefghijklmnopqrstuvwxyz abcde abcde abcde 将 Buffer 转换为 JSON对象语法： buf.toJSON() 注意：当字符串化一个 Buffer 实例时，JSON.stringify()会隐式地调用该toJSON() 返回值：返回JSON对象 实例： const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]); const json = JSON.stringify(buf); // 输出: {&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]} console.log(json); const copy = JSON.parse(json, (key, value) =&gt; { return value &amp;&amp; value.type === &apos;Buffer&apos; ? Buffer.from(value.data) : value; }); // 输出: &lt;Buffer 01 02 03 04 05&gt; console.log(copy); // 结果 {&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]} &lt;Buffer 01 02 03 04 05&gt; 缓冲区合并语法： Buffer.concat(list[, totalLength]) 参数： list - 用于合并的 Buffer 对象数组列表 totalLength - 指定合并后 Buffer 对象的总长度 返回值： 返回一个多个成员合并的新 Buffer 对象。 实例： var buffer1 = Buffer.from((&apos;1&apos;)); var buffer2 = Buffer.from((&apos;2&apos;)); var buffer3 = Buffer.concat([buffer1,buffer2]); console.log(&quot;gogo 内容: &quot; + buffer3.toString()); // 结果 gogo 内容: 12 缓冲区比较语法： buf.compare(otherBuffer) 参数： ohterBuffer - 与 buf 对象比较的另外一个 Buffer 对象 返回值： 返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同 实例： var buffer1 = Buffer.from(&apos;ABC&apos;); var buffer2 = Buffer.from(&apos;ABCD&apos;); var result = buffer1.compare(buffer2); if(result &lt; 0) { console.log(buffer1 + &quot; 在 &quot; + buffer2 + &quot;之前&quot;); }else if(result == 0){ console.log(buffer1 + &quot; 与 &quot; + buffer2 + &quot;相同&quot;); }else { console.log(buffer1 + &quot; 在 &quot; + buffer2 + &quot;之后&quot;); // 结果 ABC在ABCD之前 拷贝缓冲区语法： buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]]) 参数： targetBuffer - 要拷贝的Buffer对象 targetStart - 数字，默认 0 sourceStart - 数字，默认 0 sourceEnd - 数字，默认： buffer.length 实例： var buf1 = Buffer.from(&apos;abcdefghijkl&apos;); var buf2 = Buffer.from(&apos;RUNOOB&apos;); //将 buf2 插入到 buf1 指定位置上 buf2.copy(buf1, 2); console.log(buf1.toString()); // 结果 abRUNOOBijkl 缓冲区裁剪 buf.slice([start[, end]]) 参数： start - 数字 可选，默认 0 end - 数字 可选 默认： buffer.length 返回值： 返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。 实例： var buffer1 = Buffer.from(&apos;cui&apos;); // 剪切缓冲区 var buffer2 = buffer1.slice(0,2); console.log(&quot;buffer2 content: &quot; + buffer2.toString()); // 结果 buffer2 content: cu 缓冲区长度语法： buf.length 返回值：返回 Buffer 对象所占据的内存长度 实例： var buffer = Buffer.from(&apos;1&apos;); // 缓冲区长度 console.log(&quot;buffer length: &quot; + buffer.length); // 结果 buffer length: 1","tags":[{"name":"node学习","slug":"node学习","permalink":"https://jiaopianjun.cc/tags/node学习/"}]},{"title":"ES6入门之对象的新增方法","date":"2019-05-21T13:16:00.000Z","path":"2019/05/21/ES6入门之对象的新增方法.html","text":"1. Object.is() 用来解决在ES5中 两种相等运算符的缺点。用来比较两个值是否严格相等，行为和（===）基本一致。 在ES5中判断两个值是否相等，只能用（==）相等运算符和（===）严格相等运算符，但是这两货都有缺点，前者 两边的值都会转换数据类型，后者 NaN不等于自身还有 +0 == -0。 Object.is(&apos;foo&apos;, &apos;foo&apos;) // true Object.is({}, {}) // false // 在 Object.is() +0 === -0 // true NaN === NaN // false Object.is(+0, -0) // false Object.is(NaN, NaN) // true 2. Object.assign() 用于对象的合并，将源对象的所有可枚举属性，复制到目标对象，现在常用来进行浅拷贝。 const t = {a: 1} const s1 = {b: 2} const s2= {c: 3} Object.assign(t, s2, s2) // t {a:1, b:2, c:3} // 在上面中第一个参数t是目标对象，s1 s2是源对象 注意：如果目标对象和源对象有同名属性，或者多个同名，那么在后面的属性会将前面的覆盖。 const t = {a: 1, b: 2} const s1 = {b: 3, c: 4} const s2 = {c: 5} Object.assign(t, s1, s2) t // {a:1, b:3, c:5} 如果Object.assign的参数只有一个，那么就返回该参数，另外如果该参数不是对象，那么Object.assign会将其转为对象在返回 const t = {a: 2} Object.assign(t) t // {a: 2} Object.assigin(2) // &quot;object&quot; 另外由于null 和 undefined 无法转换位对象，那么如果他们作为第一个参数就会报错，如果不是在第一个参数则不会有这个问题 Object.assign(undefined) // 报错 Object.assign(null) //报错 这样就不会报错：如下 const t = {a: 2} Object.assign(t, undefined) // true Object.assign(t, null) // true 其他（数值，字符串，布尔值）数值不再第一个也不会报错，但是字符串会以数组的形式被拷入目标对象，两外两个则不会做任何操作。 const a = &apos;abc&apos; const b = true const c = 12 const o = Object.assign({}, a, b, c) o // {&quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot;} // 因为布尔值number 的原始值都在对象的内部属性[[PrimitiveValue]] 上面，这个属性不能别Object.assign拷贝 Obeject.assign 拷贝的属性是有限制的，只能拷贝源对象的自身属性，也不能拷贝不可枚举的属性，另外 Symbol值的属性也能被拷贝 注意点：1. 浅拷贝 Object.assign 实现的是浅拷贝，也就是说如果源对象的某个属性值是对象，那么目标对象拷贝得到的是这个对象的引用 2. 同名属性的替换 如果遇到同名属性，那Object.assign的处理方法是替换还不是追加 3. 数组的处理 在处理数组的时候，Object.assign是将其是为对象来处理，如果下标相同则是覆盖而不是追加 Object.assign([1, 2, 3], [4, 5]) // [4, 5, 3] 4. 取值函数的处理 Object.assign 只能进行值的复制，如果复制的值是一个函数，那么就等函数求值执行完在进行值的复制 常见用途：1. 为对象添加属性 2. 为对象添加方法 3. 克隆对象 4. 合并多个对象 5. 为属性指定默认值 3. Object.getOwnPropertyDescriptors() 用来返回指定对象所有自身属性（非继承属性）的描述对象 const o = { left: 123, top() { return &apos;new&apos; } } Object.getOwnPropertyDescriptors(o) // { left:{ configurable: true enumerable: true value: 123 writable: true }, top: { configurable: true enumerable: true value: ƒ top() writable: true } } Object.getOwnPropertyDescriptors() 返回一个对象，所有原对象的属性名都是该 对象的属性名，对应的属性值就是该属性的描述对象。 4. proto属性，Object.setPrototypeOf()，Object.getPrototypeOf()4.1. proto属性 用来读取或设置当前对象的prototype对象，另外这是一个内部属性。proto是调用的 Object.prototype.proto 方法 //es5 写法 const o = { method: function() {} } o.__proto__ = someOtherObj //es6 写法 var o = Object.create(someOtherObj) o.method = function(){} 4.2 Object.setPrototypeOf() 作用和 proto相同，用来设置一个对象的prototype对象，返回参数本身 // 格式 Object.setPrototypeOf(object, prototype) // 用法 const o = Object.setPrototypeOf({}, null) === 以下写法 function setPrototyoeOf(obj, proto) { obj.__proto__ = proto return obj } // 例子 let proto = {} let o = { x: 10 } Object.setPrototypeOf(o, proto) proto.y = 20 proto.z = 40 o.x // 10 o.y // 20 o.z // 40 // 上面 将proto设为 o 对象的原型，所以可以从o 中读取proto 的属性 注意：如果第一参数不是对象，将自动转换为对象，由于返回的还是第一个参数，所以这个操作不会产生任何效果，另外由于 undefined 和 null 无法转换为对象，所以第一个参数如果是这两个则会报错 Object.setPrototypeOf(1, {}) === 1 // true Object.setPrototypeOf(&apos;foo&apos;, {}) === &apos;foo&apos; // true Object.setPrototypeOf(true, {}) === true // true Object.setPrototypeOf(undefined, {}) // TypeError: Object.setPrototypeOf called on null or undefined Object.setPrototypeOf(null, {}) // TypeError: Object.setPrototypeOf called on null or undefined 4.3 Object.getPrototypeOf() 用于读取一个对象的原型对象和Object.setPrototypeOf 配套使用。所有的特性也和 上面一样，第一个参数如果不是对象将转换为对象，undefined和null 会报错 5. Object.keys()，Object.values()，Object.entries()5.1 Object.keys() 用于返回一个数组，成员的参数是对象自身的所有可遍历属性的键名 let obj = { x: 1, y: &apos;b&apos; } Object.keys(obj) // [&quot;x&quot;, &quot;y&quot;] 5.2 Object.values() 返回值是一个数组，成员是对象自身的（不含继承的）所有可遍历属性的值。Objet.values只返回对象自身的可遍历属性。 let obj = { x: 1, y: &apos;b&apos; } Object.keys(obj) // [1, &quot;b&quot;] 另外Object.values遍历的时候如果遇到属性名为数值的属性，那么将按照数值大小，从小到大遍历，如下： const obj = { 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; }; Object.values(obj) // [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;] 注意：Object.values 会过滤属性名为 Symbol的属性 Object.values({ [Symbol()]: 123, foo: &apos;abc&apos; }); // [&apos;abc&apos;] 如果Object.values的参数是一个字符串 那么将返回字符串拆解的数组 Object.values(&apos;symbol&apos;) [&quot;s&quot;, &quot;y&quot;, &quot;m&quot;, &quot;b&quot;, &quot;o&quot;, &quot;l&quot;] 注意： 如果Object.values 的参数为boolean值或者number，那么返回值是一个空数组， Object.values(true) [] Object.values(2,null) [] 5.3 Object.entries() 返回一个数组，成员是对象自身（不含继承的）所有可遍历属性的键值对数组，同样 Symbol 属性的值会被过滤。 const p = { f: &apos;b&apos;, az: 22 }; Object.entries(p) // [ [&quot;f&quot;, &quot;b&quot;], [&quot;az&quot;, 22] ] Object.entries({ [Symbol()]: 456, o: &apos;c&apos; }); // [ [ &apos;o&apos;, &apos;c&apos;] ] Object.entries 可以用来遍历对象的属性 Object.entries 将对象转为真正的Map结构 const obj = { foo: &apos;bar&apos;, baz: 42 }; const map = new Map(Object.entries(obj)); map // Map { foo: &quot;bar&quot;, baz: 42 } 6. Object.fromEntries() 是Object.entries 的逆操作，将一个键值对数组转为对象。主要是将键值对的数据结构还原为对象，适用于将Map结构转为对象 Object.fromEntries([ [&apos;foo&apos;, &apos;bar&apos;], [&apos;baz&apos;, 42] ]) // { foo: &quot;bar&quot;, baz: 42 } // 例二 将Map结构转为对象 const map = new Map().set(&apos;foo&apos;, true).set(&apos;bar&apos;, false); Object.fromEntries(map) // { foo: true, bar: false }","tags":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jiaopianjun.cc/tags/ECMAScript6/"}]},{"title":"ES6入门之对象的扩展","date":"2019-05-15T13:19:00.000Z","path":"2019/05/15/ES6入门之对象的扩展.html","text":"1. 属性的简洁表示法 在ES6中 允许直接写入变量和函数，作为对象的属性和方法，使得代码的书写更为简洁。 const f = &apos;a&apos; const b = {f} b // {f: &apos;a&apos;} 等同于 const b = {f: f} 在ES6中允许在对象内直接写变量，这时候属性名为变量名，属性值就是变量值 function u(x, y){ return {x, y} } // ==== function u(x, y){ return {x: x, y: y } } u(1, 2) // {x:1, y: 2} 或者一下写法： function o() { const x = 1; const x = 2; return {x, y} } o() // {x:1, y:2} 2. 属性名表达式 在JavaScript中属性名的表达式的方法有两种，一种 直接用标识符作为属性名，第二种用表达式作为属性名。第二种写的时候表达式要放在方括号之内 //一 obj.foo = true //二 obj[&apos;a&apos; + &apos;bc&apos;] = 123 //三 let t = &apos;m&apos; let obj = { [t]: true, [&apos;a&apos; + &apos;bc&apos;]: 123 } 表达式还可以用来定义方法名(注意：属性名表达式不能和简洁表示法同时使用) let obj = { [&apos;h&apos; + &apos;ello&apos;]() { return &apos;hi&apos; } } obj.hello() // hi 如果属性名表达式是一个对象，则默认情况下会自动将对象转为字符串[object Object] const ka = {a: 1} const kb = {b: 2} const myObj = { [ka]: &apos;va&apos;, [kb]: &apos;vc&apos; } myObj // Object {[object Object]: &apos;vc&apos;} 3. 方法的 name 属性 函数的name 属性，返回函数名，对象方法也是函数，因此也由name 属性 const p = { n() { console.log(&apos;h&apos;) } } p.n.name // n 特殊情况 getter 和 setter 属性是在 get 和 set上面 const obj = { get foo() {}, set fod() {} } obj.foo.name // undefined const d = Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;) d.get.name // get foo d.set.name // set fod 特殊情况 bind创造的函数 name 属性返回 bound 加上原有函数的名字 var do = function(){ } do.bind().name // bound do 特殊情况 Function构造函数创造的函数，name 返回 anonymous (new Function()).name // anonymous 如果对象的方法是一个Symbol 那么name 返回这个 Symbol的描述 const k = Symbol(&apos;描述&apos;) k.name // &quot;[描述]&quot; 4. 属性的可枚举性和遍历可枚举性 对象的每个属性都有一个描述对象，用来控制该属性的行为，Object.getOwnPropertyDescriptor 方法可以获取该属性的描述对象 let obj = {f: 234} Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;) // { // value: 234, // writable: true, // enumerable: true, // configurable: true // } 描述对象的 enumerable 属性，称为 “可枚举性”，如果该属性为true就表示某些操作会忽略当前操作 有四个操作会忽略 enumerate 为 false 的属性 - for...in循环： 只遍历对象自身和继承的可枚举的属性 - Object.keys()：返回对象自身的所有可枚举的属性的键名 - JSON.stringify(): 只串行化对象自身的可枚举的属性 - Object.assign(): 忽略enumerable为false的属性，只 拷贝对象自身的可枚举的属性 ES6中 所有class 的原型的方法都是不可枚举的 属性的遍历 ES6一共有5种方法可以遍历对象的属性。 （1）for...in for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 （2）Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 （3）Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 （4）Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。 （5）Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 1）for..in 以上五种方法遍历对象的键名，都遵循同样的属性遍历的次序股则 首先遍历所有数值键，按照数值升序排列。 其次遍历所有字符串键，按照加入时间升序排列。 最后遍历所有 Symbol 键，按照加入时间升序排列。 5. super关键字 this的关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字 super，指向当前对象的原型对象 注意：super关键字表示原型对象时，只能用在对象的方法之中，用在其他他地方都会报错。 // 报错 const obj = { foo: super.foo } // 报错 const obj = { foo: () =&gt; super.foo } // 报错 const obj = { foo: function () { return super.foo } } 上面三种super的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是super用在属性里面，第二种和第三种写法是super用在一个函数里面，然后赋值给foo属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。","tags":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jiaopianjun.cc/tags/ECMAScript6/"}]},{"title":"Node.js 回调函数和事件循环","date":"2019-05-14T13:33:00.000Z","path":"2019/05/14/Node.js 回调函数和事件循环.html","text":"1. node.js 回调函数 node.js 的异步编程思想最直接的体现就是回调，在node中大量使用了回调函数，所有的API都支持回调函数，回调函数一般作为最后一个参数出现，正因为这样node在执行代码的时候就没有阻塞或者等待的操作，提高了node的性能，可以处理大量的并发请求。 function f1(name, age, callback){} function f2(name, callback, callback2){} 阻塞代码实例创建一个文件input.txt内容如下： 这是一个阻塞代码的实例 创建 node.js： var fs = require(&apos;fs&apos;); var data = fs.readFileSync(&apos;input.txt&apos;) console.log(data.toString()) console.log(&apos;程序执行结束！&apos;) 结果如下： 这是一个阻塞代码的实例 程序执行结束！ 如上：阻塞代码就是需要等待前面的代码执行完成后才能继续往后执行。 非阻塞代码实例创建一个文件input.txt内容如下： 这是一个非阻塞代码的实例 创建 node.js： var fs = require(&apos;fs&apos;) fs.readFile(&apos;input.txt&apos;, function(err, data){ if (err) return console.log(err) console.log(data.toString()) }) console.log(&apos;over&apos;) 结果如下： over 这是一个阻塞代码的实例 如上，就是程序不必等到读取操作而直接执行后面的代码，等到读取完成后在执行读取文档的相关操作。 总结 阻塞是按顺序执行的，而非阻塞是不需要按照顺序的，需要处理的事件就写在回调函数之内即可。 node.js 事件循环 node.js 是单进程单线程应用程序，但是因为V8引擎提供的异步执行回调接口，通过这些接口可以处理大量并发，所以性能非常高，在nodejs中所有的事件机制都是用设计模式中观察者模式实现 node.js 单线程进入一个 while 的事件循环，知道没有事件观察者退出，每个异步事件都生成一个事件观察者，如果事件发生就调用该回调函数 node.js 事件驱动程序 node.js 使用事件驱动模型，当web server 接受到请求，就把它关闭然后处理，在去处理下一个web请求。当这个请求完成后，它会被放回到处理队列的开头，并将这个结果返回给用户。 node.js 的事件驱动扩展性非常强，因为web server一直在接受请求，而不进行任何等待操作，效率非常的高。整个流程类型观察者模式，事件相当于一个主题，所有注册到这个事件上的处理函数相当于观察者。 内置实例// 引入 events 模块 var events = require(&apos;events&apos;); // 创建 eventEmitter 对象 var eventEmitter = new events.EventEmitter(); 绑定事件： // 绑定事件及事件的处理程序 eventEmitter.on(&apos;eventName&apos;, eventHandler); 触发事件： // 触发事件 eventEmitter.emit(&apos;eventName&apos;); 实例// 引入 events 模块 var events = require(&apos;events&apos;); // 创建 eventEmitter 对象 var eventEmitter = new events.EventEmitter(); // 创建事件处理程序 var connectHandler = function connected() { console.log(&apos;连接成功。&apos;); // 触发 data_received 事件 eventEmitter.emit(&apos;data_received&apos;); } // 绑定 connection 事件处理程序 eventEmitter.on(&apos;connection&apos;, connectHandler); // 使用匿名函数绑定 data_received 事件 eventEmitter.on(&apos;data_received&apos;, function(){ console.log(&apos;数据接收成功。&apos;); }); // 触发 connection 事件 eventEmitter.emit(&apos;connection&apos;); console.log(&quot;程序执行完毕。&quot;); 执行结果： 连接成功 数据接受成功 程序执行完毕 node 应用程序如何工作 在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。 具体案例可以看上文的 非阻塞代码的实例： 正常执行结果就如上 如果把input.txt删除，那么就导致程序读取错误，就会走到代码的 err部分，就会出现如下结果： over Error: ENOENT, open &apos;input.txt&apos;","tags":[{"name":"node学习","slug":"node学习","permalink":"https://jiaopianjun.cc/tags/node学习/"}]},{"title":"重学JavaScript之DOM级别","date":"2019-05-09T13:32:00.000Z","path":"2019/05/09/重学JavaScript之DOM级别.html","text":"JavaScript是一种专门为网页交互而设计的脚本语言，主要由三个不同的部分组成。 1. ECMAScript由ECMA-262 定义，提供核心语言功能 2. 文档对象模型DOM（提供访问和操作网页内容的方法和接口） DOM 是针对于XML和已经扩展用于HTML的应用程序，DOM把整个页面映射为一个多层节点结构，这些节点又包含不同类型的数据，通过DOM的创建，我们可以获得页面的控制权，删除、添加、替换任何节点。 2.1 DOM级别2.1.1 DOM1由DOM核心和DOM HTML组成， DOM核心规定如何映射基于XML的文档结构，DOM HTML 则在DOM核心的基础上加以扩展，添加针对HTML的对象和方法。 2.1.2 DOM2DOM2在DOM1的基础上增加了 DOM视图、事件、样式、遍历和范围等功能 2.1.3 DOM3DOM3在DOM2的基础上进一步的引入了统一方式加载和文档保存的方法 3. 浏览器对象模型（BOM） BOM 只处理浏览器窗口和框架，提供浏览器交互和方法，以及如下功能： 弹窗新浏览器窗口的功能 移动、缩放和关闭浏览器窗口的功能 提供浏览器详细信息的navigator对象 提供浏览器加载页面信息的对象 location 提供 显示器分辨率属性 screen 对 cookie 支持 对 XMLHttpRequest 和 IE 的 ActiveXObject 自定义对象","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiaopianjun.cc/tags/JavaScript/"}]},{"title":"Flex布局入门","date":"2019-05-09T13:31:00.000Z","path":"2019/05/09/Flex布局入门.html","text":"1. flex (弹性布局) 主要提供简便、完整、响应式布局解决方法，设置flex布局后元素的 float、clear、vertical-align属性将失效 主要参数： flex-direaction 决定主轴的方向 - 参数： - row(默认值): 主轴为水平方向，起点在左端 - row-reverse： 同上，起点在右端 - column： 主轴为垂直方向，起点在上方 - column-reverse： 同上，起点在下方 flex-wrap 如果默认轴线排序不下，则换行 - 参数： - nowrap(默认): 不换行 - wrap： 换行，第一行在上方 - wrap-reverse： 换行，第一行在下方 flex-flow 是flex-direaction 和 flex-wrap的简写 justify-content 在主轴（水平）上的对齐方式 - 参数： - flex-start(默认值): 左对齐 - flex-end： 右对齐 - center： 居中 - space-between： 两端对齐，项目之间间隔相等 - space-around： 项目两侧有间隔，类似margin后的效果 align-items 定义项目交叉（垂直）轴上如何对齐 - 参数： - flex-start: 起点对齐 - flex-end: 重点对齐 - center: 重点对齐 - baseline: 第一行文字的基线对齐 - stretch: 如果项目未设置高度或者auto，将占满整个容器 align-content 多根轴线的对齐方式，单一不起作用 - 参数： - flex-start: 交叉轴 起点对齐 - flex-end: 交叉轴 终点对齐 - center: 交叉轴 中点对齐 - space-between: 交叉轴两端对齐，轴线之间平均分布 - sapce-around: 同margin - stretch: 占满整个交叉轴 其他参数 order 定义上项目的排列顺序，数值越小，排列越靠前，默认为0 flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大 flex-shrink 定义项目的缩小比例，默认为1，空间不足，该项目将缩小 flex-basis 在分配多余空间之前，先计算是否有多余空间 flex 上面三个的简写 align-self 允许单个项目和其他项目有不一样的对齐方式，可覆盖align-items属性， 默认auto，表示继承父元素的align-items属性，如果没有父元素则等同于stretch","tags":[{"name":"css","slug":"css","permalink":"https://jiaopianjun.cc/tags/css/"}]},{"title":"ES6入门之数组的扩展","date":"2019-05-08T08:35:00.000Z","path":"2019/05/08/ES6入门之数组的扩展.html","text":"1. 扩展运算符 …表示，将一个数组转为用逗号分隔的参数序列，如下： console.log(...[1,2,3]) // 1 2 3 console.log(1, ...[2,3,4], 5) // 1 2 3 4 5 [...document.querySelectorAll(&apos;div&apos;)] // [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] function add(x, y){ return x + y } const n = [3, 5] add(...n) // 8 扩展运算符可以和正常函数结合使用，如下：function f(a,b,c,d,e){ console.log(a,b,c,d,e) } const age = [0,1] f(-1,...age,2,...[3]) // -1 0 1 2 3 扩展运算符后面也可以是表达式，如下：const x = 10 const arr = [ ...(x &gt; 0 ? [&apos;a&apos;] : []), &apos;b&apos;, ] arr // [&apos;a&apos;, &apos;b&apos;] 重要：如果扩展运算符后面是一个空数组，将不会有任何效果。另外只有在函数调用的时候扩展函数在放在圆括号之内，其他的则会报错。替代函数的apply方法 扩展函数可以展开数组，所以将不需要apply方法来将数组转换为函数的参数。 function f(x, y, z){ console.log(x, y, z) } var a = [1,2,4] // ES5 f.apply(null, args) // ES6 f(...a) // Math.max方法 //ES5 Math.max.apply(null, [14, 3, 99]) //ES6 Math.max(...[12, 4, 55]) //等同于 Math.max(12, 4, 55) // push方法的应用 var a = [0,1,2] var b = [3,4,5] //ES5 Array.prototype.push.apply(a,b) // 0,1,2,3,4,5 //ES6 a.push(...b) 扩展运算符的应用 复制数组 因为数组是复合的数据类型，直接的复制只是复制数组在堆内存中的指针地址 const a1 = [1,2] const a2 = a1 a2[0] = 3 a1 // [3,2] // ES5 通过变通方法来复制 const a1 = [1,2] const a2 = a1.concat() a2[0] = 23 a1 // [1,2] // ES6写法 const b1 = [1,3] const b2 = [...b1] or [...b2] = b1 合并数组 const a1 = [&apos;b&apos;, &apos;c&apos;] const a2 = [&apos;d&apos;] const a3 = [&apos;x&apos;, &apos;y&apos;] // ES5中合并数组 a1.concat(a2, a3) // ES6中合并数组 [...a1, ...a2, ...a3] //以上两种都是浅拷贝，修改原数组和同步新数组 与解构赋值一起使用,扩展只能放在最后一位，不然会报错 // ES5 a = list[0], rest = list.slice(1) // ES6 [a,...rest] = list // 其他 const [a,...c] = [1,2,4,5,4,6] // a 1 c 2,4,5,4,6 const [a,...c] = [] // a undefined c [] const [a,...c] = [&apos;a&apos;] // a &apos;a&apos; c [] 字符串，将字符串转换为数组 [...&apos;hello&apos;] // [h,e,l,l,0] 实现了Iterator接口的对象 任何定义了遍历器接口对象，都可以用扩展运算符转为真正的数组 let nodelist = document.querySelectorAll(&apos;div&apos;) let array = [...nodelist] // querySelectorAll 返回的是一个类数组，通过扩展运算符 将其转换为一个真正的数组 Map 和 Set 解构，Generator函数 扩展运算符调用的是数据解构的Iterator接口，只要有Iterator接口的 对象，都可以使用扩展运算符 // Map let map = new Map([ [1, &apos;a&apos;], [2, &apos;b&apos;], [3, &apos;c&apos;], ]) let arr = [...map.keys()] // 1, 2, 3 let arr = [...map.values()] // &apos;a&apos;, &apos;b&apos;, &apos;c&apos; //Generator函数 const go = function*(){ yield 1; yield 2; yield 3; } [...go()] // [1, 2, 3] 2. Array.from() Array.from 方法用于将两类对象转为真正的数组。1、类似数组对象 和 可遍历的对象（包裹Set和Map），如下： let arrLike = { &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;, length: 3 } // ES5 var a1 = [].slice.call(arrLike) // ES6 var a2 = Array.from(arrLike) 在实际中，像获取dom后返回的Nodelist集合，以及函数内部的arguments对象就是类数组，通过 Array.from将它们转换为真正的数组。 // NodeList 对象 let ps = document.querySelectorAll(&apos;p&apos;) Array.from(ps).filter(p =&gt; { return p.textContent.length &gt; 100 }) // arguments 对象 function foo(){ var arg = Array.from(arguments) } // 只要部署了Iterator接口的数据解构，Array.from都能将其转成数组 Array.from(&apos;hello&apos;) // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;] let nl = new Set([1, 2]) Array.from(nl) // [1, 2] // 如果是真数组则返回一样的 Array.from([1, 2, 3]) // [1, 2, 3] … 扩展运算符也可以将某些类数组转换为数组，如arguments和NodeList集合 拥有lenght属性的对象都可以通过Array.from转换为数组，而扩展运算符则不行。 Array.from({lenght:3}) // [undefined, undefined, undefined] 对于低版本的浏览器，可以通过 Array.prototype.slice 方法替代 Array.from 还可以接受第二个参数如同map一样，用来对每个元素进行操作，并将处理后的值放入返回的数组中。 const arrlike = new Set([1,2,3]) Array.from(arrlike, x =&gt; x * x) // = Array.from(arrlike).map(x =&gt; x * x) // [1, 4, 9] //注意： 如果map中用到了this，可以传入Array.from 的第三个参数，用来绑定this Array.from 可以将各种值转换为真正的数组，并且还提供map相关功能，这样代表如果有个原始数据结构，可以先将他转换为数组，然后使用数组相关的方法。 3. Array.of() 用于将一组值，转换为数组。主要用来弥补Array函数因为参数个数不同而导致的差异 Array.of(3,11,6) // [3, 11, 6] Array.of(3) // [3] Array.of(4).length // 1 4. 数组的实例 copyWithin() 将当前数组中指定位置的元素复制到另外一个位置，并且会覆盖那个位置的原有元素，会修改当前数组 // 有三个参数 1. target(必须)：从该位置开始替换数据，如果是负值，则倒数 2. start(可选)：从该位置读取数据，默认0，负值同上 3. end(可选)：到这个位置停止读取数据，默认等于数组长度，负值同上 let p = [1,2,3,4,5,6,7] p.copyWithin(0,5,7) [6, 7, 3, 4, 5, 6, 7] 5. 数组实例的 find() 和 findIndex() find 用来找出数组中符合条件的成员，它的参数是一个回调函数，找到一个返回值为true的返回，如果没有则返回undefined let s = [1,2,3,4,5,6] s.find(x =&gt; x &gt; 4) // 5 find 方法的回调函数有三个参数 value // 当前值 index // 当前的位置 arr // 原数组 findIndex 同find方法类似，只不过都不符合返回的是 -1,而且符合是返回符合条件值的位置而不是值。 let s = [1,2,3,4,5,6] s.find(x =&gt; x &gt; 4) // 4 find 和 findIndex 都可以接受第二个参数 function o(p){ return p &gt; this.age } const u = {name: &apos;cx&apos;, age: 11} const y = [8,11,22,2,4] y.find(o, u) // 22 返回的值 y.findIndex(o, u) // 2 返回值的位置 6. 数组实例的 fill() 通过给定值，填充一个数组 let sz = [1,2,3,4,5,6] sz.fill(1) // [1,1,1,1,1,1] sz.fill(1,0,3) // 接受三个参数，第一个为填充值，第二个为起始位置，第三个为截至位置 sz.fill(1,3) // 如果省略最后一个参数，则默认从起始位置到数组默认长度结束 7. 数组实例的 entries(), keys(), values() 三种方法主要用于遍历数组，可以用 for…of…进行遍历，keys()对应键名，values对应键值,entries()对键值对的遍历 let bo = [&apos;a&apos;, &apos;c&apos;] for(let r of bo.keys()){ console.log(r) // 0 1 } // 0 1 for(let n of bo.values()){ console.log(n) } // a c for(let s of bo.entries()){ console.log(s) } // [0, &quot;a&quot;] // [1, &quot;c&quot;] 8. 数组实例的 includes() 用来表示某个数组是否包含给定的值，返回一个布尔值 let i = [&apos;a&apos;,1,2,3] i.includes() // false i.includes(1) // true i.includes(10) // false indexOf 和includes 的区别 indexOf // 不够语义化，它的作用是找到参数出现的第一个位置， 所以要比较是否为 -1,另外由于 内部使用的是 === 则导致NaN 的误判。 // [NaN].indexOf(NaN) // -1 includes // 使用的是不一样的算法，则不会有这个问题 // [NaN].includes(NaN) // true Map 和 Set 的has 方法和includes的区别 Map 的has 方法是用来查找键名的 Set 的has 方法是用来查找值的 9. 数组的实例 flat(), flatMap() flat() 将嵌套的二维数组变成一维数组，如果需要拉平多维数组，则flat(多维数量) 或者使用 Infinity 直接转为一维数组 let rw = [1,2,3,[4,5,6],7] rw.flat() // [1, 2, 3, 4, 5, 6, 7] let dw = [1,2,3,[4,5,6,[7,8],[2,[&apos;a&apos;,&apos;b&apos;],4,5]],[5,6,]] dw.flat(3) // [1, 2, 3, 4, 5, 6, 7, 8, 2, &quot;a&quot;, &quot;b&quot;, 4, 5, 5, 6] // 如果你不知道是多少层嵌套而都想转成一维，可以使用 Infinity dw.flat(Infinity) // [1, 2, 3, 4, 5, 6, 7, 8, 2, &quot;a&quot;, &quot;b&quot;, 4, 5, 5, 6] flatMap() 对数组执行map，然后对返回值组成的数组 执行flat，不会改变原数组。flatMap只能展开一层数组。 let mp = [2,3,4,5] mp.flatMap((item) =&gt; [item, item* 2]) // [2, 4, 3, 6, 4, 8, 5, 10] ==== mp.map((item) =&gt; [item, item*2]) // [[2,4],[3,6],[4,8],[5,10]] mp.flat() // [2, 4, 3, 6, 4, 8, 5, 10] 10. 数组的空位(避免出现空位) 数组的空位指的是该数组中某一个位置没有任何值。另外空位不是undefined，如果一个位置的值是undefined，那么这个位置还是有值的。 Array(3) // [, , ,] ES5中大多数情况中对待空位都是会忽略 - forEach(), filter(), reduce(), every() 和 some() 都会跳过空位 - map() 跳过但保留这个值 - join() 和 toString() 中 空位 === undefined，而 undefined和null会被处理成空字符串 ES6 中 空位则转换为undefined - Array.from([1,,2]) // [1, undefined, 2] - [...[&apos;a&apos;,,&apos;b&apos;]] // [ &quot;a&quot;, undefined, &quot;b&quot; ] entries() keys() values() find() findIndex() // 都会将空位处理成undefined。","tags":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jiaopianjun.cc/tags/ECMAScript6/"}]},{"title":"重学Javascript之基础知识","date":"2019-05-05T13:32:00.000Z","path":"2019/05/05/重学JavaScript之基础数据.html","text":"第一章 javascript字符串1.0、字符串基本数据类型1、javascript字符串可以是一个基本数据类型或者一个对象 2、与JavaScript中其他四种数据类型并列：数字、布尔、null 和 undefined 3、作为基本数据类型，字符串也是JavaScript直接量：这是一个集合，包含数字 数组 对象和正则表达式、数字和布尔值的直接量格式 1.0、字符串对象123456789101112131415161、字符串对象叫做string，与其他JavaScript对象一样，它拥有预先构建到对象类型中的一组属性2、可以使用JavaScript的new运算符来实例化一个string对象，从而创建一个新的对象实例： var city = new String(\"This is pin\")3、一旦实例化了，可用的字符串属性的任何一个，都可以通过字符串进行访问，例如： var lcCity = city.toLowerCase(); // 将字符串中的大写字母转换成小写 结果：this is pin 4、如果你没有使用new来访问String构造函数，将会创建一个字符串直接量，而不是一个String对象 var city = String(\"Ar. louis\");5、如果需要在一个直接量上访问String 对象方法：让JavaScript引擎创建了一个String对象，用它包含了字符串直接量，执行方法调用，然后丢弃掉string对象6、与使用字符串直接量相比，使用String的时候，要依赖于具体环境，除非你计划使用String对象属性，否则应该尽可能地使用字符串直接量，如果你要使用String方法，那么将字符串创建为对象。 1.1、连接两个或多个 字符串12345678910111、问题：想要把两个或者多个字符串合并为一个 解决方案： 使用相加（+）运算符来连接字符串 var str1 = 'ming tian'; var str2 = 'qu na li'; var str3 = str1 + str2; // ming tian qu na li 2、有一个内建的string 方法，可以连接多个字符串，这就是concat,它接受一个或者多个字符串参数，其中每一个都连接到字符串对象的末尾； var str = \"\" .concat(\"ni\",\"shi\",\"yi\",\"zhu\") //ni shi yi zhu 1.2、连接字符串和另一种数据类型12345678910111、问题：想要把一个字符串和另一种数据类型（如数字）连接起来 解决方案： 使用与连接字符串的时候完全相同的运算符 + 或者 += var num = 131 var str = \"ni shi shui\" var strr2 = str + num //ni shi shui 131 2、注意点： 当把一个字符串和其他数据类型相加的时候，过程有所不同。在其他数据类型的情况下，如布尔或者数字， js引擎先将其他数据转换为一个字符串，然后在将其连接 1.3、条件比较字符串1234567891、问题：想要比较两个字符串看看是否相同 解决方案： 使用 == 运算符来判断 如果遇到大小写混合的例子可以先使用 toLowerCase 或 toUpperCase 将字符串转换为大写或者小写来比对，这两个方法不接受任何参数。 2、有时候，不想让自动数据发生转化，想要在比较的值拥有不同的数据类型时，比较失败，如果一个值是字符直接量，e","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiaopianjun.cc/tags/JavaScript/"}]},{"title":"Python基础教程之dict和set","date":"2019-04-30T14:36:00.000Z","path":"2019/04/30/Python基础教程之dict和set.html","text":"1. dict Python中的dict等于js中的 map ，使用键-值（key-value）存储，具有极快的查找速度。 如果 我们要根据同学的姓名去查找他的成绩在不用dict的情况下。就需要两个list: names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;] scores = [95, 75, 85] // 通过一个名字，去查找对应的位置，再从scores中取出对应的成绩 这样导致list的越来越长，速度越来越慢 // 如果通过dict实现，只需要“名字-成绩”就行，无论这个表多大，查找速度都不会变慢，如下： &gt;&gt;&gt; d = {&apos;Michael&apos;: 95, &apos;Bob&apos;: 75, &apos;Tracy&apos;: 85} &gt;&gt;&gt; d[&apos;Michael&apos;] 95 原理： 因为dict是通过索引去查找的而不是通过遍历的方式去找的。 // 除了初始化指定外，还可以通过key放入： &gt;&gt;&gt; d[&apos;Adam&apos;] = 67 &gt;&gt;&gt; d[&apos;Adam&apos;] 67 // 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉： &gt;&gt;&gt; d[&apos;Jack&apos;] = 90 &gt;&gt;&gt; d[&apos;Jack&apos;] 90 &gt;&gt;&gt; d[&apos;Jack&apos;] = 88 &gt;&gt;&gt; d[&apos;Jack&apos;] 88 如果key不存在，dict将会报错。 可以通过in判断key是否存在 或者通过get()方法 // in 方法 &gt;&gt;&gt; &apos;Thomas&apos; in d False // get() key不存在返回None &gt;&gt;&gt; d.get(&apos;Thomas&apos;) &gt;&gt;&gt; d.get(&apos;Thomas&apos;, -1) -1 // 删除key 通过 pop()方法 &gt;&gt;&gt; d.pop(&apos;Bob&apos;) 75 &gt;&gt;&gt; d {&apos;Michael&apos;: 95, &apos;Tracy&apos;: 85} 注意点： 1. dict 内部存放的顺序和key的放入顺序没有关系 2. 和list比较 2.1 查找和插入速度极快，不会随着key的增加而变慢 2.2 需要占用大量的内存，内存浪费多 3. 和list相反 3.1 查找和插入时间随着元素的增加而增加 3.2 占用空间小，浪费内存少 4. dict是一种以空间换时间的方法 5. dict的key必须是不可变对象 6. 字符串和整数等不可变，可以作为key，而list的则不行。 2. set 和dict类似，但是不存储value，key不重复。创建set，需要提供一个list作为输入集合，如下： &gt;&gt;&gt; s = set([1, 2, 3]) &gt;&gt;&gt; s {1, 2, 3} // 传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素， 显示的顺序也不表示set是有序的 // set中重复将会被过滤 &gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3]) &gt;&gt;&gt; s {1, 2, 3} // 通过add(key)可以向set中添加元素，可以重复添加但无效果 &gt;&gt;&gt; s.add(4) &gt;&gt;&gt; s {1, 2, 3, 4} &gt;&gt;&gt; s.add(4) &gt;&gt;&gt; s {1, 2, 3, 4} // 通过remove(key)删除元素 &gt;&gt;&gt; s.remove(4) &gt;&gt;&gt; s {1, 2, 3} set和dict的区别仅在于没有存储对应的value。 3. 不可变对象 对于可变对象，对它进行操作，对象本想将会变化 &gt;&gt;&gt; a = [&apos;c&apos;, &apos;b&apos;, &apos;a&apos;] &gt;&gt;&gt; a.sort() &gt;&gt;&gt; a [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 对于不可变对象，对象本身不会变化 &gt;&gt;&gt; a = &apos;abc&apos; &gt;&gt;&gt; a.replace(&apos;a&apos;, &apos;A&apos;) &apos;Abc&apos; &gt;&gt;&gt; a &apos;abc&apos; 所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。","tags":[{"name":"Python","slug":"Python","permalink":"https://jiaopianjun.cc/tags/Python/"}]},{"title":"Python基础教程之条件判断和循环","date":"2019-04-25T09:36:00.000Z","path":"2019/04/25/Python基础教程之条件判断和循环.html","text":"1. 条件判断 计算机之所以能做很多自动化的任务，是因为它可以自己做条件判断如下： age = 20 if age &gt;= 18: print(&apos;your age is&apos;, age) print(&apos;adult&apos;) // 如果age &gt;= 18 那么就会执行下面的语句，反之则不会执行。 age = 3 if age &gt;= 18: print(&apos;your age is&apos;, age) print(&apos;adult&apos;) else: print(&apos;your age is&apos;, age) print(&apos;teenager&apos;) // 注意 ：号，还可以用更详细的方法来执行如下： age = 3 if age &gt;= 18: print(&apos;adult&apos;) elif age &gt;= 6: print(&apos;teenager&apos;) else: print(&apos;kid&apos;) // 注意 if 的执行是自上而下执行的，而且如果第一个条件执行成功， 将不会在执行后续的 elif 2. 循环 Python 中的循环有两种，一种是for…in 循环，依次把list或者tuple中的每个元素迭代出来。第二种是while循环，只要条件满足就不断循环，条件不满足则退出。 &gt;&gt;&gt; 1 + 2 + 3 6 // 几个数的计算可以直接这样写。 // 如果要计算未知数就需要用循环，就是遍历的概念 names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;] for name in names: print(name) Michael Bob Tracy // 比如求和 sum = 0 for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]: sum = sum + x print(sum) 在Python中可以通过range()函数，生成整数序列，在通过list()函数转换为list，然后通过循环去遍历相加，如下： &gt;&gt;&gt; list(range(5)) [0, 1, 2, 3, 4] sum = 0 for x in range(101): sum = sum + x print(sum) // 遍历100 求和 while循环 sum = 0 n = 99 while n &gt; 0: sum = sum + n n = n - 2 print(sum) // while循环可以通过break提前终止循环 n = 1 while n &lt;= 100: if n &gt; 10: # 当n = 11时，条件满足，执行break语句 break # break语句会结束当前循环 print(n) n = n + 1 print(&apos;END&apos;) // while循环也可以通过continue跳过当前，执行之后的循环 n = 0 while n &lt; 10: n = n + 1 if n % 2 == 0: # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print(n) 循环是让计算机做重复任务最有效的方法。另外请不要滥用 break 和 continue 这样会造成代码执行逻辑分叉过多，容易出错。","tags":[{"name":"Python","slug":"Python","permalink":"https://jiaopianjun.cc/tags/Python/"}]},{"title":"Node.js REPL","date":"2019-04-19T13:33:00.000Z","path":"2019/04/19/Node-js-REPL.html","text":"Node.js REPL Node.js REPL (交互式解释器)，表示一个电脑的环境，类似window的终端或者shell,使的我们可以在终端中输入名，并接受系统的响应。Node自带了交互式解释器，可以执行下面任务： 1. 读取 - 读取用户输入，解析输入了JavaScript数据结构并存储到内存中。 2. 执行 - 执行输入的数据结构 3. 打印 - 输出结果 4. 循环 - 循环操作以上步骤直到用户按下两次Ctrl-c 退出 我们在安装Node后 可以通过输入node启动终端 1. 简单的表达式运算$ node &gt; 1 +4 5 &gt; 5 / 2 2.5 &gt; 3 * 6 18 &gt; 4 - 1 3 &gt; 1 + ( 2 * 3 ) - 4 3 &gt; ctrl + c - 退出当前终端。 2. 使用变量 你可以将数据存储在变量中，并在你需要的时候使用它。 变量声明需要使用 var 关键字，如果没有使用 var 关键字变量会直接打印出来。 使用 var 关键字的变量可以使用 console.log() 来输出变量。 $ node &gt; x = 10 10 &gt; var y = 10 undefined &gt; x + y 20 &gt; console.log(&quot;Hello World&quot;) Hello World undefined &gt; console.log(&quot;www.runoob.com&quot;) www.runoob.com undefined 3. 多行表达式 Node REPL 支持输入多行表达式，这就有点类似 JavaScript。接下来让我们来执行一个 do-while 循环： $ node &gt; var x = 0 undefined &gt; do { ... x++; ... console.log(&quot;x: &quot; + x); ... } while ( x &lt; 5 ); x: 1 x: 2 x: 3 x: 4 x: 5 undefined &gt; ctrl + c 按下两次 - 退出 Node REPL。 // ... 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式。 4. 下划线(_)变量 你可以使用下划线(_)获取上一个表达式的运算结果： $ node &gt; var x = 10 undefined &gt; var y = 20 undefined &gt; x + y 30 &gt; var sum = _ undefined &gt; console.log(sum) 30 undefined &gt; 5. REPL 命令ctrl + d - 退出 Node REPL. 向上/向下 键 - 查看输入的历史命令 tab 键 - 列出当前命令 .help - 列出使用命令 .break - 退出多行表达式 .clear - 退出多行表达式 .save filename - 保存当前的 Node REPL 会话到指定文件 .load filename - 载入当前 Node REPL 会话的文件内容。","tags":[{"name":"node学习","slug":"node学习","permalink":"https://jiaopianjun.cc/tags/node学习/"}]},{"title":"Python基础教程之list和tuple","date":"2019-04-19T03:36:00.000Z","path":"2019/04/19/Python基础教程之list和tuple.html","text":"1. list Python内置的一种数据类型是列表，list 它是一种有序的集合，可以随时添加和删除其中的元素。 &gt;&gt;&gt; classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;] &gt;&gt;&gt; classmates [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;] // 变量 classmates就是一个list，可以通过len(classmates) 来查看classmates的长度。 可以通过索引来访问list中每一个位置的元素，索引从0开始。 &gt;&gt;&gt; classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;] &gt;&gt;&gt; classmates[0] // &apos;Michael&apos; &gt;&gt;&gt; classmates[1] // &apos;Bob&apos; &gt;&gt;&gt; classmates[2] // &apos;Tracy&apos; // 如果索引超过list的范围，将会报错。所以我们将最后一个索引的元素 设置为 len(classmates) -1,如果要取最后一个元素，除了索引， 我们可以通过-1直接获取最后一个元素。 &gt;&gt;&gt; classmates[-1] // &apos;Tracy&apos; &gt;&gt;&gt; classmates[-2] // &apos;Bob&apos; &gt;&gt;&gt; classmates[-3] // &apos;Michael&apos; list 是一个有序列表，我们可以往list中追加元素到末尾，也可以把元素插入的指定的位置。 &gt;&gt;&gt; classmates.append(&apos;Adam&apos;) &gt;&gt;&gt; classmates [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, &apos;Adam&apos;] // 插入 索引为1的位置 &gt;&gt;&gt; classmates.insert(1, &apos;Jack&apos;) &gt;&gt;&gt; classmates [&apos;Michael&apos;, &apos;Jack&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, &apos;Adam&apos;] // 删除末尾的元素 用pop() &gt;&gt;&gt; classmates.pop() &apos;Adam&apos; &gt;&gt;&gt; classmates [&apos;Michael&apos;, &apos;Jack&apos;, &apos;Bob&apos;, &apos;Tracy&apos;] // 删除指定位置 pop(i) &gt;&gt;&gt; classmates.pop(1) &apos;Jack&apos; &gt;&gt;&gt; classmates [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;] // 替换指定位置元素 &gt;&gt;&gt; classmates[1] = &apos;Sarah&apos; &gt;&gt;&gt; classmates [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] // list中的元素数据类型可以不同 &gt;&gt;&gt; L = [&apos;Apple&apos;, 123, True] // 也可以放入另外一个list &gt;&gt;&gt; s = [&apos;python&apos;, &apos;java&apos;, [&apos;asp&apos;, &apos;php&apos;], &apos;scheme&apos;] &gt;&gt;&gt; len(s) 4 // 它只有4个长度，因为里面的list 算一个整体的。 2. tuple Python 中还有一种有序列表叫元组：tuple，tuple和list非常类似，但是tuple一旦初始化，将不能修改而且一旦定义就必须赋值，也可以为空。所以这样将更安全。可以理解为常量的概念。写法如下： &gt;&gt;&gt; classmates = (&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;) &gt;&gt;&gt; t = (1, 2) &gt;&gt;&gt; t (1, 2) &gt;&gt;&gt; t = () // 为空 &gt;&gt;&gt; t = (1) // 定义一个元素但是这样比不是一个tuple &gt;&gt;&gt; t = (1,) // 这样才是一个元素的tuple,必须要加 , 号 &gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;, [&apos;A&apos;, &apos;B&apos;]) &gt;&gt;&gt; t[2][0] = &apos;X&apos; &gt;&gt;&gt; t[2][1] = &apos;Y&apos; &gt;&gt;&gt; t (&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;]) // 其他的写法 这时候是可以修改里面列表的值如上","tags":[{"name":"Python","slug":"Python","permalink":"https://jiaopianjun.cc/tags/Python/"}]},{"title":"ES6入门之函数的扩展","date":"2019-04-18T13:35:00.000Z","path":"2019/04/18/ES6入门之函数的扩展.html","text":"# 1. 函数参数的默认值 1.1 用法 在ES6之前是不能为函数的参数指定默认值的，要想实现默认值只能通过判断赋值的方式来实现，在ES6中允许函数为参数设置默认值，主要是为了提高代码的可阅读性，有利于代码的优化。另外注意的是在参数赋值的时候，该参数不能重复使用，不能使用let const 进行定义。 // ES6 之前实现 function log(x, y) { y = y || &apos;World&apos;; if (typeof y === &apos;undefined&apos;) { y = &apos;World&apos;; } console.log(x, y); } log(&apos;Hello&apos;) // Hello World log(&apos;Hello&apos;, &apos;China&apos;) // Hello China log(&apos;Hello&apos;, &apos;&apos;) // Hello World // ES6 中实现 function log(x, y = &apos;World&apos;) { console.log(x, y); } log(&apos;Hello&apos;) // Hello World log(&apos;Hello&apos;, &apos;China&apos;) // Hello China log(&apos;Hello&apos;, &apos;&apos;) // Hello function Point(x = 0, y = 0) { this.x = x; this.y = y; } const p = new Point(); p // { x: 0, y: 0 } function foo(x = 5,x) { let x = 1; // 报错，不能同名参数，不能对参数进行let const 定义 const x = 2; } 1.2 与解构赋值一起使用 如果函数在调用的时候没有提供参数，内部变量就不会产生，就会产生错误，通过提供函数的默认值可以解决这种问题，如下： function foo({x, y = 5}) { console.log(x, y); } foo() // 报错 foo({x:1}) // 1 5 foo({x:2,y:3) // 2 3 foo({}) // undefined 5 function foo ({x,y = 5} = {}){ console.log(x,y) } foo() // undefined 5 这样就是如果没有在调用的时候传值 就默认赋空对象。 如下例子： function post(url, {b = &apos;&apos;,type=&apos;get&apos;,h={}}){ console.log(type) } post(&apos;w.b.c&apos;,{}) // get post(&apos;w.b.c&apos;) // 报错 // 改成这样就可以了 function post(url, {b = &apos;&apos;,type=&apos;get&apos;,h={}} = {}){ console.log(type) } post(&apos;w.b.c&apos;,{}) // get post(&apos;w.b.c&apos;) // get 下面例子的区别 // 写法一 function m1({x = 0, y = 0} = {}) { return [x, y]; } // 写法二 function m2({x, y} = { x: 0, y: 0 }) { return [x, y]; } 两个都是有默认值在调用的时候都传值或者都不传值的时候情况是一样的。 但是如果传空值，或者不传值的情况会有差异如下： m1({}) // 因为本身有默认值 所以为 [0,0] m2({}) // 默认值为空 解构赋值没有传值 所以 [undefined,undefined] // 其他情况同上 m1({x: 3}) // [3, 0] m2({x: 3}) // [3, undefined] m1({z: 3}) // [0, 0] m2({z: 3}) // [undefined, undefined] 1.3 参数默认值的位置 如果定义了默认值的参数，应该是函数的尾参数。而且这个参数是无法省略的，除非输入undefined 1.4 函数的 length 属性 函数参数指定了默认值之后，函数的length属性将会减去指定了默认值的参数个数。因为该属性认为，指定了默认值的参数将不包含在预期参数个数中。如下： (function (a) {}).length // 1 (function (a = 5) {}).length // 0 (function (a, b, c = 5) {}).length // 2 1.5 作用域 如果函数中的参数设置了默认值，那么函数在声明初始化的时候，参数会形成一个单独的作用域，初始化完成后这个作用域就会消失，这种情况只在参数设置了默认值的情况下。如下： var x = 1; function f(x, y = x) { console.log(y); } f(2) // 2 // 因为 设置了默认值 所以在调用 f 的时候就形成了作用域，这时候因为将x赋值给y 传入的x 为 2 所以y是2，如果这时候 调用的时候不传值， 那么x将指向全局，所以y = 1 1.6 应用 利用参数默认值，可以指定某一个参数不得省略，如果省略就报错，如下 function throwIfMissing() { throw new Error(&apos;Missing parameter&apos;); } function foo(mustBeProvided = throwIfMissing()) { return mustBeProvided; } foo() // Error: Missing parameter foo(2) // 2 2. rest 参数 ES6 中 增加了 rest 参数（…变量名），用于获取函数多余的参数，rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 function add(...values) { let sum = 0; for (var val of values) { sum += val; } return sum; } add(2, 5, 3) // 10 // 注意：rest 参数之后不能再有其他参数，另外rest参数也不计算在 函数的length属性中。 3. 严格模式 ES6 中，如果函数参数使用了默认值，解构赋值，或者扩展运算符，那么函数内部将不能显式设定为严格模式，否则会报错。因为函数执行的时候 先执行函数参数，在执行函数体，但是因为只有在函数体中才能知道参数是否以严格模式执行，但是参数却应该先于函数执行。有两种方法可以规避：一、 设置全局严格模式，二、把函数包在一个无参数的立即执行函数里面。 4. name属性 返回函数的函数名，如下： function foo(){} foo.name // foo var f = function(){} // ES5 f.name // &apos;&apos; // ES6 f.name // f var f = function c(){} f.name // c 5. 箭头函数 ES6 允许使用 “箭头” （=&gt;）定义函数 var f = v =&gt; v; // 等同于 var f = function (v) { return v; }; var f = () =&gt; 5; // 等同于 var f = function () { return 5 }; var sum = (num1, num2) =&gt; num1 + num2; // 等同于 var sum = function(num1, num2) { return num1 + num2; }; // 如果箭头函数后面的语句较多就要用大括号包裹起来 并return返回 var sum = (num1, num2) =&gt; { return num1 + num2; //rest 参数与箭头函数结合的例子。 const numbers = (...nums) =&gt; nums; numbers(1, 2, 3, 4, 5) // [1,2,3,4,5] const headAndTail = (head, ...tail) =&gt; [head, tail]; headAndTail(1, 2, 3, 4, 5) // [1,[2,3,4,5]] 注意点1. 函数体内的this对象，就是在定义时所在的对象，而不是使用时所在的对象。 2. 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 3. 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 4. 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 5. 由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。 不适用场景1. 定义对象的方法，且该方法内部包括this 2. 动态定义this 的场合，如点击事件中this 的指向 嵌套的箭头函数 箭头函数内部可以在嵌套使用箭头函数。 6. 尾调用优化什么是尾调用 函数式编程的一个重要概念，指某个函数的最后一步是调用另一个函数 function f(x){ return g(x); } // 一下都不属于 // 情况一 function f(x){ let y = g(x); return y; } // 情况二 function f(x){ return g(x) + 1; } // 情况三 function f(x){ g(x); } 尾调用优化 只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 function f() { let m = 1; let n = 2; return g(m + n); } f(); // 等同于 function f() { return g(3); } f(); // 等同于 g(3); 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 尾递归 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。尾递归优化的实现 在正常模式下，可以使用减少调用栈，采用循环换掉递归的方法","tags":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jiaopianjun.cc/tags/ECMAScript6/"}]},{"title":"CSS函数","date":"2019-04-09T13:30:00.000Z","path":"2019/04/09/CSS函数.html","text":"1. attr() 用来选择元素的属性值，用法：attr(html元素的属性名)，正常搭配css content一起使用 html: &lt;p&gt;&lt;a href=&quot;http://a.b.c&quot; name=&quot;attr&quot;&gt;十&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;http://d.f.e&quot; name=&quot;我是谁&quot;&gt;九&lt;/a&gt;&lt;/p&gt; css: a:after{content:&apos;(&apos;attr(href) &apos;/&apos; attr(name) &apos;)&apos;} 结果： 十(http://a.b.c / attr) 九(http://d.f.e / 我是谁) 2. calc() 用于动态计算长度值 calc(数学表达式) 运算符前后需要有空格 不管什么长度都可以用calc计算 calc() 支持 ‘+’,’-‘,’*’,’/‘ 等运算 calc() 使用标准的数学运算优先级规则 语法： width: calc(70% - 60px) height: calc(70% / 2 * 12 + 66px) 3. linear-gradient() 用于 创建一个线性渐变的 图像，需要设置一个起点一个方向，还可以定义角度起始颜色等。 语法： background: linear-gradient(direction, color-stop1, color-stop2, ...); direction: 指定渐变方向的角度 （可以省略） color-stop1： 指定渐变的起止颜色 示例： background: linear-gradient(red,yellow,blue,green); // 结果如下，在未设置渐变角度是自上而下的 示例： background: linear-gradient(12deg,red,yellow,blue,green); // 结果如下，设置渐变角度后 示例： background: linear-gradient(to left top,red,yellow,blue,green); // 结果如下，渐变角度可以从某个方向到另外一个方向 4. radial-gradient() 用法和linear-gradient()差不多，只不过它是用径向渐变创建图像，渐变由中心点定义，必须设置两个终止色（区别） 语法： background: radial-gradient(shape size at position, start-color, ..., last-color); shape: 确定圆的类型（选填） - ellispe(默认): 指定椭圆形的径向渐变 - circle： 指定圆形的径向渐变 size: 指定径向渐变的大小（选填） - farthest-corner(默认)： 指定径向渐变的半径长度为从圆心到离圆心最远的角 - closest-side： 指定径向渐变的半径长度为从圆心到离圆心最近的边 - closest-corner： 指定径向渐变的半径长度为从圆心到离圆心最近的角 - farthest-side：指定径向渐变的半径长度为从圆心到离圆心最远的边 position: 定义渐变的位置（选填） - center(默认)：设置中间为径向渐变圆心的纵坐标值 - top：设置顶部为径向渐变圆心的纵坐标值 - bottom：设置底部为径向渐变圆心的纵坐标值 start-color, ..., last-color：定义渐变的起止色 示例： background: radial-gradient(red, green, blue, yellow); // 结果如下，渐变从中心往外扩散 示例： background: radial-gradient( red 5%, green 10%, blue 15%,yellow 20%); // 结果如下，可以单独设置每个颜色的占比 示例： background: radial-gradient(circle, red, green, blue, yellow); // 结果如下，径向渐变设置为圆形，默认为椭圆形 5. repeating-linear-gradient() 创建重复的线性渐变图像 语法： background: repeating-linear-gradient(angle | to side-or-corner, color-stop1, color-stop2, ...); angle: 定义渐变角度（0deg-360deg，默认180deg） side-or-corner: 指定线性渐变起始位置（顺序随意） - 关键字一： 水平位置（left,right） - 关键字而： 垂直位置（top,bottom） color-stop1, color-stop2,... - 指定渐变的起止颜色，由颜色值、停止位置（可选，使用百分比指定）组成 示例： background: repeating-linear-gradient(red, yellow 10%, green 20%); // 结果如下，默认自上而下，以及设置颜色的占比 示例： background: repeating-linear-gradient(30deg, red 5%, yellow 10%, green 20%); // 结果如下，设置角度后的效果","tags":[{"name":"css","slug":"css","permalink":"https://jiaopianjun.cc/tags/css/"}]},{"title":"ES6入门之数值的扩展","date":"2019-04-08T13:35:00.000Z","path":"2019/04/08/ES6入门之数值的扩展.html","text":"# 1. 二进制和八进制表示法 ES6提供了二进制和八进制数值的新写法，分别用前缀 0b(0B) 和 0o(0O)表示 如下： 0b111110111 === 503 // true 0o767 === 503 // true 2. Number.isFinite(), Number.isNaN() ES6在number上提供了 Number.isFinite(), Number.isNaN()两个方法，前者用来检查数值是否为有限的，后者用来检查一个值是否为NAN，如下： Number.isFinite(15); // true Number.isFinite(0.8); // true Number.isFinite(NaN); // false Number.isFinite(Infinity); // false Number.isFinite(-Infinity); // false Number.isFinite(&apos;foo&apos;); // false Number.isFinite(&apos;15&apos;); // false Number.isFinite(true); // false 参数类型如果不是数字就返回false Number.isNaN(NaN) // true Number.isNaN(15) // false Number.isNaN(&apos;15&apos;) // false Number.isNaN(true) // false Number.isNaN(9/NaN) // true Number.isNaN(&apos;true&apos; / 0) // true Number.isNaN(&apos;true&apos; / &apos;true&apos;) // true 与传统的isFinite() 和 isNaN() 的区别在于，传统方法优先调用Number()将非数值的值转为数值，在进行判断。而Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。 3. Number.parseInt(), Number.parseFloat() ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。减少全局性方法，使得语言逐渐模块化。如下： // ES5的写法 parseInt(&apos;12.34&apos;) // 12 parseFloat(&apos;123.45#&apos;) // 123.45 // ES6的写法 Number.parseInt(&apos;12.34&apos;) // 12 Number.parseFloat(&apos;123.45#&apos;) // 123.45 4. Number.isInteger() Number.isInteger()用来判断一个数值是否为整数，如下： Number.isInteger(25) // true Number.isInteger(25.1) // false Number.isInteger(25.0) // true 整数和浮点数采用相同的存储方式 但是Number.isInteger() 对于数据精度要求比较高的情况不能很好的判断，不建议使用。 5. Number.EPSILON Number.EPSILON 用来表示1 与 大于1的最小浮点数之间的差，实际上就是JavaScript能够表示的最小精度。 function withinErrorMargin (left, right) { return Math.abs(left - right) &lt; Number.EPSILON * Math.pow(2, 2); } 0.1 + 0.2 === 0.3 // false withinErrorMargin(0.1 + 0.2, 0.3) // true 1.1 + 1.3 === 2.4 // false withinErrorMargin(1.1 + 1.3, 2.4) // true 6. 安全整数和 Number.isSafeInteger() JavaScript能够精准表示的整数范围在 -2^53到2^53之间（不含两个端点），ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。而Number.isSafeInteger() 就是判断一个整数是否在这个范围之内。 7. Math 对象的扩展 ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。 Math.trunc() 用于去除一个数的小树部分，返回整数部分。对于非数值，则用Number方法将其转换为数值，对于空值和无法截取整数的值，返回 NaN。如下： Math.trunc(4.1) // 4 Math.trunc(4.9) // 4 Math.trunc(-4.1) // -4 Math.trunc(-4.9) // -4 Math.trunc(-0.1234) // -0 // 非数值 Math.trunc(&apos;123.456&apos;) // 123 Math.trunc(true) //1 Math.trunc(false) // 0 Math.trunc(null) // 0 // 空值和无法截取的值 Math.trunc(NaN); // NaN Math.trunc(&apos;foo&apos;); // NaN Math.trunc(); // NaN Math.trunc(undefined) // NaN Math.sign() 用来判断一个数是否为正数、负数、还是零，对于非数值，则将其转换为数值。 // 返回五种结果： - 参数为正数，返回+1； - 参数为负数，返回-1； - 参数为 0，返回0； - 参数为-0，返回-0; - 其他值，返回NaN。 Math.sign(-5) // -1 Math.sign(5) // +1 Math.sign(0) // +0 Math.sign(-0) // -0 Math.sign(NaN) // NaN Math.sign(&apos;&apos;) // 0 Math.sign(true) // +1 Math.sign(false) // 0 Math.sign(null) // 0 Math.sign(&apos;9&apos;) // +1 Math.sign(&apos;foo&apos;) // NaN Math.sign() // NaN Math.sign(undefined) // NaN Math.cbrt() 用来计算一个数的立方根，与其他相同如果不是数值就先转换为数值。 Math.cbrt(-1) // -1 Math.cbrt(0) // 0 Math.cbrt(1) // 1 Math.cbrt(2) // 1.2599210498948734 Math.clz32() 用来将参数转为32位无符号整数的形式，然后这个32位值里面有多个前导0 Math.imul() 用来返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号的整数。 Math.fround() 返回一个32位单精度浮点数形式 Math.hypot() 返回所有参数的平方和的平方根 8. 对数方法8.1 Math.expm1() Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1。 8.2 Math.log1p() Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。 8.3 Math.log10() Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。 8.4 Math.log2() Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。 9. 双曲函数方法 ES6 新增了 6 个双曲函数方法。 Math.sinh(x) 返回x的双曲正弦（hyperbolic sine） Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine） Math.tanh(x) 返回x的双曲正切（hyperbolic tangent） Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine） Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine） Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent） 10. 指数运算 ES6 新增了指数运算符（**），而且是从右往左计算。 2 ** 3 // 16 2 ** 2 ** 3 === 2 ** (2 ** 3) // 256 let a = 1.5 a** = 2 === a = a*a let b =4 b** = 3 === b = b* b* b 和 Math.pow 在运算结果的最后一位数字有差异，特别大的运算结果有细微的差异","tags":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jiaopianjun.cc/tags/ECMAScript6/"}]},{"title":"Python基础教程之字符串和编码","date":"2019-04-05T13:36:00.000Z","path":"2019/04/05/Python基础教程之字符串和编码.html","text":"1. 字符编码 由于计算机只能处理数字，如果要处理文本就必须将文本转换为数字才能处理，最早设计的时候采用8b 表示一个字节，一个字节能够表示的最大整数是255,如果要表示更大的整数，就必须用多个字节。另外由于计算机是美国人发明的，所以计算机早期只有127个字符被编码到计算机了，也就是Ascii码，后来要处理中文中国就指定了GB2312 ，但是其他国家也有自己的语言 然后就有了不同的标准， 所以就有组织将所有的统一成 Unicode编码。 2. python字符串 在python 中字符串支持多语言,python 提供了 ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符，如下： &gt;&gt;&gt; ord(&apos;A&apos;) 65 &gt;&gt;&gt; ord(&apos;中&apos;) 20013 &gt;&gt;&gt; chr(66) &apos;B&apos; &gt;&gt;&gt; chr(25991) &apos;文&apos; 由于python字符串类型是str，在内存中以 unicode表示，一个字符对应若干字节，如果需要在网上传输，或者保存磁盘，就需要把str变为以字节为单位的bytes python 对 bytes 类型的数据用 带b前缀的单引号和双引号表示,如下： x = b &apos;ABC&apos; &apos;ABC&apos; 和 b&apos;ABC&apos; // 前者是 str 后者是表示字节 在python 中 unicode 表示的str 通过 encode() 方法可以编码为指定的bytes，例如： &gt;&gt;&gt; &apos;ABC&apos;.encode(&apos;ascii&apos;) b&apos;ABC&apos; &gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf-8&apos;) b&apos;\\xe4\\xb8\\xad\\xe6\\x96\\x87&apos; &gt;&gt;&gt; &apos;中文&apos;.encode(&apos;ascii&apos;) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128) // 纯英文的str 可以用 ASCII编码为 bytes，含有中文的可以用UTF-8编码为bytes,在bytes中无法显示的ASCII字符的字节，用\\x##显示 反之，我们需要读取字节流，可以通过decode()方法，将bytes 转换为str，如果bytes中包含无法解码的字节，decode()会报错。 &gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;) &apos;ABC&apos; &gt;&gt;&gt; b&apos;\\xe4\\xb8\\xad\\xe6\\x96\\x87&apos;.decode(&apos;utf-8&apos;) &apos;中文&apos; &gt;&gt;&gt; b&apos;\\xe4\\xb8\\xad\\xff&apos;.decode(&apos;utf-8&apos;) Traceback (most recent call last): ... UnicodeDecodeError: &apos;utf-8&apos; codec can&apos;t decode byte 0xff in position 3: invalid start byte len() 函数是用来计算str 的字符数，如果换成bytes， 就计算字节数 在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。3. 格式化 在python 中采用和 c语言一样的格式化方式，用%来实现，如下： &gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos; &apos;Hello, world&apos; &gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000) &apos;Hi, Michael, you have $1000000.&apos; 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 4. format() 通过format方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}等。写法比%麻烦。如下： &gt;&gt;&gt; &apos;Hello, {0}, 成绩提升了 {1:.1f}%&apos;.format(&apos;小明&apos;, 17.125) &apos;Hello, 小明, 成绩提升了 17.1%&apos;","tags":[{"name":"Python","slug":"Python","permalink":"https://jiaopianjun.cc/tags/Python/"}]},{"title":"ES6入门之正则的扩展","date":"2019-03-30T13:35:00.000Z","path":"2019/03/30/ES6入门之正则的扩展.html","text":"# 1. 正则的扩展 参数为字符串， 那么第二个参数表示正则表达式的修饰符，如下： var regex = new RegExp(&apos;xyz&apos;, &apos;i&apos;) // 等价于 var regex = /xyz/i 参数为一个正则表达式，这时返回一个原有正则表达式的拷贝。如下： var regex = new RegExp(/xyz/i) // 等价于 var regex = /xyz/i Es6中改变了这种行文。如果RegExp构造函数第一个参数是正则对象，那第二个参数可以指定修饰符，并且返回的正则表达式会忽略原有正则表达式的修饰符，只使用新指定的修饰符。 如下： new RegExp(/abc/ig, &apos;i&apos;).flags // 原有的ig 被 i 覆盖 2. 字符串的正则方法 字符串对象共有4个方法，可以使用正则表达式： match()、 replace()、search() 和 split()。在Es6中 全部调用RegExp的实例方法，全部定义在RegExp对象上。如下： String.prototype.match 调用 RegExp.prototype[Symbol.match] String.prototype.replace 调用 RegExp.prototype[Symbol.replace] String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split 3. u 修饰符 ES6 对正则表达式添加了 u 修饰符，用来正确处理大于\\uFFFF的Unicode字符。如下： /^\\uD83D/u.test(&apos;\\uD83D\\uDC2A&apos;) // false /^\\uD83D/.test(&apos;\\uD83D\\uDC2A&apos;) // true // 如上代码因为在ES5中 不支持四个字节的 UTF-16编码，会将为识别为两个字符 导致 第二行为true 但是加了 u 修饰符后，ES6将为识别为一个字符，所以第一行为flase 4. RegExp.prototype.unicode 属性 正则实例对象新增 unicode 属性，用来判断表示是否设置了u修饰符，如下： const r1 = /hello/; const r2 = /hello/u; r1.unicode // false r2.unicode // true 5. y 修饰符 和 g 修饰符相似，全局匹配，但是下次匹配都是从上次匹配成功的下一个位置开始。而g 只要剩余位置中存在匹配即可，y 必须从剩余的第一个位置开始。如下： var s = &apos;aaa_aa_a&apos;; var r1 = /a+/g; var r2 = /a+/y; r1.exec(s) // [&quot;aaa&quot;] r2.exec(s) // [&quot;aaa&quot;] r1.exec(s) // [&quot;aa&quot;] r2.exec(s) // null // 第一次执行后 为 _aa_a g 只要剩余位置存在即可匹配，返回 aa // y 则是从上一次结果后的第一个位置开始，因为是_ 所以返回null 6. RegExp.prototype.sticky 属性 与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符 如下： var r = /hello\\d/y; r.sticky // true 7. RegExp.prototype.flags 属性 ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。 // ES5 的 source 属性 // 返回正则表达式的正文 /abc/ig.source // &quot;abc&quot; // ES6 的 flags 属性 // 返回正则表达式的修饰符 /abc/ig.flags // &apos;gi&apos; 8. s 修饰符：dotAll 模式 匹配的是任意单个字符,用来匹配任意单个字符，如下： /foo.bar/s.test(&apos;foo\\nbar&apos;) // true 9. Unicode 属性类 ES2018 引入了一种新的类的写法\\p{…}和\\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。 const regexGreekSymbol = /\\p{Script=Greek}/u; regexGreekSymbol.test(&apos;π&apos;) // true 10. 具名组匹配 正常多个匹配 可能用圆括号包起，如下： const RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/; const matchObj = RE_DATE.exec(&apos;1999-12-31&apos;); const year = matchObj[1]; // 1999 const month = matchObj[2]; // 12 const day = matchObj[3]; // 31 但是以上的写法不容易看懂，理解较为困难，而且只能用数字序号，另外如果数组顺序变了，还需要修改引用的序号。所以就有了具名组匹配。允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。即使组的顺序变了，叶不用去更改匹配后的处理代码。如下： const RE_DATE = /(?&lt;year&gt;\\d{4})-(?&lt;month&gt;\\d{2})-(?&lt;day&gt;\\d{2})/; const matchObj = RE_DATE.exec(&apos;1999-12-31&apos;); const year = matchObj.groups.year; // 1999 const month = matchObj.groups.month; // 12 const day = matchObj.groups.day; // 31 // 格式： “具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?&lt;year&gt;） 11. String.prototype.matchAll 如果一个正则表达式在一个字符串中有多个匹配，现在使用的是 g 修饰符 或者 y 修饰符 循环 取出。现在有了新的提案。就是用 String.prototype.matchAll 一次性取出，但是它返回的不是一个数组，而是一个遍历器。然后可以用 for … of 取出。","tags":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jiaopianjun.cc/tags/ECMAScript6/"}]},{"title":"ES6入门之字符串的扩展","date":"2019-03-24T13:35:00.000Z","path":"2019/03/24/ES6入门之字符串的扩展.html","text":"1. 字符的 Unicode 表示法 Javascript 中允许采用 \\uxxxx的形式表示一个字符，其中xxxx表示字符的Unicode码点。如下 &quot;\\u0061&quot; 这种 表示有区间 只能在 0000 ~ FFFF之间，如果超出则需要用双字节的的形式表示 &quot;\\u20BB7\\uDFB1&quot; 在ES6中，对字符串的写法做出了改变。改为将码点放入大括号中，就能正确读取该字符，如下： &quot;\\u{20BB7}&quot; // 吉 2. codePointAt() Javascript内部，字符以 UTF-16的格式存储，每个字符固定为2个字节。对于需要4个字节储存的字符，JavaScript会认为它们是两个字符。如下： var s = &quot;吉&quot; s.length // 2 s.charAt(0) // &apos;&apos; s.charAt(1) // &apos;&apos; s.charCodeAt(0) // 55362 s.charCodeAt(1) // 57271 上面代码中汉字吉 需要4个字节存储，但是JavaScript不能正确处理，字符串长度误判为2，而且charAt 方法无法读取字符，charCodeAt 只能返回前面两个字节和后面两个字节的值，ES6 提供了 codePointAt 方法能够正确处理4个字节存储的字符，返回一个字符的码点，如下： let s = ‘吉a’； s.codePointAt(0) // 134071 s.codePointAt(1) // 57271 codePointAt() 方法是测试一个字符由两个字节还是四个字节组成的最简单的方法 3. String.fromCodePoint() ES5 提供了 String.fromCharCode 方法 用于从码点返回对应字符，但是不能识别32位的UTR-16字符，ES6提供了 Sring.fromCodePoint() 方法 可以识别大于32位的。如果有多个参数则将合并。如下： String.fromCodePoint(0x20BB7) // &quot;𠮷&quot; String.fromCodePoint(0x78, 0x1f680, 0x79) === &apos;x\\uD83D\\uDE80y&apos; // true 注意：fromCodePoint 方法定义在 String 对象上，而codePointAt 方法定义在字符串实例对象上 4. 字符串的遍历器接口 ES6为字符串添加了遍历器接口，字符串可以被for of 遍历 5. normalize() 用来将字符的不同表示方法统一为同样的形式， 6. includes(), startsWith(), endsWith() 传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 7. repeat() 用来返回一个新字符串，表示将原字符串重复N次 &apos;x&apos;.repeat(2) // &apos;xx&apos; &apos;cx&apos;.repeat(3) // &apos;cxcxcx&apos; 参数NaN等同于 0。 &apos;na&apos;.repeat(NaN) // &quot;&quot; 如果repeat的参数是字符串，则会先转换成数字。 &apos;na&apos;.repeat(&apos;na&apos;) // &quot;&quot; &apos;na&apos;.repeat(&apos;3&apos;) // &quot;nanana&quot; 8. padStart()，padEnd() 用于字符串的补全，接受两个参数，第一个字符串补全生效的最大长度，第二个是用来补全的字符串，如下： &apos;x&apos;.padStart(5, &apos;ab&apos;) // &apos;ababx&apos; &apos;x&apos;.padStart(4, &apos;ab&apos;) // &apos;abax&apos; &apos;x&apos;.padEnd(5, &apos;ab&apos;) // &apos;xabab&apos; &apos;x&apos;.padEnd(4, &apos;ab&apos;) // &apos;xaba&apos; 注意： 如果原字符串的长度等于或大于最大长度，则补全不生效，返回原字符串 如果补全字符串和原字符串，两者长度超过最大长度，则截取超出位数的补全字符串 9. matchAll() matchAll方法返回一个正则表达式在当前字符串的所有匹配 10. 模板字符串 用来简化之前模板的写法，写法如下： $(&apos;#result&apos;).append( &apos;There are &lt;b&gt;&apos; + basket.count + &apos;&lt;/b&gt; &apos; + &apos;items in your basket, &apos; + &apos;&lt;em&gt;&apos; + basket.onSale + &apos;&lt;/em&gt; are on sale!&apos; ); 上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。 $(&apos;#result&apos;).append(` There are &lt;b&gt;${basket.count}&lt;/b&gt; items in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt; are on sale! `); 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。 let x = 1; let y = 2; `${x} + ${y} = ${x + y}` // &quot;1 + 2 = 3&quot; `${x} + ${y * 2} = ${x + y * 2}` // &quot;1 + 4 = 5&quot; let obj = {x: 1, y: 2}; `${obj.x + obj.y}` // &quot;3&quot; 11. 模板编译 使用&lt;%…%&gt;放置 JavaScript 代码，使用&lt;%= … %&gt;输出 JavaScript 表达式，如下： let template = ` &lt;ul&gt; &lt;% for(let i=0; i &lt; data.supplies.length; i++) { %&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% } %&gt; &lt;/ul&gt; `; 12. 标签模板 模板字符串可以跟在一个函数名后面，该函数将被调用来处理这个模板字符串，这被称为 标签模板。 如下： alert(123) alert`123` 标签模板其实不是模板，而是函数的一种特殊形式。“标签”就是函数，跟在后面的模板字符串就变成了它的参数。但是如果模板字符串里面有变量，就会将模板字符串先处理成多个参数，再调用函数。如下： let a = 5; let b = 10; tag`Hello ${ a + b } world ${ a * b }`; // 等同于 tag([&apos;Hello &apos;, &apos; world &apos;, &apos;&apos;], 15, 50); String.raw() ES6 为原生 String 对象，提供了一个raw方法。用来充当模板字符串的处理函数，返回一个斜杠都被转义的字符串，对应于替换变量后的模板字符串。如下： String.rawHi\\n${2+3}!;// 返回 “Hi\\n5!” String.rawHi\\u000A!;// 返回 “Hi\\u000A!” 模板字符串的限制 模板字符串默认会将字符串转义，导致无法嵌入其他语言。为了解决这个问题，ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从raw属性上面可以得到原始字符串。","tags":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jiaopianjun.cc/tags/ECMAScript6/"}]},{"title":"Python基础教程之数据类型和变量","date":"2019-03-20T13:36:00.000Z","path":"2019/03/20/Python基础教程之数据类型和变量.html","text":"1. 数据类型 计算机能够处理的各种数值以及文本、图形、音频等。 1.1 整数 python 可以处理任意大小的整数、负整数，写法和数学上一致，但是有的时候可能用十六进制来展示 1 ， 100，-8080 // 十进制 0xff00, 0xa5b4 // 十六进制用0x前缀和0-9，a-f表示 1.2 浮点数 浮点数也就是小数，之所以成为浮点数，是因为浮点数的小数点是可变的。浮点数可以用数学写法如：1.23， 如果很大或者很小的浮点数，就需要用科学计数法表示，把10 用 e 来代替。整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的，而浮点数可能会四舍五入。 1.3 字符串 字符串是以单引号 或者 双引号 包裹起来的文本。 1.4 布尔值 布尔值和布尔代数的表示完全一致，只有 true flase 两种值，在python 中可以直接用 True False 表示布尔值（注意大小写），也可以通过布尔运算计算出来，布尔值可以通过 and 、 or 、not 运算 1.5 空值 python 中一个特殊的值，用 None表示，但是不能理解为0，None是一个特殊的空值。 2. 变量 变量的概念和初中代数的方程变量一致，在这里变量不仅可以是数字，还可以是任意数据类型，变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_下划线的组合，不能数字开头。 a = &apos;ABC&apos; python 解释器做了两件事 1. 在内存中创建了一个&apos;ABC&apos;的字符串 2. 在内存中创建了一个名为a 的变量，并把它指向&apos;ABC&apos; 3. 常量 常量就是不能变的变量，在Python中，全部大写的变量名表示常量，但是在python中 常量还是能被改变，这点不同于js语言。大写只是一种自我约定的写法。 4. 总结 python 支持多种数据类型，可以把任何数据都看成一个对象，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量联系起来。python中整数没有大小限制，浮点数也没有大小限制，但是超出一定范围就直接表示inf（无限大）","tags":[{"name":"Python","slug":"Python","permalink":"https://jiaopianjun.cc/tags/Python/"}]},{"title":"ES6入门之变量的解构赋值","date":"2019-03-19T13:34:00.000Z","path":"2019/03/19/ES6入门之变量的解构赋值.html","text":"1.数组的解构赋值 基本用法 ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为结构。 在ES6之前想要为变量赋值，只能指定其值，如下： let a = 1; let b = 2 而在ES6中可以写成这样，如下： let [a,b] = [1,2] // a = 1, b = 2 值得注意的是，等式两边的值要对等，这样左边的变量才会被赋上右边对应的值，如果不对等左边的值将会出现undefined，如下写法： let [foo,[[bar],baz]] = [1,[[2],3]] foo // 1 bar // 2 baz // 3 注意：只有左右两边的 格式一定要对等，数量可以不对等。 let [a,b,c] = [1,2] a = 1, b = 2, c = undefined let [a,,c] = [1,2,3] a = 1, c = 3 let [a, ...b] = [1,2,3] a = 1, b = [2,3] let [a] = [] let [b,a] = [1] a = undefined 还有一种情况，等号左边为数组，但是等号右边为其他值，将会报错。如下： let [a] = 1; let [a] = false; let [a] = NaN; let [a] = undefined; let [a] = null; let [a] = {}; 以上都会报错 但是如果左边为数组，右边为字符串，将会取字符串的第一个下标的值 let [a] = &apos;121321&apos; a = &apos;1&apos; let [a] = &apos;adgasg&apos; a = &apos;a&apos; 对于Set结构，同样可以使用数组的解构赋值。 let [x,y,z] = new Set([1,2,3]) x = 1, y = 2, z = 3 默认值 解构赋值允许指定默认值 let [a = 3] = [] // a:3 let [a = 3,b] = [,4] // a:3 b:4 let [a = 3,b] = [5,4] // a:5 b:4 特殊 let [a = 3] = [undefined] // a:3 let [a = 3] = [null] // a:null ++++==Tips==++: 在es6中使用严格相等运算符，在结构赋值中如果需要默认值生效，则应对等的值为undefined的时候才会采用默认值，否则还是使用赋值。上面中null 不严格等于undefined++ 如果默认值的赋值为一个表达式，只有当等号右边的赋值没有值为undefined的时候，才会取表达式中的值，如下： function demo(){ console.log(&apos;demo&apos;) } let [a = demo()] = [] // a: demo let [a = demo()] = [1] // a : 1 对象的解构赋值 与数组的不同点是，数组的元素必须和赋值的元素要位置一致才能正确的赋值，而对象的解构赋值则是等号两边的变量和属性同名即可取到正确的值。否则值为 undefined let {a,b} = {a:&apos;23&apos;,b:&apos;3&apos;} let {a,b} = {b:&apos;3&apos;,a:&apos;23&apos;} // 上面两个的值 都是 a: 23 b: 3 let {a,b} = {a:&apos;3&apos;,c:&apos;d&apos;} //a: 3 b: undefined 对象的解构赋值还有将某一个现有对象的方法赋值到一个新的变量，如下： let {sin,cos} = Math // Math 中的sin cos 方法将赋值给变量 sin cos let {log} = console // log(2) === console.log(2) 如果等号左边的变量名不能和等号右边的对象的属性名一致，则必须写成如下格式： let {a:b} = {a:&apos;ss&apos;} // b：ss //a是属性名，b才是实际赋值的变量名 对象的解构赋值一样是可以嵌套解构的，如下： 第一种： let obj = { p:[ &apos;Hello&apos;, {y:&apos;world&apos;} ] } let {p:[x,{y}]} = obj // x: Hello, y: world 这边的p只是属性不是变量，如果p想赋值可以写成： let {p,:[x,{y}]} = obj 第二种： const a = { loc: { t :1, b :{ c:1, d:2 } } } let {loc:{t,b:{c,d}}} = a 或者 let {loc,loc:{t,b,b:{c,d}}} = a 嵌套赋值let o = {}, arr = [] ({foo:o.prop,bar: arr[0]} = {foo:123,bar:true}) //o: 123, arr = [true] 如果解构模式 是嵌套的对象，如果子对象所在的父属性不存在，则会报错，如下： let {foo:{bar}} = {baz:&apos;baz&apos;} //报错 默认值let {x = 3} = {} // x: 3 let {x,y = 5} = {x : 1} // x: 1, y: 5 let {x: y = 5} = {} // y = 5 let {x: y = 5} = {x : 4} // y = 4 let {x: y = &apos;hhhh&apos;} = {} //y = &apos;hhhh&apos; Tips:以上左边 x为属性名，y为变量 let {x = 5} = {x: undefined} // x: 5 let {x = 4} = {x: null} // x: null 同数组一样遵循 严格等于 只有右边为undefined的时候默认值才会生效 注意点：1）不能将已声明的变量用于解构赋值，因为已经是一个代码块。 字符串的解构赋值 如果赋值的对象是数组，字符串将被分割为数组的格式，一一对应赋值 let [a,b] = &apos;ha&apos; // a = h , b = a 同时可以获得字符串的长度： let {length:len} = &apos;12121&apos; // len = 5 数值和布尔值的解构赋值 如果等号右边是数字或者布尔值 则转换成对象或者说，除了是数组和对象，其他值都将转换成对象，null 和 undefined 除外。如下： let {t:s} = 123 let {t: s} = true 函数参数的解构赋值function add([x,y]){ return x+y } add([3,5]) // 8 [[3,5],[6,7]].map(([a,b]) =&gt; a + b) //8 , 13 function m({x=3, y=4} = {}){ return [x,y] } m({x:33,y:8}) // [33,8] m({x:32}) // [32,4] m({}) // [3,4] m() // [3,4] function m({x,y} = {x=0,y=0}){ return [x,y] } m({x:33,y:8}) // [33,8] // 代替右边的 x:0, y:0 所以是传值 33 8 m({x:32}) // [32,undefined] //因为传值替代右边的赋值，但是只有x没有y //所以y是取 左边y的默认值，因为你没有赋值 为undefined m({}) // [undefined,undefined] // 取左边x,y的默认值，因为没有赋值 为undefined m() // [0,0] // 没有传值，使用本身的赋值 都是0 其他不能使用圆括号的情况 变量声明语句 函数参数 赋值语句的模式 可以使用圆括号的情况 赋值语句的非模式部分，可以使用圆括号 解构赋值的用途 交换变量的值 从函数返回多个值 函数参数的定义 提取JOSN数据 函数参数的默认值 遍历Map解构 输入模块的指定方法","tags":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jiaopianjun.cc/tags/ECMAScript6/"}]},{"title":"ES6入门之let、cont","date":"2019-03-11T08:22:00.000Z","path":"2019/03/11/ES6入门之let、cont.html","text":"一、前提1解决ES5中只有全局作用域和函数作用域，没有块级作用域而带来的不合理的场景。 let 基本用法用法和var 一样，只是let声明的变量只有在let命令所在的代码块有效 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 可以看出var 声明的变量在代码块之外也是可以调用，而let声明的则调用报错。所以let 声明只在它声明的当前代码块中才能调用。 变量提升在使用 var 的时候会出现 “变量提升”的现象，即变量可以在声明之前使用，值为undefined。let 改变了这种现状，但是必须先声明在使用，如果在声明之前使用则会出现报错。如下： 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 暂时性死区只要块级作用域内部存在 let 或者 const 命令，它所声明的变量就“绑定”在这个区域，不会受外部影响。且暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。如下： 123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; ES6 明确规定，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。如下： 1234567891011if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 注意：++使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。++ 不允许重复声明let 不允许在同一个作用域内声明同一个变量，如下： 1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 或者如下： 1234567891011function func(arg) &#123; let arg;&#125;func() // 报错function func(arg) &#123; &#123; let arg; &#125;&#125;func() // 不报错 块级作用域上面也提到过在es5中没有块级作用域的概念，只有函数作用域和全局作用域，那么就带来了一些问题，如下： 12345678910111213var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = 'hello world'; &#125;&#125;f(); // undefined外层声明被内层声明所覆盖，内层使用的是外层的声明，内层变量提升导致 undefinded 第二种：计数循环全局泄露，如下：123456789var s = 'hello';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5常见的面试题，最后输出不是预料中的 1 2 3 4 5 而全部是 5 ES6的块级作用域，实际上就是let 新增的，如下：123456789function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125;内外层的 n 互不干扰 ES6中 允许作用域任意嵌套，并且互不干扰，如下：12345678910111213内外层可以同名&#123;&#123;&#123;&#123; let insane = 'Hello World'; &#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;;或者&#123;&#123;&#123;&#123; &#123;let insane = 'Hello World'&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;; 块级作用域的出现可以让以下立即执行函数的写法不必要，如下： 1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 块级作用域和函数声明在ES5中，函数只能在顶层作用域和函数作用域中声明，不能在块级作用域中声明，但是浏览器为了兼容性，还是可以在块级作用域中声明，理论上在ES6中 块级作用域中声明的函数，在外部调用会报错，考虑环境的问题，应当避免在块级作用域中声明函数，如果需要也应当写成函数表达式的方式，而不是函数声明语句，如下： 123456789101112131415// 函数声明语句&#123; let a = 'secret'; function f() &#123; return a; &#125;&#125;// 函数表达式&#123; let a = 'secret'; let f = function () &#123; return a; &#125;;&#125; CONSTconst声明的是一个常量 如下： 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 声明之后如果在赋值，将会报错，同时因为声明的是常量，即const声明后即要赋值不然也会报错 const 和 let 相同，声明也只在当前的块级作用域生效。同样也不会声明提升，也存在暂时死区，只能在声明之后使用，且和 let 一样不得重复声明，不能重新赋值。 重要：const 所不能改变的并不是值，而是变量指向的那个内存地址所保存的值不能变动，对于简单类型（数值、字符串、布尔值），值就保存在变量所指向的内存地址中，因此等同于常量。而对于复合类型（数组、对象），变量指向的内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的（即总指向一个固定的地址）。至于它指向的数据结构则是不能控制的 ，如下： 1234567891011const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: \"foo\" is read-only常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 或者 123456const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错 如果真的想将声明对象冻结，不能在改变 则应该使用object.freeze()12345678910111213141516const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123;对象也可以冻结var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; ES6 声明变量的六种方法1234561. function2. var3. let4. const5. import 6. class 顶层对象的属性在浏览器环境指的是window对象，在 Node 指的是global对象,ES5 之中，顶层对象的属性与全局变量是等价的。 12345window.a = 1;a // 1a = 2;window.a // 2 global 对象ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。 Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。","tags":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jiaopianjun.cc/tags/ECMAScript6/"}]},{"title":"CSS之BFC","date":"2019-03-07T09:42:00.000Z","path":"2019/03/07/CSS之BFC.html","text":"1. 什么是BFC？ BFC(块格式上下文), 在css中渲染页面是按照块级盒子布局，W3C对于BFC的定义如下： 浮动元素和绝对定位元素，非块级盒子的块级容器， 以及overflow值不为 visiable 的块级盒子，都会为他们的内容创建新的BFC 2. BFC的作用1. 不和浮动元素重叠 2. 清除元素内部浮动 3. 防止margin重叠 3. BFC的形成条件1. float的值不能为none 2. overflow的值不能为visible 3. display的值为table-cell, table-caption, inline-block中的任何一个 4. position的值不为relative和static","tags":[{"name":"css","slug":"css","permalink":"https://jiaopianjun.cc/tags/css/"}]},{"title":"F2E资源分享","date":"2019-03-07T03:18:00.000Z","path":"2019/03/07/f2e.html","text":"目录 语言无关 IDE MySQL NoSQL PostgreSQL Web WEB服务器 其它 函数式概念 分布式系统 在线教育 大数据 操作系统 数据库 智能系统 正则表达式 版本控制 程序员杂谈 管理和监控 编程艺术 编译原理 编辑器 计算机图形学 设计模式 软件开发方法 项目相关 语言相关 Android AWK C C# C++ CoffeeScript Dart Elasticsearch Elixir Erlang Fortran Golang Haskell HTML / CSS HTTP iOS Java JavaScript LaTeX LISP Lua Markdown Node.js Perl PHP Python Django R reStructuredText Ruby Rust Scala Scheme Scratch Shell Swift Vim Visual Prolog 语言无关IDE IntelliJ IDEA 简体中文专题教程 MySQL 21分钟MySQL入门教程 MySQL索引背后的数据结构及算法原理 NoSQL Disque 使用教程 Redis 命令参考 Redis 设计与实现 The Little MongoDB Book The Little Redis Book 带有详细注释的 Redis 2.6 代码 带有详细注释的 Redis 3.0 代码 PostgreSQL PostgreSQL 8.2.3 中文文档 PostgreSQL 9.3.1 中文文档 PostgreSQL 9.4.4 中文文档 PostgreSQL 9.5.3 中文文档 PostgreSQL 9.6.0 中文文档 Web 3 Web Designs in 3 Weeks Chrome 开发者工具中文手册 Chrome扩展开发文档 Growth: 全栈增长工程师指南 Grunt中文文档 Gulp 入门指南 gulp中文文档 HTTP 接口设计指北 HTTP/2.0 中文翻译 http2讲解 JSON风格指南 Wireshark用户手册 一站式学习Wireshark 关于浏览器和网络的 20 项须知 前端代码规范 及 最佳实践 前端开发体系建设日记 前端资源分享（一） 前端资源分享（二） 正则表达式30分钟入门教程 浏览器开发工具的秘密 移动Web前端知识库 移动前端开发收藏夹 WEB服务器 Apache 中文手册 Nginx开发从入门到精通 (淘宝团队出品) Nginx教程从入门到精通 (PDF版本，运维生存时间出品) 其它 OpenWrt智能、自动、透明翻墙路由器教程 SAN 管理入门系列 Sketch 中文手册 深入理解并行编程 函数式概念 傻瓜函数编程 分布式系统 走向分布式 (PDF) 在线教育 51CTO学院 Codecademy CodeSchool Coursera Learn X in Y minutes (数十种语言快速入门教程) shiyanlou TeamTreeHouse Udacity xuetangX 慕课网 (丰富的移动端开发、php开发、web前端、html5教程以及css3视频教程等课程资源) 极客学院 汇智网 计蒜客 大数据 Spark 编程指南简体中文版 大型集群上的快速和通用数据处理架构 数据挖掘中经典的算法实现和详细的注释 面向程序员的数据挖掘指南 操作系统 Debian 参考手册 Docker —— 从入门到实践 Docker中文指南 Docker入门实战 FreeBSD 使用手册 Linux Documentation (中文版) Linux Guide for Complete Beginners Linux 构建指南 Linux 系统高级编程 Linux工具快速教程 Mac 开发配置手册 Operating Systems: Three Easy Pieces The Linux Command Line (中英文版) Ubuntu 参考手册 uCore Lab: Operating System Course in Tsinghua University UNIX TOOLBOX 命令行的艺术 嵌入式 Linux 知识库 (eLinux.org 中文版) 开源世界旅行手册 理解Linux进程 鸟哥的 Linux 私房菜 基础学习篇 鸟哥的 Linux 私房菜 服务器架设篇 数据库 Redis 设计与实现 The Little MongoDB Book 中文版 智能系统 一步步搭建物联网系统 正则表达式 正则表达式-菜鸟教程 正则表达式30分钟入门教程 版本控制 Git - 简易指南 Git-Cheat-Sheet （感谢 @flyhigher139 翻译了中文版） Git Community Book 中文版 git-flow 备忘清单 Git magic Git Magic Git 参考手册 Github帮助文档 GitHub秘籍 Git教程 （本文由 @廖雪峰 创作，如果觉得本教程对您有帮助，可以去 iTunes 购买） Got GitHub GotGitHub HgInit (中文版) Mercurial 使用教程 Pro Git Pro Git 中文版 (整理在gitbook上) svn 手册 学习 Git 分支 (点击右下角按钮可切换至简体及正体中文) 沉浸式学 Git 猴子都能懂的GIT入门 程序员杂谈 程序员的自我修养 管理和监控 ElasticSearch 权威指南 Elasticsearch 权威指南（中文版） ELKstack 中文指南 Logstash 最佳实践 Mastering Elasticsearch(中文版) Puppet 2.7 Cookbook 中文版 编程艺术 取悦的工序：如何理解游戏 (豆瓣阅读，免费书籍) 每个程序员都应该了解的内存知识(译)【第一部分】 程序员编程艺术 编程入门指南 编译原理 《计算机程序的结构和解释》公开课 翻译项目 编辑器 exvim–vim 改良成IDE项目 Vim中文文档 所需即所获：像 IDE 一样使用 vim 笨方法学Vimscript 中译本 计算机图形学 LearnOpenGL CN OpenGL 教程 设计模式 史上最全设计模式导学目录 图说设计模式 软件开发方法 傻瓜函数编程 (《Functional Programming For The Rest of Us》中文版) 硝烟中的 Scrum 和 XP 项目相关 GNU make 指南 Gradle 2 用户指南 Gradle 中文使用文档 Joel谈软件) selenium 中文文档 开源软件架构 持续集成（第二版） (译言网) 約耳談軟體(Joel on Software) 编码规范 让开发自动化系列专栏 追求代码质量 语言相关Android Android Design(中文版) Android Note(开发过程中积累的知识点) Android6.0新特性详解 Android学习之路 Android开发技术前线(android-tech-frontier) Google Android官方培训课程中文版 Google Material Design 正體中文版 (译本一 译本二) Material Design 中文版 Point-of-Android Android 一些重要知识点解析整理 AWK awk中文指南 awk程序设计语言 C C 语言常见问题集 C/C++ 学习教程 Linux C 编程一站式学习 新概念 C 语言教程 C Sharp 精通C#(第6版) C++ 100个gcc小技巧 100个gdb小技巧 C 语言编程透视 C/C++ Primer - @andycai C++ FAQ LITE(中文版) C++ Primer 5th Answers C++ Template 进阶指南 C++ 基础教程 C++ 并发编程(基于C++11) C++ 并发编程指南 CGDB中文手册 Cmake 实践 (PDF) GNU make 指南 Google C++ 风格指南 QT 教程 ZMQ 指南 像计算机科学家一样思考（C++版) (《How To Think Like a Computer Scientist: C++ Version》中文版) 简单易懂的C魔法 跟我一起写Makefile(PDF) (PDF) CoffeeScript CoffeeScript 中文 CoffeeScript 编程风格指南 Dart Dart 语言导览 Elasticsearch Elasticsearch 权威指南 （《Elasticsearch the definitive guide》中文版） ELKstack 中文指南 Mastering Elasticsearch(中文版) Elixir Elixir Getting Started 中文翻译 Elixir 编程语言教程 (Elixir School) Elixir元编程与DSL 中文翻译 Phoenix 框架中文文档 Erlang Erlang 并发编程 (《Concurrent Programming in Erlang (Part I)》中文版) Fortran Fortran77和90/95编程入门 Golang Go Web 编程 Go 入门指南 (《The Way to Go》中文版) Go 官方文档翻译 Go 指南 (《A Tour of Go》中文版) Go 简易教程 (《 The Little Go Book 》中文版) Go 编程基础 Go 语言实战笔记 Go 语言标准库 Go命令教程 Go实战开发 Go语言博客实践 Java程序员的Golang入门指南 Network programming with Go 中文翻译版本 Revel 框架手册 学习Go语言 神奇的 Go 语言 Groovy 实战 Groovy 系列 Haskell Haskell 趣学指南 Real World Haskell 中文版 HTML / CSS CSS3 Tutorial 《CSS3 教程》 CSS参考手册 Emmet 文档 HTML5 教程 HTML和CSS编码规范 Sass Guidelines 中文 前端代码规范 (腾讯 AlloyTeam 团队) 学习CSS布局 通用 CSS 笔记、建议与指导 iOS Apple Watch开发初探 Google Objective-C Style Guide 中文版 iOS7人机界面指南 iOS开发60分钟入门 iPhone 6 屏幕揭秘 网易斯坦福大学公开课：iOS 7应用开发字幕文件 Java Activiti 5.x 用户指南 Apache MINA 2 用户指南 Apache Shiro 用户指南 Google Java编程风格指南 H2 Database 教程 Java Servlet 3.1 规范 Java 编码规范 Jersey 2.x 用户指南 JSSE 参考指南 MyBatis中文文档 Netty 4.x 用户指南 Netty 实战(精髓) REST 实战 Spring Boot参考指南 (翻译中) Spring Framework 4.x参考文档 用jersey构建REST服务 Javascript Airbnb JavaScript 规范 AngularJS AngularJS入门教程 AngularJS最佳实践和风格指南 在Windows环境下用Yeoman构建AngularJS项目 构建自己的AngularJS backbone.js backbone.js中文文档 backbone.js入门教程 (PDF) Backbone.js入门教程第二版 Chrome扩展及应用开发 CoffeeScript CoffeeScript 编码风格指南 D3.js Learning D3.JS (Created by 十二月咖啡馆) 官方API文档 张天旭的D3教程 楚狂人的D3教程 ECMAScript 6 入门 (作者：阮一峰) ExtJS Ext4.1.0 中文文档 Google JavaScript 代码风格指南 Google JSON 风格指南 impress.js impress.js的中文教程 JavaScript Promise迷你书 Javascript 原理 JavaScript 标准参考教程（alpha） 《JavaScript 模式》 “JavaScript patterns”中译本 javascript 的 12 个怪癖 JavaScript 秘密花园 JavaScript核心概念及实践 (PDF) (此书已由人民邮电出版社出版发行，但作者依然免费提供PDF版本，希望开发者们去购买，支持作者) Javascript编程指南 (源码) jQuery How to write jQuery plugin 简单易懂的JQuery魔法 Node.js express.js 中文文档 Express框架 koa 中文文档 Learn You The Node.js For Much Win! (中文版) Node debug 三法三例 Node.js Fullstack《從零到一的進撃》 Node.js 包教不包会 Nodejs Wiki Book (繁体中文) nodejs中文文档 Node入门 七天学会NodeJS 使用 Express + MongoDB 搭建多人博客 JavaScript全栈工程师培训材料 React.js Learn React &amp; Webpack by building the Hacker News front page React Native 中文文档(含最新Android内容) React webpack-cookbook React.js 中文文档 React.js 入门教程 Vue.js Vue.js中文文档 Zepto.js Zepto.js 中文文档 你不知道的Javascript (深入JavaScript语言核心机制的系列图书) 命名函数表达式探秘 (注:原文由为之漫笔 翻译，原始地址无法打开，所以此处地址为我博客上的备份) 学用 JavaScript 设计模式 (开源中国) 深入理解JavaScript系列 LaTeX LaTeX 笔记 一份不太简短的 LaTeX2ε 介绍 大家來學 LaTeX (PDF) LISP ANSI Common Lisp 中文翻译版 Common Lisp 高级编程技术 (《On Lisp》中文版) Lua Lua 5.3 参考手册 Markdown Markdown 快速入门 Markdown 简明教程 Markdown 语法说明 献给写作者的 Markdown 新手指南 Node.js Node 入门 The NodeJS 中文文档 （社区翻译） 七天学会NodeJS 阿里出品，很好的入门资料 Perl Master Perl Today Perl 5 教程 Perl 教程 PHP Composer中文文档 Laravel5.4中文文档 Phalcon7中文文档 PHP 之道 PHP中文手册 PHP标准规范中文版 Symfony2 实例教程 Yii2中文文档 深入理解 PHP 内核 Python Django 1.11.6 中文文档 Django book 2.0 Python 3 文档(简体中文) 3.2.2 documentation Python Cookbook第三版 (作者：David Beazley, Brian K.Jones 翻译：熊能) Python 中文学习大本营 Python之旅 (作者：Ethan) Python教程 - 廖雪峰的官方网站 像计算机科学家一样思考Python (中英对照版 作者：Allen B. Downey 翻译：大胖哥) 深入 Python 3 笨办法学 Python 简明 Python 教程 (作者：Swaroop C H 译者：沈洁元、漠伦) Django Django Girls 教程 (1.11) (HTML) R 153分钟学会 R (PDF) R 导论 (《An Introduction to R》中文版) (PDF) 用 R 构建 Shiny 应用程序 (《Building ‘Shiny’ Applications with R》中文版) 统计学与 R 读书笔记 (PDF) reStructuredText reStructuredText 入门 Ruby Rails 风格指南 Ruby on Rails 实战圣经 Ruby on Rails 指南 Ruby 风格指南 Sinatra 笨方法学 Ruby Rust Rust 官方教程 Rust 语言学习笔记 RustPrimer 通过例子学习 Rust Scala Effective Scala Scala 初学者指南 (The Neophyte’s Guide to Scala) Scala 课堂 (Twitter的Scala中文教程) Scheme Scheme 入门教程 (《Yet Another Scheme Tutorial》中文版) Scratch 创意计算课程指南 Shell shell-book Shell 编程基础 Shell 脚本编程30分钟入门 The Linux Command Line 中文版 Swift 《The Swift Programming Language》中文版 Vim Vim Manual(中文版) 大家來學 VIM Visual Prolog Visual Prolog 7初学指南 Visual Prolog 7边练边学","tags":[{"name":"分享","slug":"分享","permalink":"https://jiaopianjun.cc/tags/分享/"}]},{"title":"Javascript数组操作","date":"2019-02-19T03:12:01.000Z","path":"2019/02/19/Javascript数组操作.html","text":"1、concat()1234567concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，仅会返回被连接数组的一个副本。var arr1 = [1,2,3];var arr2 = [4,5];var arr3 = arr1.concat(arr2);console.log(arr1); //[1, 2, 3]console.log(arr3); //[1, 2, 3, 4, 5] 2、join()12345join() 方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的，默认使用','号分割，不改变原数组。var arr = [2,3,4];console.log(arr.join()); //2,3,4console.log(arr); //[2, 3, 4] 3、push()12345678push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。末尾添加，返回的是长度，会改变原数组。var a = [2,3,4];var b = a.push(5);console.log(a); //[2,3,4,5]console.log(b); //4push方法可以一次添加多个元素push(data1,data2....) 4、pop()12345pop() 方法用于删除并返回数组的最后一个元素。返回最后一个元素，会改变原数组。var arr = [2,3,4];console.log(arr.pop()); //4console.log(arr); //[2,3] 5、shift()12345shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。返回第一个元素，改变原数组。var arr = [2,3,4];console.log(arr.shift()); //2console.log(arr); //[3,4] 6、unshift()1234567unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。返回新长度，改变原数组。var arr = [2,3,4,5];console.log(arr.unshift(3,6)); //6console.log(arr); //[3, 6, 2, 3, 4, 5]tip:该方法可以不传参数,不传参数就是不增加元素。 7、slice()12345slice() 返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。返回选定的元素，该方法不会修改原数组。var arr = [2,3,4,5];console.log(arr.slice(1,3)); //[3,4]console.log(arr); //[2,3,4,5] 8、splice()12345678相同点：如果只是写一个参数，两者的作用都一样：都是是截取字符串从当前下标以后直到字符串最后的字符串片段。var a = [5,6,7,8];console.log(a.splice(1,0,9)); //[]console.log(a); // [5, 9, 6, 7, 8]var b = [5,6,7,8];console.log(b.splice(1,2,3)); //[6, 7]console.log(b); //[5, 3, 8] 9、substring() 和 substr()1234567891011121314splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。splice() 方法会直接对数组进行修改。substr(startIndex);substring(startIndex);var str = '123456789';console.log(str.substr(2)); // \"3456789\"console.log(str.substring(2)) ;// \"3456789\"不同点：第二个参数substr（startIndex,lenth）： 第二个参数是截取字符串的长度（从起始点截取某个长度的字符串）；substring（startIndex, endIndex）： 第二个参数是截取字符串最终的下标 （截取2个位置之间的字符串,‘含头不含尾'）。console.log(\"123456789\".substr(2,5)); // \"34567\"console.log(\"123456789\".substring(2,5)) ;// \"345\" 10、sort 排序123456按照 Unicode code 位置排序，默认升序var fruit = ['cherries', 'apples', 'bananas'];fruit.sort(); // ['apples', 'bananas', 'cherries']var scores = [1, 10, 21, 2];scores.sort(); // [1, 10, 2, 21] 11、reverse()12345reverse() 方法用于颠倒数组中元素的顺序。返回的是颠倒后的数组，会改变原数组。var arr = [2,3,4];console.log(arr.reverse()); //[4, 3, 2]console.log(arr); //[4, 3, 2] 12、indexOf 和 lastIndexOf123456789101112131415161718192021都接受两个参数：查找的值、查找起始位置不存在，返回 -1 ；存在，返回位置。indexOf 是从前往后查找， lastIndexOf 是从后往前查找。indexOfvar a = [2, 9, 9];a.indexOf(2); // 0a.indexOf(7); // -1if (a.indexOf(7) === -1) &#123; // element doesn't exist in array&#125;lastIndexOfvar numbers = [2, 5, 9, 2];numbers.lastIndexOf(2); // 3numbers.lastIndexOf(7); // -1numbers.lastIndexOf(2, 3); // 3numbers.lastIndexOf(2, 2); // 0numbers.lastIndexOf(2, -2); // 0numbers.lastIndexOf(2, -1); // 3 13、every123456对数组的每一项都运行给定的函数，每一项都返回 ture,则返回 truefunction isBigEnough(element, index, array) &#123; return element &lt; 10;&#125; [2, 5, 8, 3, 4].every(isBigEnough); // true 14、some1234567对数组的每一项都运行给定的函数，任意一项都返回 ture,则返回 truefunction compare(element, index, array) &#123; return element &gt; 10;&#125; [2, 5, 8, 1, 4].some(compare); // false[12, 5, 8, 1, 4].some(compare); // true 15、filter1234567对数组的每一项都运行给定的函数，返回 结果为 ture 的项组成的数组var words = [\"spray\", \"limit\", \"elite\", \"exuberant\", \"destruction\", \"present\", \"happy\"];var longWords = words.filter(function(word)&#123; return word.length &gt; 6;&#125;);// Filtered array longWords is [\"exuberant\", \"destruction\", \"present\"] 16、map1234567891011121314对数组的每一项都运行给定的函数，返回每次函数调用的结果组成一个新数组var numbers = [1, 5, 10, 15];var doubles = numbers.map(function(x) &#123; return x * 2;&#125;);// doubles is now [2, 10, 20, 30]// numbers is still [1, 5, 10, 15]十七、forEach 数组遍历const items = ['item1', 'item2', 'item3'];const copy = []; items.forEach(function(item)&#123; copy.push(item)&#125;); ES6新增新操作数组的方法1、find()：1234传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它，并且终止搜索。const arr = [1, \"2\", 3, 3, \"2\"]console.log(arr.find(n =&gt; typeof n === \"number\")) // 1 2、findIndex()：1234传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它的下标，终止搜索。const arr = [1, \"2\", 3, 3, \"2\"]console.log(arr.findIndex(n =&gt; typeof n === \"number\")) // 0 3、fill()：123用新元素替换掉数组内的元素，可以指定替换下标范围。arr.fill(value, start, end) 4、copyWithin()：123456789101112选择数组的某个下标，从该位置开始复制数组元素，默认从0开始复制。也可以指定要复制的元素范围。arr.copyWithin(target, start, end)const arr = [1, 2, 3, 4, 5]console.log(arr.copyWithin(3)) // [1,2,3,1,2] 从下标为3的元素开始，复制数组，所以4, 5被替换成1, 2const arr1 = [1, 2, 3, 4, 5]console.log(arr1.copyWithin(3, 1)) // [1,2,3,2,3] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，所以4, 5被替换成2, 3const arr2 = [1, 2, 3, 4, 5]console.log(arr2.copyWithin(3, 1, 2)) // [1,2,3,2,5] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，结束位置为2，所以4被替换成2 5、from12345678将类似数组的对象（array-like object）和可遍历（iterable）的对象转为真正的数组const bar = [\"a\", \"b\", \"c\"];Array.from(bar);// [\"a\", \"b\", \"c\"]Array.from('foo');// [\"f\", \"o\", \"o\"] 6、of123456789用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数 Array() 的不足。因为参数个数的不同，会导致 Array() 的行为有差异。Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8]Array.of(7); // [7]Array.of(1, 2, 3); // [1, 2, 3]Array(7); // [ , , , , , , ]Array(1, 2, 3); // [1, 2, 3] 7、entries() 返回迭代器：返回键值对12345678910111213141516171819202122//数组const arr = ['a', 'b', 'c'];for(let v of arr.entries()) &#123; console.log(v)&#125;// [0, 'a'] [1, 'b'] [2, 'c']//Setconst arr = new Set(['a', 'b', 'c']);for(let v of arr.entries()) &#123; console.log(v)&#125;// ['a', 'a'] ['b', 'b'] ['c', 'c']//Mapconst arr = new Map();arr.set('a', 'a');arr.set('b', 'b');for(let v of arr.entries()) &#123; console.log(v)&#125;// ['a', 'a'] ['b', 'b'] 8、values() 返回迭代器：返回键值对的value12345678910111213141516171819202122//数组const arr = ['a', 'b', 'c'];for(let v of arr.values()) &#123; console.log(v)&#125;//'a' 'b' 'c'//Setconst arr = new Set(['a', 'b', 'c']);for(let v of arr.values()) &#123; console.log(v)&#125;// 'a' 'b' 'c'//Mapconst arr = new Map();arr.set('a', 'a');arr.set('b', 'b');for(let v of arr.values()) &#123; console.log(v)&#125;// 'a' 'b' 9、keys() 返回迭代器：返回键值对的key12345678910111213141516171819202122//数组const arr = ['a', 'b', 'c'];for(let v of arr.keys()) &#123; console.log(v)&#125;// 0 1 2//Setconst arr = new Set(['a', 'b', 'c']);for(let v of arr.keys()) &#123; console.log(v)&#125;// 'a' 'b' 'c'//Mapconst arr = new Map();arr.set('a', 'a');arr.set('b', 'b');for(let v of arr.keys()) &#123; console.log(v)&#125;// 'a' 'b' 10、includes12345判断数组中是否存在该元素，参数：查找的值、起始位置，可以替换 ES5 时代的 indexOf 判断方式。indexOf 判断元素是否为 NaN，会判断错误。var a = [1, 2, 3];a.includes(2); // truea.includes(4); // false","tags":[]},{"title":"JavaScript类型相关常用操作","date":"2019-02-15T02:01:00.000Z","path":"2019/02/15/JavaScript类型相关常用操作.html","text":"一、 JS数组，字符串，json互相转换1.JS数组转字符串1234567891011121314151617使用数组自带的join方法可以把数组转化为字符串： let arr = [1,2,'uu']; let str = arr.join(','); console.log(str); // 1,2,uu如果素组元素包含对象，则调用对象的toString()方法将对象转化为字符串。 class C &#123; // 自定义类C，以及自定义toString()方法 toString() &#123; return 'class C'; &#125; &#125; let cc = new C(); // C的实例 let arr = [&#123;a: 1&#125;, cc, [3,4,[5,5]], 5]; let str = arr.join('---'); console.log(str); // [object Object]---class C---3,4,5,5---5 从上面的例子中还可以发现，数组中嵌套数组时，所有元素依次打印出来，那是因为数组Array的toString()方法内部实现就是join. [1,1,[2,2,[3,3,3]]] + \"\"; // 1,1,2,2,3,3,3 2.字符串转数组12345使用字符串自带的split方法可以把字符串分割为数组。 let str = '1,2,uu'; let arr = str.split(','); console.log(arr); // [\"1\", \"2\", \"uu\"] str 3.数组转json字符串，json字符串转数组12345678使用JSON.parse()方法可以解析json字符串转化为相应的json对象（包括数组），使用JSON.stringify()方法可以把数组或对象转化为json字符串。let arr = [1,2,'uu'];let jsonStr = JSON.stringify(arr);console.log(jsonStr); // 字符串：'[1,2,\"uu\"]'let jsonObj = JSON.parse(jsonStr);console.log(jsonObj); // 数组： [1,2,'uu'] 二、 JS清空数组的方法1.赋值空数组1234let arr = [1,2,3];console.log(arr); // [1,2,3]arr = [];console.log(arr); // [] 2.修改length属性123456JS数组的length熟悉可以直接修改。let arr = [1,2,3];console.log(arr); // [1,2,3]arr.length = 0;console.log(arr); // [] 3.使用splice方法1234JS中数组自带的splice()方法用于向数组中添加或者删除元素，功能非常强大。参数说明如下，返回值为包含被删除项目的新数组，如果有的话。arrayObject.splice(index,howmany,item1,.....,itemX) 参数名 描述 index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, …, itemX 可选。向数组添加的新项目。 12345let arr = [1,2,3];console.log(arr); // [1,2,3]let arr2 = arr.splice(0, arr.length); // 删除所有元素console.log(arr); // []console.log(arr2); // [1,2,3] 三、JS时间和时间戳的转换1.JS时间转时间戳123456789101112131415使用Date对象的方法：let dateObj = new Date(); // Date对象，当前时间// parse()方法，毫秒级别的数值被转化为000Date.parse(dateObj); // 1549976497000// Date对象的valueOf()方法dateObj.valueOf(); // 1549976497495// Date对象的getTime()方法dateObj.getTime(); // 1549976497495// 转化为Number类型，包括显式和隐式类型转换new Number(dateObj); // Number &#123;1549976497495&#125;dateObj - 0; // 1549976497495 2.JS时间戳转时间1234567891011121314151617181920212223Date()对象的构造函数不仅可以接受表示时间戳数字类型的参数，还可以接受时间字符串，但是对格式有要求。let timeStr = '2019-02-02 12:12:12';let dateObj = new Date(timeStr);dateObj.getTime(); // 1549080732000dateObj.toDateString(); // Sat Feb 02 2019dateObj.toString(); // Sat Feb 02 2019 12:12:12 GMT+0800 (中国标准时间)dateObj.toLocaleString(); // 2019/2/2 下午12:12:12myDate.getYear(); //获取当前年份(2位)myDate.getFullYear(); //获取完整的年份(4位,1970-????)myDate.getMonth(); //获取当前月份(0-11,0代表1月)myDate.getDate(); //获取当前日(1-31)myDate.getDay(); //获取当前星期X(0-6,0代表星期天)myDate.getTime(); //获取当前时间(从1970.1.1开始的毫秒数) myDate.getHours(); //获取当前小时数(0-23)myDate.getMinutes(); //获取当前分钟数(0-59)myDate.getSeconds(); //获取当前秒数(0-59)myDate.getMilliseconds(); //获取当前毫秒数(0-999)myDate.toLocaleDateString(); //获取当前日期var mytime=myDate.toLocaleTimeString(); //获取当前时间myDate.toLocaleString( ); //获取日期与时间----如果涉及到时分秒，直接使用即可。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://jiaopianjun.cc/tags/javascript/"}]},{"title":"CSS实现 Tab hover 下划线跟随","date":"2019-02-05T06:53:00.000Z","path":"2019/02/05/CSS实现-Tab-hover-下划线跟随.html","text":"html12345678910&lt;div class=\"menu\"&gt; &lt;ul&gt; &lt;li&gt;你好啊&lt;/li&gt; &lt;li&gt;我的名字叫&lt;/li&gt; &lt;li&gt;Pte Lundde&lt;/li&gt; &lt;li&gt;很高兴认识你哦&lt;/li&gt; &lt;li&gt;希望&lt;/li&gt; &lt;li&gt;你能成为我的朋友&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; css123456789101112131415161718192021222324252627282930.menu ul&#123; height: 30px; width: auto; line-height: 30px;&#125;.menu ul li&#123; position: relative; float: left; display: inline-block; padding:0 30px; height: 30px; line-height: 30px;&#125;.menu ul li::before&#123; content:''; position: absolute; top:0; left:100%; width: 0; height: 100%; border-bottom: 2px solid #000; transition: all .3s linear;&#125;.menu ul li:hover::before&#123; left:0; width: 100%&#125;.menu ul li:hover ~ li::before&#123; left:0;&#125; 效果预览","tags":[{"name":"css","slug":"css","permalink":"https://jiaopianjun.cc/tags/css/"}]},{"title":"极简天气之小夭天气","date":"2019-01-22T05:44:00.000Z","path":"2019/01/22/Untitled-1.html","text":"1、利用周末两天的时间，参考小天气的风格，撸了一个天气小程序，【小夭天气】。2、功能十分简单，查看当前地区的天气和搜索其他地区的天气，增加了可以生成图片分享出去。3、上线后发现一个问题，就是极速提供的天气接口对区级市没有区分，例如 上海有宝山区，东北那也有一个。就没有区分。这是一个bug4、其他有什么问题欢迎大家提意见和建议。欢迎大家扫码体验 详情如下 首页 首页 首页 空气质量详情 生活指数详情 多日天气详情 部分代码如下：12345678910&lt;!-- 生成图片 --&gt;&lt;view class=\"saveimage\" wx:if=\"&#123;&#123;canvasPic&#125;&#125;\"&gt; &lt;view class=\"loading\" wx:if=\"&#123;&#123;loading&#125;&#125;\"&gt;&lt;image src=\"../images/loading.gif\" class=\"loading\"&gt;&lt;/image&gt;&lt;/view&gt; &lt;canvasdrawer painting=\"&#123;&#123;painting&#125;&#125;\" bind:getImage=\"eventGetImage\"/&gt; &lt;view class=\"picbox\"&gt; &lt;view class=\"saveimageCont\"&gt;&lt;image src=\"&#123;&#123;shareImage&#125;&#125;\" mode=\"widthFix\"&gt;&lt;/image&gt;&lt;/view&gt; &lt;button class=\"keep\" catchtap='eventSave'&gt;&#123;&#123;shareText&#125;&#125;&lt;/button&gt; &lt;text class=\"keep keep2\" bindtap=\"closesaveimage\"&gt;返回&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; 1234567891011121314151617181920212223242526&lt;!--选择地区--&gt;&lt;view class=\"selectArea &#123;&#123;getLotion === '' ? 'nomargin' :'' &#125;&#125;\" wx:if=\"&#123;&#123;selectArea&#125;&#125;\"&gt; &lt;!-- 返回 --&gt; &lt;view class=\"selectAreaBox\" :dss=\"getLotion\"&gt; &lt;view class=\"back\" wx:if=\"&#123;&#123;getLotion === 'null' || getLotion !== ''&#125;&#125;\"&gt; &lt;view class=\"backIcon\" bindtap=\"back\"&gt; &lt;image src=\"../images/back.png\" class=\"img\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"input\"&gt; &lt;input type=\"text\" class=\"Jinput\" placeholder=\"请输入地区\" bindinput='writeArea' value=\"&#123;&#123;inpuText&#125;&#125;\" &gt;&lt;/input&gt; &lt;image src=\"../images/serchicon.png\" class=\"imgicon\"&gt;&lt;/image&gt; &lt;view class=\"clear\" bindtap=\"clearInpuText\"&gt;&lt;image src=\"../images/clear.png\" class=\"clearicon\"&gt;&lt;/image&gt;&lt;/view&gt; &lt;view class=\"sureBtn\" bindtap=\"inputGoWeather\"&gt;&lt;image src=\"../images/surebtn.png\" class=\"sureicon\"&gt;&lt;/image&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class=\"tips\"&gt;历史记录&lt;/view&gt; &lt;view class=\"hisCity\"&gt; &lt;view class=\"hisCityBtn\" data-city=\"&#123;&#123;list&#125;&#125;\" wx:for=\"&#123;&#123;historyArea&#125;&#125;\" wx:for-item=\"list\" wx:key wx:if=\"historyArea.length &gt; 0\" bindtap=\"goWeather\"&gt;&#123;&#123;list&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;view class=\"tips\"&gt;热门城市&lt;/view&gt; &lt;view class=\"recCity\"&gt; &lt;view class=\"recCityBtn getLocation\" bindtap=\"selectLocation\"&gt;&lt;image class=\"getLocationimg\" src=\"../images/hoticon.png\"&gt;&lt;/image&gt;定位&lt;/view&gt; &lt;view class=\"recCityBtn\" data-city=\"&#123;&#123;list&#125;&#125;\" wx:for=\"&#123;&#123;hotArea&#125;&#125;\" wx:for-item=\"list\" wx:key bindtap=\"goWeather\"&gt;&#123;&#123;list&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162getWeatherData:function(city)&#123; var _this = this, thisdata = this.data, historyArea = thisdata.historyArea; wx.request(&#123; url: _this.data.api, data: &#123; \"city\": city &#125;, method: 'get', header: &#123; 'Content-Type': 'application/json' &#125;, dataType: 'jsonp', jsonp: 'callback', success: function (res) &#123; var res = res.data res = JSON.parse(res) if (res.status === \"0\") &#123; var data = res['result'] data.img = '../images/condicon/'+data.img+'b.png' _this.setData(&#123; getSuccess: 'true', getLotion: city, realdata: data, clock: data.updatetime, aqi: data['aqi'], aqiMsg: data.aqi.aqiinfo['affect'] + '，' + data.aqi.aqiinfo['measure'], life: data['index'], daily: data['daily'], hourly: data['hourly'], airPredict: '两小时之后天气' + data.hourly[2].weather + ' ，温度 ' + data.hourly[2].temp + '°', quality: data['aqi'].quality &#125;) // 搜索返回成功后 清除 输入框，将搜索结果放入历史记录 // _this.$refs.clearText.value = '' if (thisdata.inpuText !== '') &#123; if (thisdata.historyArea.indexOf(thisdata.inpuText) === -1) &#123; historyArea.push(thisdata.inpuText) _this.setData(&#123; historyArea: historyArea &#125;) &#125; &#125; _this.back() &#125; else &#123; wx.showModal(&#123; title: '提示', content: res.msg, success: function (res) &#123; if (res.confirm) &#123; _this.setData(&#123; msgText: '位置获取失败！！！请手动选择', loadingBtn: true &#125;) &#125; else if (res.cancel) &#123; console.log('用户点击取消') &#125; &#125; &#125;) &#125; &#125;, 12345678910111213141516171819202122232425262728293031323334353637383940// 定位获取 selectLocation: function () &#123; let _this = this _this.getlocation(); &#125;, getlocation: function () &#123; var _this = this wx.getLocation(&#123; type: 'wgs84', success: function (res) &#123; console.log(res) var latitude = res.latitude var longitude = res.longitude var speed = res.speed var accuracy = res.accuracy qqmapsdk.reverseGeocoder(&#123; location: &#123; latitude: latitude, longitude: longitude &#125;, success: function (res) &#123; console.log(res) _this.setData(&#123; getLotion: res.result.address_component.district ? res.result.address_component.district : res.result.address_component.city &#125;) wx.setNavigationBarTitle(&#123; title: res.result.address_component.district &#125;) _this.getWeatherData(res.result.address_component.district) &#125; &#125;) &#125;, fail:function(res)&#123; _this.setData(&#123; msgText: '位置获取失败！！！请手动选择', loadingBtn:true &#125;) &#125; &#125;) &#125;,","tags":[{"name":"小程序","slug":"小程序","permalink":"https://jiaopianjun.cc/tags/小程序/"}]},{"title":"JS获取当前位置信息","date":"2019-01-14T01:58:00.000Z","path":"2019/01/14/面获取当前位置信息.html","text":"123456789101112function getLocation() &#123; var options = &#123; enableHighAccuracy : true, maximumAge : 1000 &#125; if (navigator.geolocation) &#123; navigator.geolocation.getCurrentPosition(onSuccess, onError, options); &#125; else &#123; alert('您的浏览器不支持地理位置定位'); &#125;&#125; 1234567891011121314//成功时function onSuccess(position) &#123; var longitude = position.coords.longitude; var latitude = position.coords.latitude; var map = new BMap.Map(\"allmap\"); var point = new BMap.Point(longitude, latitude); var gc = new BMap.Geocoder(); gc.getLocation(point, function(rs) &#123; var addComp = rs.addressComponents; document.getElementById(\"aera\").innerHTML = addComp.province + \", \" + addComp.city + \", \"+ addComp.district + \", \" + addComp.street + \", \"+ addComp.streetNumber; &#125;); // 这里后面可以写你的后续操作了 // postData(longitude, latitude);&#125; 1234567891011121314151617181920212223//失败时function onError(error) &#123; switch (error.code) &#123; case 1: alert(\"位置服务被拒绝\"); break; case 2: alert(\"暂时获取不到位置信息\"); break; case 3: alert(\"获取信息超时\"); break; case 4: alert(\"未知错误\"); break; &#125; // 这里后面可以写你的后续操作了 //经度 var longitude = 23.1823780000; //纬度 var latitude = 113.4233310000; postData(longitude, latitude);&#125; 12345// 页面载入时请求获取当前地理位置window.onload = function()&#123; // html5获取地理位置 getLocation();&#125;; 引入百度api 调用资源1&lt;script src=\"http://api.map.baidu.com/api?v=1.4\" type=\"text/javascript\"&gt;&lt;/script&gt;","tags":[{"name":"获取位置信息","slug":"获取位置信息","permalink":"https://jiaopianjun.cc/tags/获取位置信息/"}]},{"title":"Git操作（图）","date":"2019-01-03T03:24:00.000Z","path":"2019/01/03/Git操作（图）.html","text":"Git操作相关图谱","tags":[{"name":"Git","slug":"Git","permalink":"https://jiaopianjun.cc/tags/Git/"}]},{"title":"前端网络相关基础以及安全","date":"2018-12-25T06:22:00.000Z","path":"2018/12/25/端网络相关基础.html","text":"1.TCP UDP的区别12345678910111213141516171819202122TCP的优点：可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。UDP的优点： 快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP ……有些应用场景对可靠性要求不高会用到UPD，比如长视频，要求速率TCP与UDP区别总结：1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信5、TCP首部开销20字节;UDP的首部开销小，只有8个字节6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道7、基于连接与无连接；8、对系统资源的要求（TCP较多，UDP少）；9、UDP程序结构较简单；10、流模式与数据报模式 ；11、TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。 2.浏览器输入URL后发生了什么1234561. DNS域名解析2. 建立TCP连接3. 发起HTTP请求4. 接受响应结果5. 浏览器解析html6. 浏览器布局渲染 3.OSI/ISO七层模型1234567物理层：设备之间的比特流的传输、物理接口、电气特性等 数据链路层： 成帧、用MAC地址访问媒介、错误检测与修正 网络层：提供逻辑地址、选路 传输层：可靠与不可靠的传输、传输钱的错误检测、流控。 会话层：对应用会话的管理、同步 表示层：数据的表现形式、特定功能的实现如=》加密 应用层：用户接口 4.TCP三次握手和四次挥手的全过程1234567891011121314151617181920212223242526三次握手的过程step1:第一次握手建立连接时，客户端发送SYN包到服务器，其中包含客户端的初始序号seq=x，并进入SYN_SENT状态，等待服务器确认。（其中，SYN=1，ACK=0，表示这是一个TCP连接请求数据报文；序号seq=x，表明传输数据时的第一个数据字节的序号是x）。step2:第二次握手服务器收到请求后，必须确认客户的数据包。同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN_RECV状态。（其中确认报文段中，标识位SYN=1，ACK=1，表示这是一个TCP连接响应数据报文，并含服务端的初始序号seq(服务器)=y，以及服务器对客户端初始序号的确认号ack(服务器)=seq(客户端)+1=x+1）。step3:第三次握手客户端收到服务器的SYN+ACK包，向服务器发送一个序列号(seq=x+1)，确认号为ack(客户端)=y+1，此包发送完毕，客户端和服务器进入ESTAB_LISHED(TCP连接成功)状态，完成三次握手。未连接队列在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包(syn=j)开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包时，删除该条目，服务器进入ESTAB_LISHED状态。四次挥手过程（关闭客户端到服务器的连接）step1：第一次挥手首先，客户端发送一个FIN，用来关闭客户端到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u。step2：第二次挥手服务器收到这个FIN，它发送一个ACK，确认ack为收到的序号加一。step3：第三次挥手关闭服务器到客户端的连接，发送一个FIN给客户端。step4：第四次挥手客户端收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加一。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 5.http协议123HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样：HTTP定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而 HTTP 中的GET，POST，PUT，DELETE就对应着对这个资源的查，增，改，删4个操作。 6.IP划分123456789A类：0.0.0.0~127.255.255.255B类：128.0.0.0~191.255.255.255C类：192.0.0.0~223.255.255.255D类：224.0.0.0~239.255.255.255E类：240.0.0.0~247.255.255.255 7.Ngnix代理跨域1234567891011121314151617181920212223242526272829303132333435server &#123; listen 80; #监听80端口，可以改成其他端口 server_name localhost; # 当前服务的域名 #charset koi8-r; #access_log logs/host.access.log main; location / &#123; proxy_pass http://localhost:81; proxy_redirect default; &#125; location /apis &#123; #添加访问目录为/apis的代理配置 rewrite ^/apis/(.*)$ /$1 break; proxy_pass http://localhost:82; &#125;&#125;配置解释：1.由配置信息可知，我们让nginx监听localhost的80端口，网站A与网站B的访问都是经过localhost的80端口进行访问。2.我们特殊配置了一个“/apis”目录的访问，并且对url执行了重写，最后使以“/apis”开头的地址都转到“http://localhost:82”进行处理。3.rewrite ^/apis/(.*)$ /$1 break; 代表重写拦截进来的请求，并且只能对域名后边以“/apis”开头的起作用，例如www.a.com/apis/msg?x=1重写。只对/apis重写。 rewrite后面的参数是一个简单的正则 ^/apis/(.*)$ ,$1代表正则中的第一个(),$2代表第二个()的值,以此类推。 break代表匹配一个之后停止匹配。 5.总结浏览器跨域的解决方式有很多种：1.jsonp 需要目标服务器配合一个callback函数。2.window.name+iframe 需要目标服务器响应window.name。3.window.location.hash+iframe 同样需要目标服务器作处理。4.html5的 postMessage+ifrme 这个也是需要目标服务器或者说是目标页面写一个postMessage，主要侧重于前端通讯。5.CORS 需要服务器设置header ：Access-Control-Allow-Origin。6.nginx反向代理 这个方法一般很少有人提及，但是他可以不用目标服务器配合，不过需要你搭建一个中转nginx服务器，用于转发请求。 8.交换机与路由器有什么区别12345什么是路由器？路由器就像是出租车，上车后司机司机需要知道你的目的地（IP 地址），然后司机来负责选择线路到达目的地。到达目的地的线路可能根据实际的交通情况有所变化。什么是交换机？交换机就像地铁，从A到B的线路是固定的，只要你选择了到达地址（MAC),你就只能乘坐某条固定的线路，地铁司机也不会司机也不问你去哪里 9.TCP/IP的流量控制1所谓的流量控制就是让发送方的发送速率不要太快，让接收方来得及接受。利用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制。TCP的窗口单位是字节，不是报文段，发送方的发送窗口不能超过接收方给出的接收窗口的数值。 10.ICMP协议和DHCP协议123456789101112131415161718DHCP简介DHCP(Dynamic Host Configuration Protocol),动态主机配置协议，是一个应用层协议。当我们将客户主机ip地址设置为动态获取方式时，DHCP服务器就会根据DHCP协议给客户端分配IP，使得客户机能够利用这个IP上网。DHCP的实现分为4步，分别是： 第一步：Client端在局域网内发起一个DHCP Discover包，目的是想发现能够给它提供IP的DHCP Server。 第二步：可用的DHCP Server接收到Discover包之后，通过发送DHCP Offer包给予Client端应答，意在告诉Client端它可以提供IP地址。 第三步：Client端接收到Offer包之后，发送DHCP Request包请求分配IP。 第四步：DHCP Server发送ACK数据包，确认信息。ICMP协议详解ICMP协议是一个网络层协议。 一个新搭建好的网络，往往需要先进行一个简单的测试，来验证网络是否畅通；但是IP协议并不提供可靠传输。如果丢包了，IP协议并不能通知传输层是否丢包以及丢包的原因。 所以我们就需要一种协议来完成这样的功能–ICMP协议。ICMP协议的功能ICMP协议的功能主要有： 1. 确认IP包是否成功到达目标地址 2. 通知在发送过程中IP包被丢弃的原因 11.传输层协议与网络层协议的区别？1234567网络层负责ip数据报的产生以及ip数据包在逻辑网络上的路由转发。传输层提供端到端通信服务层次,提供可靠及非可靠连接。网络层只是根据网络地址将源结点发出的数据包传送到目的结点（点到点），其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。而传输层则负责将数据可靠地传送到相应的端口（端到端），传输层提供了主机应用程序进程之间的端到端的服务。传输层利用网络层提供的服务，并通过传输层地址提供给高层用户传输数据的通信端口，使高层用户看到的只是在两个传输实体间的一条端到端的、可由用户控制和设定的、可靠的数据通路。 12.说说静态路由和动态路由有什么区别12345静态路由 是在路由器中设置的固定的路由表。除非网络管理员干预，否则静态路由不会发生变化由于静态路由不能对网络的改变作出反映，一般用于网络规模不大、拓扑结构固定的网络中。静态路由的优点是简单、高效、可靠。在所有的路由中，静态路由优先级最高。当动态路由与静态路由发生冲突时，以静态路由为准动态路由 是网络中的路由器之间相互通信，传递路由信息，利用收到的路由信息更新路由器表的过程。它能实时地适应网络结构的变化。如果路由更新信息表明发生了网络变化，路由选择软件就会重新计算路由，并发出新的路由更新信息。这些信息通过各个网络，引起各路由器重新启动其路由算法，并更新各自的路由表以动态地反映网络拓扑变化。动态路由适用于网络规模大、网络拓扑复杂的网络。 13.跨站脚本攻击(XSS攻击)1234跨站脚本攻击(Cross Site Script为了区别于CSS简称为XSS)指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。怎么预防上面演示的是一个非常简单的XSS攻击，还有很多隐蔽的方式，但是其核心都是利用了脚本注入，因此我们解决办法其实很简单，不信赖用户输入，对特殊字符如”&lt;”,”&gt;”转义，就可以从根本上防止这一问题，当然很多解决方案都对XSS做了特定限制，如上面这中做法在ASP.NET中不幸不同，微软validateRequest对表单提交自动做了XSS验证。但防不胜防，总有些聪明的恶意用户会到我们的网站搞破坏，对自己站点不放心可以看看这个XSS跨站测试代码大全试试站点是否安全。 14.跨站请求伪造(CSRF攻击)1234567CSRF原理很简单，当用户登录以站点时用浏览器打开一恶意网址，就有可能遭受攻击。有同学会奇怪了这个很难实现吧，必须同时满足两个条件才行。其实很简单，比如我们使用QQ，看看QQ zone，突然蹦出个包含中奖或者问卷调查链接的聊天窗口（或者是。。。），这个腾讯做了防范，但是我们收到封邮件包含此内容，很多用户会选择去点击如何防范 1. 使用post，不使用get修改信息2. 验证码，所有表单的提交需要验证码，但是貌似用起来很麻烦，所以一些关键的操作可以3. 在表单中预先植入一些加密信息，验证请求是此表单发送 15.SQL注入攻击12345678910111213SQL注入是一种将SQL代码插入或添加到应用（用户）的输入参数中的攻击，之后再将这些参数传递给后台的SQL服务器加以解析并执行。原理：对构造成SQL语句的变量，过滤不严格，造成可以构造任意的SQL语句，传递到数据库执行。哪里能够引发SQL注入get query stringport stringhttp header1.在程序中进行过滤首先，针对SQL注入漏洞产生的原因，我们首先想到的，应该是严格限制用户提交的字符串。也就是URL之后的QueryString，当然，也包括Form、Cookie等。因此，我们需要在接受这些用户传值的页面对参数进行过滤。2.使用存储过程3.对用户密码进行加密 16.文件上传漏洞123456789101112131415161718192021什么是文件上传漏洞？文件上传漏洞是指由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。造成文件上传漏洞的原因以及原理原因：1 对于上传文件的后缀名（扩展名）没有做较为严格的限制2 对于上传文件的MIMETYPE(用于描述文件的类型的一种表述方法) 没有做检查3 权限上没有对于上传的文件目录设置不可执行权限，（尤其是对于shebang类型的文件）4 对于web server对于上传文件或者指定目录的行为没有做限制原理：在 WEB 中进行文件上传的原理是通过将表单设为 multipart/form-data，同时加入文件域，而后通过 HTTP 协议将文件内容发送到服务器，服务器端读取这个分段 (multipart) 的数据信息，并将其中的文件内容提取出来并保存的。通常，在进行文件保存的时候，服务器端会读取文件的原始文件名，并从这个原始文件名中得出文件的扩展名，而后随机为文件起一个文件名 ( 为了防止重复 )，并且加上原始文件的扩展名来保存到服务器上。文件上传漏洞的攻击与防御方式1.前端限制2.检查扩展名3.检查HTTP Header中的Content-Type4.分析文件头内容来检查文件类型5.限制Web Server对于特定类型文件的行为6.文件系统00截断7.其它方式—绕过","tags":[{"name":"网络","slug":"网络","permalink":"https://jiaopianjun.cc/tags/网络/"}]},{"title":"Vue响应式原理","date":"2018-12-25T06:16:00.000Z","path":"2018/12/25/Vue响应式原理.html","text":"1、vue响应式原理就是对你数据的变化，vue会有一个响应，去完成某件事。2、vue的响应式原理就是基于vue知道了数据发生了变化，那么vue是如何知道数据发生了变化呢？3、数据劫持 vue.js 采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter,getter，在数据变动时发布消息给订阅者，触发相应的监听回调1Object.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个值 4、数据劫持盲区1234561. vue 在实例化的时候会将data数据中的属性全部做数据劫持2. 如果时对象，也会迭代本身属性将全部属性都实现数据劫持3. 当赋值的时候，如果时newVal是对象，也会迭代newVal的属性实现全部属性的数据劫持什么时候会发生盲区： 比如说，data中现有一个obj 的值 list，但是现有list中没有name 这个属性。现在主动 list.name = 1，因为list.name的属性不是 Getter/Setter，所以赋值后不会去发布消息给订阅者，订阅者也没有办法更新。这就是数据劫持盲区 但是有一个有趣的现象：就是虽然obj.newparam不会发布消息，但是如果别的发布者触发的时候，页面局部渲染时如果包括obj.newparam的值，渲染效果也是会显示obj.newparam的最新值。这是由于页面更新时是直接读取的obj.newparam的值。 5. 数组Array的特殊性1234vue中实现的方法实际是对数组的属性重写，重写过后的方法不仅能实现原有的功能，还能发布消息给订阅者。当然Array也有特殊现象：如果要更新 Array 某个索引对应的值得时候，要用Vue.set方式实现``","tags":[{"name":"vue","slug":"vue","permalink":"https://jiaopianjun.cc/tags/vue/"}]},{"title":"JS快速排序记录","date":"2018-12-24T05:44:00.000Z","path":"2018/12/24/JS快速排序记录.html","text":"12345678910111213141516171819202122232425var arr = [1,5,25,7,55,21,45,2,3,64,135,333,7882]function quickSort(arr)&#123; if(arr.length &lt; 2) return arr; //如果长度小于2 直接返回 let left = 0, right = arr.length - 1; while(left &lt; right) &#123; while(arr[right] &gt; a[0] &amp;&amp; left &lt; right)&#123; // 找出右边比a[0]小的 right = right - 1 &#125; while(arr[left] &lt;= a[0] &amp;&amp; left &lt; right)&#123; // 找出右边比a[0]大的 left++; &#125; if(left == right)&#123; let mid = arr[right]; arr[right] = arr[0]; arr[0] = mid; break; &#125; let tmp = arr[right] arr[right] = arr[left] arr[left] = tmp &#125; return quickSort(arr.slice(0,left)).concat(arr.slice(left,right+1)).concat(quickSort(arr.slice(right+1)))&#125;console.log(quickSort(arr))","tags":[{"name":"javascript","slug":"javascript","permalink":"https://jiaopianjun.cc/tags/javascript/"}]},{"title":"Python + Wxpy  搭建简单微信机器人","date":"2018-12-21T03:46:00.000Z","path":"2018/12/21/Python-Wxpy-搭建简单微信机器人.html","text":"因为之前想过 如果每天早上微信能够发送天气预报给我，给我老婆多好，然后就动手看网上的教程做了一个可以定时发送天气预报的程序， 最近又想到折腾，做了一个更加详细的版本。但是需要主动操作 具体操作看图。 4bf724fa5a27670491cee4fd3b7977c.png d3d3306aa96844c06a4dd991a398e2b.png b0d0d26535ef1647a74fb0ec5853b5b.png 部分代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366#coding=utf8import requestsfrom requests import exceptionsfrom urllib.request import urlopenfrom bs4 import BeautifulSoupfrom urllib.parse import urlencodefrom threading import Timerimport refrom wxpy import *import scheduleimport timeimport httpimport json import datetimeimport randombot = Bot(cache_path=True,console_qr = 1)myself = bot.selfbot.enable_puid('wxpy_puid.pkl')tuling = Tuling(api_key='换成自己的图片key')group = bot.groups().search(u'Test')shgroup = bot.groups().search('伐木累🌱')friends = bot.friends().search(u'Lie')msgText = \"Helo! 回复'功能'获取对应功能\\n1.天气（例：苏州天气）\\n2.今日nba（注：今日所有比赛结果）\\n3.今日黄历\\n4.每日一句\\n5.开启机器人（关闭机器人）\\n6.今日古诗词\\n7.每日阅读\\n8.历史上的今天\\n9.nba排名(注：当日东西部排名)\\n10.新闻\\n 1.头条新闻\\n 2.社会新闻\\n 3.娱乐新闻\\n 4.体育新闻\\n11.星座运势（例如：天秤座）\" #任意回复获取的菜单newText = \"你可以这样回复： \\n1.头条新闻\\n2.社会新闻\\n3.娱乐新闻\\n4.体育新闻\"def get_now_weather(city): header = &#123; 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.8', 'Connection': 'keep-alive', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.235' &#125; url = 'https://free-api.heweather.com/s6/weather/now?location='+city+'&amp;key=换成自己的聚合数据key' PMurl = 'https://free-api.heweather.com/s6/air/now?parameters&amp;location='+city+'&amp;key=换成自己的和风key' # 设定超时时间，防止被网站认为是爬虫 timeout = random.choice(range(80, 180)) rep = requests.get(url, headers=header, timeout=timeout) pm = requests.get(PMurl, headers=header, timeout=timeout) result = '' temp = rep.json() temp = temp['HeWeather6'][0] update = temp['update'] now = temp['now'] nowTime = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S') pm = pm.json() pm = pm['HeWeather6'][0] print(now) airnow = pm['air_now_city'] result = city + '实时天气预报-' + '\\n'\\ + '更新时间：'+ update['loc'] + '\\n'\\ + ' 当前天气：'+ now['cond_txt'] + '\\n'\\ + ' 当前温度：'+ now['tmp'] + '°C' + '\\n'\\ + ' 体感温度：'+ now['fl'] + '°C' + '\\n'\\ + ' 风向：'+ now['wind_dir'] + ' ' + now['wind_sc'] + '级 '+ now['wind_spd'] + '公里/小时'+ '\\n'\\ + ' 相对湿度：'+ now['hum'] + '%' + '\\n'\\ + ' 降水量：'+ now['pcpn'] + 'ml' + '\\n'\\ + ' 能见度：'+ now['vis'] + '公里' + '\\n'\\ + ' 云量：'+ now['cloud'] + '\\n'\\ + '-----------------------------------' + '\\n'\\ + '当前空气质量：'+'\\n'\\ + ' 空气质量指数：'+ airnow['aqi']+'\\n'\\ + ' 主要污染物：'+ airnow['main']+'\\n'\\ + ' 空气质量：'+ airnow['qlty']+'\\n'\\ + ' 二氧化氮指数：'+ airnow['no2']+'\\n'\\ + ' 二氧化硫指数：'+ airnow['so2']+'\\n'\\ + ' 一氧化碳指数：'+ airnow['co']+'\\n'\\ + ' pm10指数：'+ airnow['pm10']+'\\n'\\ + ' pm25指数：'+ airnow['pm25']+'\\n'\\ + ' 臭氧指数：'+ airnow['o3']+'\\n' result = result + '发送时间：' + nowTime + '\\n' return resultdef get_news(type): header = &#123; 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.8', 'Connection': 'keep-alive', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.235' &#125; url = 'http://v.juhe.cn/toutiao/index?type='+str(type)+'&amp;key=换成自己的聚合数据key' timeout = random.choice(range(80, 180)) rep = requests.get(url, headers=header, timeout=timeout) data = json.loads(rep.text) data = data['result'] data = data['data'] item = [] obj = &#123;&#125; html = '今日'+str(type)+'新闻：'+ '\\n' for i in data: html = html + '标题：' + i['title'] + '\\n'\\ + '链接：' + i['url'] + '\\n'\\ + '分类：' + i['category'] + '\\n'\\ + '来自：' + i['author_name'] + '\\n'\\ + '时间：' + i['date'] + '\\n'\\ + '-----------------------------------------------' + '\\n' +'\\n' \\ return htmldef get_star(name): header = &#123; 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.8', 'Connection': 'keep-alive', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.235' &#125; url = 'http://web.juhe.cn:8080/constellation/getAll?consName='+str(name)+'&amp;type=today&amp;key=换成自己的聚合数据key' timeout = random.choice(range(80, 180)) rep = requests.get(url, headers=header, timeout=timeout) data = json.loads(rep.text) starhtml = '今日'+str(name)+'运势：'+ '\\n'\\ + ' 综合指数：' + data['all'] + '\\n'\\ + ' 幸运色：' + data['color'] + '\\n'\\ + ' 健康指数：' + data['health'] + '\\n'\\ + ' 爱情指数：' + data['love'] + '\\n'\\ + ' 财运指数：' + data['money'] + '\\n'\\ + ' 速配星座：' + data['QFriend'] + '\\n'\\ + ' 工作指数：' + data['work'] + '\\n'\\ + ' 今日概述：' + data['summary'] + '\\n'\\ return starhtmldef get_nba(): resp = urlopen('https://m.hupu.com/nba/game') soup = BeautifulSoup(resp,'html.parser') tagToday = soup.find('section',class_=\"match-today\") nbaHtml = '今日NBA比赛结果：' + '\\n' + '\\n' for tag in tagToday.find_all('a', class_='match-wrap'): nbaHtml = nbaHtml + tag.find('div', class_='away-team').span.get_text() + ' ' + tag.find('strong', class_='').span.get_text() + ' ' + tag.find('div', class_='home-team').span.get_text() + ' (' + tag.find('div', class_='match-status-txt').get_text() +')' + '\\n' return nbaHtml def get_rank(): resp = urlopen('https://m.hupu.com/nba/stats') soup = BeautifulSoup(resp,'html.parser') east = soup.find_all('li',class_= \"weast\")[0] west = soup.find_all('li',class_= \"weast\")[1] rankHtml = '今日NBA东部排名：（1.排名 2.球队 3.胜负 4.胜负差 5.最近情况）' + '\\n' + '\\n' for tag in east.find_all('li', class_=''): list = tag.find('p', class_='right-data') rankHtml = rankHtml + tag.find('span', class_='rank').get_text() + '. ' + tag.find('div', class_='').h1.get_text() + ' ' + list.find_all('span')[0].get_text() + ' ' + list.find_all('span')[1].get_text() +' '+ list.find_all('span')[2].get_text() +'\\n' rankHtml = rankHtml + '\\n' + '\\n' + '---------------------------------------------' + '\\n' + '\\n' rankHtml = rankHtml + '今日NBA西部排名：（1.排名 2.球队 3.胜负 4.胜负差 5.最近情况）' + '\\n' + '\\n' for tag in west.find_all('li', class_=''): list = tag.find('p', class_='right-data') rankHtml = rankHtml + tag.find('span', class_='rank').get_text() + '. ' + tag.find('div', class_='').h1.get_text() + ' ' + list.find_all('span')[0].get_text() + ' ' + list.find_all('span')[1].get_text() +' '+ list.find_all('span')[2].get_text() +'\\n' return rankHtml def invite(user): print('4') group = bot.groups().search('cc') group[0].add_members(user, use_invitation=True)@bot.register(msg_types=FRIENDS)@bot.register(group)@bot.register(shgroup,TEXT)@bot.register(friends)def auto_reply_all(msg): if '苏州天气' in msg.text: nowWeather = get_now_weather('苏州') msg.sender.send(nowWeather) elif 'py' in msg.text.lower(): # 接受好友 (msg.card 为该请求的用户对象) new_friend = bot.accept_friend(msg.card) # 或 new_friend = msg.card.accept() # 向新的好友发送消息 new_friend.send('哈哈，我自动接受了你的好友请求，发送【帮助】获取帮助！！') elif '上海天气' in msg.text: nowWeather = get_now_weather('上海') msg.sender.send(nowWeather) elif '帮助' in msg.text: msg.sender.send(msgText) elif '每日一句' in msg.text: url = 'http://open.iciba.com/dsapi/' r = requests.get(url) content = json.loads(r.text) msg.sender.send('每日一句：\\n'+content['content'] +'\\n'+content['note']+\"\\n\") elif '今日黄历' in msg.text: header = &#123; 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.8', 'Connection': 'keep-alive', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.235' &#125; timeout = random.choice(range(80, 180)) wk = &#123;\"Sunday\":\"星期日\",\"Monday\":\"星期一\",\"Tuesday\":\"星期二\",\"Wednesday\":\"星期三\",\"Thursday\":\"星期四\",\"Friday\":\"星期五\",\"Saturday\":\"星期六\"&#125; yy = &#123;\"False\":\"不是\",\"True\":\"是\"&#125; url = \"https://www.sojson.com/open/api/lunar/json.shtml\" r = requests.get(url, headers= header, timeout=timeout) jsonarr = json.loads(r.text) result = jsonarr[\"data\"] xingqi = str(wk[result['week']]) yangli = '阳历日期：' + str(result['year']) +'-'+ str(result['month']) +'-'+ str(result['day']) nongli = '农历日期：' + str(result['cnyear']) + '-' + str(result['cnmonth']) + '月-' + str(result['cnday']) +'日' jieqibody = result[\"jieqi\"] jieqi ='本月节气:' for i in jieqibody: jieqi += i + '日' + jieqibody[i] + '，' leap = '是否是闰月：' + str(result['leap']) maxDayInMonth = '农历当月天数：' + str(result['maxDayInMonth']) festivalList = '当天节日：' + str(result['festivalList']) jiazi = '甲子:' + str(result['cyclicalYear']) + '-' + str(result['cyclicalMonth']) + '-' + str(result['cyclicalDay']) shengxiao = '今年生肖：' + str(result['animal']) yi = '宜：' + str(result['suit']) ji = '忌：' + str(result['taboo']) msg.sender.send('今天是:'+ xingqi + '\\n' + '本日黄历：' + '\\n' + yangli + '\\n' + nongli + \"\\n\" + jiazi + \"\\n\" + shengxiao + \"\\n\" + yi + \"\\n\" + ji + \"\\n\" + leap + \"\\n\" + maxDayInMonth + \"\\n\" + festivalList + \"\\n\" + jieqi + \"\\n\") elif '今日古诗词' in msg.text: header = &#123; 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.8', 'Connection': 'keep-alive', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.235' &#125; timeout = random.choice(range(80, 180)) url = \"https://v2.jinrishici.com/info\" urlA = \"https://v2.jinrishici.com/one.json\" r = requests.get(url, headers= header, timeout=timeout) rA = requests.get(urlA, headers= header, timeout=timeout) jsonarr = json.loads(r.text) jsonA = json.loads(rA.text) result = jsonarr[\"data\"] resultA = jsonA[\"data\"] content = str(resultA['content']) origin = resultA['origin'] title = str(origin['title']) dynasty = str(origin['dynasty']) author = str(origin['author']) detail = '《' + ',\\n'.join(origin['content']) + '》' matchTags = '推荐关键词：' + ','.join(resultA['matchTags']) sendTime = '发送时间：' + str(resultA['cacheAt']) ipAddress = '查询人IP：' + str(result['ip']) address = '查询人地址：' + str(result['region']) weatherData = result['weatherData'] wd = ' 实时温度：' + str(weatherData['temperature']) + '°C' fx = str(weatherData['windDirection']) fl = str(weatherData['windPower']) sd = ' 湿度：' + str(weatherData['humidity']) uptime = ' 更新时间：' + str(weatherData['updateTime']) we = ' 天气：' + str(weatherData['weather']) njd = ' 能见度：' + str(weatherData['visibility']) yu = ' 雨量：' + str(weatherData['rainfall']) pm25 = ' pm2.5：' + str(weatherData['pm25']) tags = ' ' + ','.join(result['tags']) scMsg = content + '\\n' + ' ---- 这是来自' + dynasty + '诗人' + author + '的' + '《'+ title +'》' + '\\n' + matchTags + '\\n' +'诗句详情：' + '\\n' + detail + '\\n' + '\\n' + sendTime + '\\n' + ipAddress + '\\n' + address + '\\n' + '天气（实时）：' + '\\n' + we + '\\n' + wd + '\\n' + ' 风向：' + fx + fl + '\\n' + sd +'\\n' + njd + '\\n' + yu + '\\n' + pm25 + '\\n' + '标签：' + '\\n' + tags msg.sender.send(scMsg) elif '帮助' in msg.text: msg.sender.send(msgText) elif '今日nba' in msg.text: nba = get_nba() msg.sender.send(nba) elif 'nba排名' in msg.text: nbarank = get_rank() msg.sender.send(nbarank) elif '头条新闻' in msg.text: nlist = get_news('头条') msg.sender.send(nlist) elif '娱乐新闻' in msg.text: nlist = get_news('娱乐') msg.sender.send(nlist) elif '体育新闻' in msg.text: nlist = get_news('体育') msg.sender.send(nlist) elif '社会新闻' in msg.text: nlist = get_news('社会') msg.sender.send(nlist) elif '每日阅读' in msg.text: header = &#123; 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.8', 'Connection': 'keep-alive', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; WOW64) A&lt;Appl&gt;&lt;/Appl&gt;WebKit/537.36 (KHTML, like Gecko) Chrome/43.0.235' &#125; timeout = random.choice(range(80, 180)) url = \"https://interface.meiriyiwen.com/article/random?dev=1\" r = requests.get(url, headers= header, timeout=timeout) jsonarr = json.loads(r.text) result = jsonarr[\"data\"] form = '来自：' + str(result['author']) + '的《' + str(result['title']) + '》\\n' content = str(result['content']) msg.sender.send(form + content) elif '历史上的今天' in msg.text: header = &#123; 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.8', 'Connection': 'keep-alive', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.235' &#125; timeout = random.choice(range(80, 180)) m = datetime.datetime.now().month d = datetime.datetime.now().day url = \"http://api.juheapi.com/japi/toh?v=1.0&amp;month=\"+str(m)+\"&amp;day=\"+str(d)+\"&amp;key=换成自己的key\" r = requests.get(url, headers= header, timeout=timeout) jsonarr = json.loads(r.text) result = jsonarr[\"result\"] form = '历史上的【' + str(m) +'-'+ str(d)+ '】发生了以下事件：' + '\\n' + '\\n' item = [] for i in result: item.append(i['des']) item = '\\n'+ '\\n'.join(item) msg.sender.send(form + item) elif '白羊座' in msg.text: star = get_star('白羊座') msg.sender.send(star) elif '金牛座' in msg.text: star = get_star('金牛座') msg.sender.send(star) elif '双子座' in msg.text: star = get_star('双子座') msg.sender.send(star) elif '巨蟹座' in msg.text: star = get_star('巨蟹座') msg.sender.send(star) elif '狮子座' in msg.text: star = get_star('狮子座') msg.sender.send(star) elif '处女座' in msg.text: star = get_star('处女座') msg.sender.send(star) elif '天秤座' in msg.text: star = get_star('天秤座') msg.sender.send(star) elif '天蝎座' in msg.text: star = get_star('天蝎座') msg.sender.send(star) elif '射手座' in msg.text: star = get_star('射手座') msg.sender.send(star) elif '摩羯座' in msg.text: star = get_star('摩羯座') msg.sender.send(star) elif '水瓶座' in msg.text: star = get_star('水瓶座') msg.sender.send(star) elif '双鱼座' in msg.text: star = get_star('双鱼座') msg.sender.send(star) elif '开启机器人' in msg.text: msg.sender.send('哎呀，人家还不能这样呢') elif '关闭机器人' in msg.text: msg.sender.send('哎呀，人家还不能这样呢') elif '加群' in msg.text.lower(): print('1') group = bot.groups().search('cc') group[0].add_members(msg.sender, use_invitation=True) else: tuling.do_reply(msg) msg.sender.send(msg.location)while True: schedule.run_pending() time.sleep(1) 喜欢的可以加微信【wex_5201314】验证信息【py】拉你进群体验或者关注公众号 【故事胶片】 发送 【wxpy】获取源码或者直接扫描二维码 WeChat Image_20181221112044.jpg","tags":[{"name":"Python","slug":"Python","permalink":"https://jiaopianjun.cc/tags/Python/"},{"name":"微信机器人","slug":"微信机器人","permalink":"https://jiaopianjun.cc/tags/微信机器人/"}]},{"title":"页面的重绘（repaint）与回流（reflow）","date":"2018-12-12T06:24:00.000Z","path":"2018/12/12/页面得重绘与回流.html","text":"1. 回流(reflow)当dom中render树中的节点或者元素的大小，边距，数量发生变化后，导致页面需要重新构建的过程叫做回流。另外如果浏览器获取某些元素属性也会触发回流，例如：offsetTop,offsetLeft等。 2. 重绘(repaint)当dom中元素的属性，例如：颜色，字体样式等发生变化时，只需要更改该元素的时候叫做重绘。 3.回流的成本高于重绘4.回流一定重绘，重绘不一定会回流5.如何优化1.避免单个修改节点样式，尽量一次性修改 2.使用DocumentFragment将需要多次修改的DOM元素缓存，修改好后一次性替换 3.将需要多次修改的DOM元素设置成display:none,修改完成后在改回来。 4.避免读取上述的那些属性 5.将复杂的dom节点脱离文档流。","tags":[{"name":"重绘","slug":"重绘","permalink":"https://jiaopianjun.cc/tags/重绘/"},{"name":"回流","slug":"回流","permalink":"https://jiaopianjun.cc/tags/回流/"}]},{"title":"map,filter,forEach的区别和用法","date":"2018-12-03T08:52:00.000Z","path":"2018/12/03/map-filter-forEach的区别和用法.html","text":"map map() 方法创建一个新数组，其结果是该数组都执行一次函数，原函数保持不变。 12345var a = [1,2,3,5,4,8,6,3,2]var newa = a.map(x =&gt;&#123; return x + 1&#125;)newa // [2,3,4,5,9,7,4,3] 对新数组进行加1赋值 forEach forEach() 方法对数组的每一个元素执行一次提供的函数。 12345var a = [1,2,3,5,4,8,6,3,2]var newa = a.forEach((item,index)=&gt;&#123; return item +1&#125;)//遍历所有值 filter filter() 方法使指定函数测试数组的每一个元素，并返回一个通过元素的新数组。 12345var a = [1,2,3,5,4,8,6,3,2]var newa = a.filter(x=&gt;&#123; return x &gt; 1&#125;)newa // [2,3,5,4,8,6,3,2] 用于过滤大于1 的 some some() 方法测试该数组只要有元素通过了指定函数的测试，如果有返回true，否则，返回false。 12345var a = [1,5,2,4,5,8,6,10]var newa = a.some(x=&gt;&#123; return x &gt; 10&#125;)true // 判断a中是否有大于10 的值有则true 无则 false every every() 方法测试该数组是否全部通过指定函数测试，全部通过返回true，否则，返回false 12345var a = [1,5,2,4,5,8,6,10]var newa = a.every(x=&gt;&#123; return x &gt; 10&#125;)false // 判断a中是否都大于10 的值是则true 无则 false reduce reduce() 接受一个函数作为累加器，依次加上数组的当前元素。12345var a = [1,5,2,4,5,8,6,10]var newa = a.reduce((x,i)=&gt;&#123; return x + i&#125;)41 //累加数组中的值","tags":[{"name":"数组","slug":"数组","permalink":"https://jiaopianjun.cc/tags/数组/"}]},{"title":"JQ获取图片的实际尺寸","date":"2018-11-30T06:23:00.000Z","path":"2018/11/30/JQ获取图片的实际尺寸.html","text":"在实际情况中我们设置了图片大小，比如我们设置了 400 * 300 但实际的图片大小是 1300 * 1000 那我们怎么获取这个实际的大小呢。 123在原生js 中可以通过 nWidth = document.getElementById('example').naturalWidth,nHeight = document.getElementById('example').naturalHeight; 在JQ 中可以通过封装natural来实现 1234567891011121314151617181920212223 (function($)&#123; var props = ['Width', 'Height'], prop; while (prop = props.pop()) &#123; (function (natural, prop) &#123; $.fn[natural] = (natural in new Image()) ? function () &#123; return this[0][natural]; &#125; : function () &#123; var node = this[0], img, value; if (node.tagName.toLowerCase() === 'img') &#123; img = new Image(); img.src = node.src, value = img[prop]; &#125; return value; &#125;; &#125;('natural' + prop, prop.toLowerCase())); &#125;&#125;(jQuery)); 使用方法：12$(\"#a\").naturalWidth();$(\"#a\").naturalHeight();","tags":[{"name":"javascript","slug":"javascript","permalink":"https://jiaopianjun.cc/tags/javascript/"}]},{"title":"CSS 日常踩坑----- transform 导致文本、图片模糊","date":"2018-11-22T03:00:00.000Z","path":"2018/11/22/CSS-日常踩坑-transform-导致文本、图片模糊.html","text":"问题：通过transform:translate3D 设置图片位移动画的时候，发现文本变模糊，但是同样方法的另一个却没有通过百度过后，发现这是因为transform时div的宽度或者高度并不是偶数，移动50%之后，像素点并不是整数，出了小数，和显示像素没有对上导致模糊解决办法：将元素设置为偶数可以解决","tags":[{"name":"css","slug":"css","permalink":"https://jiaopianjun.cc/tags/css/"}]},{"title":"CSS Content 属性 新发现","date":"2018-11-07T08:23:00.000Z","path":"2018/11/07/CSS-Content-新发现.html","text":"content 属性 none normal inherit string url() attr() [no-]open-quote [no-]close-quote counter[s] url() 和 background:url()类似，但是不能控制图片的大小 ```12``` 2. attr() 用于获取元素上自定义属性 如 data-text content:attr(data-text) 12345673. quote 引号用于给元素前后加上引号，配合quotes 属性一起使用。 示例：&lt;p&gt;鲁迅曾经说过: &lt;span&gt;能用CSS解决的问题就不要使用JS。&lt;span&gt;呵呵，谁说的？&lt;span class=\"no-quote\"&gt;呵呵，谁说的？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; span &#123;quotes: '“' '”' '‘' '’' '\"' '\"';&#125; span:before &#123;content: open-quote;&#125; span:after &#123;content: close-quote;&#125; .no-quote:after&#123;content: no-close-quote;&#125;结果： 微信截图_20181123154518.png 3.counter[s] · 计数器 counter-reset用来标识计数器的作用域，值包括两部分：第一部分为计数器的名字；第二部分为计数器的起始值，默认为0。此外，COUNTER-RESET还可以同时声明多个计数器 123counter-reset: n 0counter-reset: n 2 counter-reset: n 0 m 0 p 0 counter-increment用来表明计数器实际用到的范围，值包括两部分：第一部分为计数器的名字；第二部分为计数器的递增的值，默认为1。如： 12counter-increment: n 2counter-increment: n -1 /*递减*/ counter()counter方法可以接收两个参数。第一个是计数器的名字，必填；第二个是计数器的样式，也就是list-style-type，其支持的关键字值，就是list-style-type支持的那些值，比如disc | circle | square之类等等。 12content: counter(n)content: counter(m, circle) counters()counters方法主要用于嵌套计数，可以接收三个参数。第一个是计数器的名字，必填；第二个是字符串，用于嵌套计数的分隔符，如1.1中的“.”；第三个参数是计数器的样式，与counter一样。其中，前两个参数为必填 1content: counters(n, '-');","tags":[{"name":"css","slug":"css","permalink":"https://jiaopianjun.cc/tags/css/"}]},{"title":"Git相关操作及术语（转载）","date":"2018-11-01T07:59:00.000Z","path":"2018/11/01/Git相关操作及术语（转载）.html","text":"1540787997345.jpg Git 相关术语1234工作区（Working Directory）暂存区（Stage/Index）本地历史仓库（Repository）远程仓库（Remote） 1540793441688.jpg 工作区1我们写代码的地方就是工作区，就是在电脑里能看到的目录，我们当前的工作空间 暂存区12暂存区（stage）就是每次 git add 时，文件的修改存放的地方。git commit 时就是一次性把暂存区所有修改提交到分支。 1540792175843.jpg 本地仓库12我们可以把暂存区的内容提交到我们的本地仓库，又名版本库（respository），可将其理解成一个目录，该目录下的所有文件都会被 git 管理起来，每个文件的修改、删除、git 都能跟踪，以便随时追踪历史，和还原。.git 隐藏目录就是 git 的版本库，里面存了很多东西，最重要的就是 stage（index） 暂存区，还有第一个分支 master，以及指向 master 的 HEAD 指针。 远程仓库12远程仓库其实就是找一台电脑充当服务器的角色，每天 24 小时开机，其他每个人都从这个远程仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。比如，GitHub、Gitlab 等都属于远程仓库。 举一个形象化的例子来帮助大家理解上面几个概念：1234567比如我们在逛着某宝：1、看到了心仪的物品，我们可以把商品添加到购物车（暂存区），我们可能会频繁的添加商品（add）或者移除商品（checkout），在这个过程中我们可以随便嗨，反正还没给钱；2、接着我们挑的七七八八了，接着我们就要提交我们的订单了，点击提交订单（commit），接着会生成一个商品的订单列表（快照），我们还可以在提交的时候添加点备注信息，比如要什么颜色（commit -m \"颜色\"），好的，此时订单提交了，但是我们还没支付（Push），我们可以在自己的账户未支付订单列表（本地仓库）中找到我们的这个订单订单（快照），也可以看到自己以前的一些订单记录；3、再接着我们选择这个还没付款的订单，进行支付（Push），付款完成后，商家（远程仓库）就会收到这个订单，然后发货... 其他一些重要概念1234567891011121314HEADHEAD 就是当前活跃分支的游标，你现在在哪儿，HEAD 就指向哪儿。HEAD 是一个指针，总是指向当前分支。仓库版本的回退和追踪都是通过操作 HEAD 指针来完成。不过 HEAD 并非只能指向分支的最顶端（时间节点距今最近的那个），实际上它可以指向任何一个节点，它就是 Git 内部用来追踪当前位置的东东。标签有了 commit id 为什么还要tag？因为 commit id 不好找，tag 是有意义的名字，它与 commit 绑在一起。其他要点1、每一次 git commit，都会生成一个 commit id 记录该次提交，Git 都会将它们串成一条时间线，这条时间线就是一个分支。2、因为创建、合并、删除分支都很快，所以 git 鼓励你使用分支完成某个任务，合并后再删除分支。过程比直接在 master 分支工作更安全，且效果一样。3、分支策略：master 分支应该是非常稳定的，仅用来发布新版本，平时不能在上面干活，干活都在 dev 分支，dev 是不稳定的，到 1.0 发布时，再将 dev 合并到 master 上，由 master 发布新版本。 Git 常用命令1. 创建一个新的仓库12345678# 在当前目录新建一个 Git 仓库$ git init# 新建一个目录，并将其初始化为 Git 仓库$ git init [project-name]# 从远程下载一个仓库$ git clone [url] 2. 配置123456789101112Git 的配置文件是 .gitconfig，可以放在用户的主目录（全局配置）下或项目目录下（项目配置）。# 显示当前的 Git 配置$ git config --list# 编辑 Git 配置$ git config -e [--global]# 设置用来提交代码的用户信息$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\" 3. 添加/删除文件12345678910111213141516171819202122# 将指定文件添加到暂存区中$ git add [file1] [file2] ...# 将指定目录添加到暂存区中，包括子目录$ git add [dir]# 将当前目录中的所有文件添加到暂存区中$ git add .# 在添加每个更改之前都进行确认# 对于同一个文件的多个更改，建议分开提交$ git add -p# 将指定文件从工作区删除，并将本次删除添加到暂存区$ git rm [file1] [file2] ...# 停止追踪指定的文件，不会删除文件$ git rm --cached [file]# 对指定文件进行重命名，并添加到暂存区中$ git mv [file-original] [file-renamed] 4. 代码提交相关12345678910111213141516171819# 将暂存区中的文件提交到代码仓库$ git commit -m [message]# 将指定的文件从暂存区中提交到仓库$ git commit [file1] [file2] ... -m [message]# 将工作区的更改直接提交到仓库$ git commit -a# 提交前展示所有的变动$ git commit -v# 使用新提交代替上次提交# 如果代码没有任何变动，将会用于重写上次提交的提交信息$ git commit --amend -m [message]# 重做上次的提交，并将指定的文件包含其中$ git commit --amend [file1] [file2] ... 5. 分支相关12345678910111213141516171819202122232425262728293031323334353637383940414243# 列出本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出本地和远程的所有分支$ git branch -a# 新建分支，并留在当前分支$ git branch [branch-name]# 新建分支，并切换到新分支$ git checkout -b [branch]# 指向某次提交新建分支$ git branch [branch] [commit]# 创建一个新分支，并与指定的远程分支建立跟踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 将本地分支与指定的远程分支建立跟踪关系$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支与当前分支$ git merge [branch]# 将指定的提交合并到本地分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 6. 标签操作123456789101112131415161718192021222324252627# 列出所有标签$ git tag# 在当前提交上创建一个新标签$ git tag [tag]# 在指定提交上创建一个新标签$ git tag [tag] [commit]# 删除本地标签$ git tag -d [tag]# 删除远程标签$ git push origin :refs/tags/[tagName]# 查看标签信息$ git show [tag]# 提交指定标签$ git push [remote] [tag]# 提交所有标签$ git push [remote] --tags# 创建一个新分支，指向特定的标签$ git checkout -b [branch] [tag] 7.查看信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 显示有变动的文件$ git status# 显示当前分支的提交历史$ git log# 显示提交历史和每次提交的文件$ git log --stat# 指定关键字搜索提交历史$ git log -S [keyword]# 显示自某次提交以来的所有更改，一次提交显示一行。$ git log [tag] HEAD --pretty=format:%s# 显示自某次提交以来的所有更改，其提交描述必须符合搜索条件。$ git log [tag] HEAD --grep feature# 显示指定文件的提交历史$ git log --follow [file]$ git whatchanged [file]# 显示与指定文件相关的每个差异$ git log -p [file]# 显示最近 5 次提交$ git log -5 --pretty --oneline# 显示所有的提交用户，已提交数目多少排名$ git shortlog -sn# 显示指定文件何时被何人修改过$ git blame [file]# 显示暂存区和工作区的文件差别$ git diff# 显示暂存区和上一次提交的差别$ git diff --cached [file]# 显示工作区和当前分支的最近一次提交的差别$ git diff HEAD# 显示指定两次提交的差别$ git diff [first-branch]...[second-branch]# 显示今天提交了多少代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"# 显示特定提交的提交信息和更改的内容$ git show [commit]# 新手某次提交改动了哪些文件$ git show --name-only [commit]# 显示某个提交的特定文件的内容$ git show [commit]:[filename]# 显示当前分支的最新提交$ git reflog 8. 远程同步123456789101112131415161718192021222324# 从远程分支下载所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程参考的信息$ git remote show [remote]# 新建一个远程仓库，并命名$ git remote add [shortname] [url]# 检索远程存储库的更改，并与本地分支合并$ git pull [remote] [branch]# 将本地分支提交到远程仓库$ git push [remote] [branch]# 将当前分支强制提交到远程仓库，即使有冲突存在$ git push [remote] --force# 将所有分支提交到远程仓库$ git push [remote] --all 9. 撤销操作12345678910111213141516171819202122232425262728293031# 将暂存区中的指定文件还原到工作区，保留文件变动$ git checkout [file]# 将指定文件从某个提交还原到暂存区和工作区$ git checkout [commit] [file]# 将暂存区中的所有文件还原到工作区$ git checkout .# 重置暂存区中的指定文件，与先前的提交保持一致，但保持工作空间的变动不变$ git reset [file]# 重置暂存区和工作区中的指定文件，并与最近一次提交保持一致，工作空间文件变动不会保留$ git reset --hard# 重置暂存区，指向指定的某次提交，工作区的内容不会被覆盖$ git reset [commit]# 重置暂存区和工作区中的指定文件，并与指定的某次提交保持一致，工作区的内容会被覆盖$ git reset --hard [commit]# 将 HEAD 重置为指定的某次提交，保持暂存区和工作区的内容不变$ git reset --keep [commit]# 新建新提交以撤消指定的提交# All changes of the latter will be offset by the former and applied to the current branch.$ git revert [commit]# 暂存为提交的变动，并在稍后移动它们$ git stash$ git stash pop 10. 其他12# 生成用于发布的存档$ git archive","tags":[{"name":"Git","slug":"Git","permalink":"https://jiaopianjun.cc/tags/Git/"}]},{"title":"js 数组平铺","date":"2018-11-01T07:54:00.000Z","path":"2018/11/01/js-数组平铺.html","text":"例如：1234var arr = [1,[3,4],[5,6,7]]1. arr.flat() // [1,3,4,5,6,7]2. arr = [].concat(...arr);","tags":[{"name":"数组操作","slug":"数组操作","permalink":"https://jiaopianjun.cc/tags/数组操作/"}]},{"title":"火狐 window.event无效问题","date":"2018-11-01T06:48:00.000Z","path":"2018/11/01/火狐-window-event无效问题.html","text":"火狐下 window.event 获取值为 undefind 的解决办法 1234function window(event)&#123; var e = event || window.event; e.target.ctrlKey&#125;","tags":[{"name":"兼容性","slug":"兼容性","permalink":"https://jiaopianjun.cc/tags/兼容性/"}]},{"title":"history对象和HTML5 History API","date":"2018-10-23T09:32:00.000Z","path":"2018/10/23/history对象和HTML5-History-API.html","text":"history对象和HTML5 History API123456history.back() // 返回上一个访问的页面，等同于浏览器的返回按钮history.forward() // 移动到下一个访问页面，等同于浏览器的前进按钮history.go() // 参数为一个整数history.go(-1) // 等同于 history.back()history.go(1) // 等同于 history.forward()history.go(0) // 等同于刷新当前页面 增加的属性121、History.state() 返回一个表示历史堆栈顶部的状态的值，只是一种可以不必等待 popstate事件查看状态的方式。2、History.scrollRestortion()：允许Web应用程序在历史导航上显示地设置默认滚动恢复行为。此属性可以是自动的（auto），或者手动的（manual） 增加的方法1、History.pushState()：按指定的名称和URL(如果提供该参数)，将数据push进会话历史栈，数据被DOM进行不透明处理，你可以指定任何可以被序列化的js对象。1234567pushState() 需要三个参数:1、一个状态对象,2、一个标题 (目前被忽略), 、3、一个URL(可选的) 必须和当前页面同源,为空则为当前页面url.另外如果是相对地址则是相对于当前url处理。例子： var stateObj = &#123; foo: \"bar\" &#125;; history.pushState(stateObj, \"page 2\", \"bar.html\"); 2、History.replaceState()：按指定的数据，名称和URL(如果提供该参数)，更新历史栈上最新的入口。这个数据被DOM进行了不透明处理。你可以指定任何可以被序列化的js对象。1231、history.replaceState()的使用与 history.pushState() 非常相似，区别在于 replaceState() 是修改了当前的历史记录项而不是新建一个。 注意这并不会阻止其在全局浏览器历史记录中创建一个新的历史记录项。2、replaceState() 的使用场景在于为了响应用户操作，你想要更新状态对象state或者当前历史记录的URL。3、history.replaceState(stateObj, \"page 3\", \"bar2.html\");","tags":[{"name":"history","slug":"history","permalink":"https://jiaopianjun.cc/tags/history/"}]},{"title":"前端跨域方法总结","date":"2018-10-23T08:01:00.000Z","path":"2018/10/23/前端跨域方法总结.html","text":"为什么需要跨域浏览器处于安全的考虑，引入了同源策略。这种策略会对我们页面上执行的js访问资源时进行限制。比如： 不能通过js访问不同源之下页面的DOM结构， 对不同源发送请求也无法获得服务器的相应。 也不能访问不属于同源下的cookie，localstorage等 何为 同源 ：指的是访问的目标url和当前页面的url两者的协议，端口，域名，ip只要有一个不同，则属于不同的源。 常用的跨域方法1、CORS 跨域资源共享。通过设置请求方法的请求头，来实现跨域 123Access-Control-Allow-OriginAccess-Control-Allow-Methods：对客户端回应服务器支持的请求方法列表；Access-Control-Allow-Headers：对客户端回应服务器支持的Header； 2、JSONP 但是只能用于get请求 3、Cookie跨域共享 123451.配置服务端返回的 Set-Cookie响应头2.在页面上的JavaScript代码中通过document.cookie，直接设置document.cookie为我们需要存储的内容。例如：document.cookie=\"name=Jack;path=/\"document.cookie=\"age=25;path=/\" // cookie中会同时保存name和age这两个字段 跨页面通信1、document.domian 121、两个页面所在的源是一样的，可以直接通信，但是如果两个页面所在的域名相同，但是端口不同或者其他情况，那么两个页面仍需要设置相同的document.domain,否则还是会被浏览器block掉2、需要在前入的iframe加载完成之后才能和其加载的子页面进行通信，否则拿到的值可能还是undefined 2、window对象name属性 1浏览器具有这样一个特性：同一个标签页或者同一个iframe框架加载过的页面共享相同的window.name属性值，意味着只要是在同一个标签页里面打开过的页面（不管是否同源），这些页面上的window.name属性值都是相同的。利用这一特性在不同页面作为传递数据的介质 3、HTML5 cross-document message 1html5中引入了另外一种跨页面通信的方式：跨文档消息传送。同样可以实现主页面和嵌入的iframe子页面（或者由当前页面打开的页面）之间完成数据的传递，另外这种方法也可以用于当前JavaScript引擎线程和其他worker线程之间完成数据交换。如果是与iframe加载的子页面进行通信，则需要先获取到接收数据的目标页面的window对象，通过该对象的postMessage方法可以向目标页面发送数据。 4、locakStorage 1localStorage是HTML5引入的客户端存储方案，通过localStorage存储的内容会一直保存在客户端，除非调用removeItem方法显式移除，否则内容将永久保留。 其他跨域问题1、跨域脚本错误处理 对于页面上加载的跨域脚本执行出错，页面上绑定的错误处理函数window.onerror在默认情况下是获取不到具体的错误信息的，这时候需要在加载跨域脚本的标签上使用crossorigin属性，也就是在请求跨域脚本的时候执行CORS。crossorigin属性可以设置的值有： 12anonymous：请求脚本的时候不会携带凭据use-credentials：请求脚本的时候携带凭据 设置为其他值都会被看作是anonymous关键字。设置了crossorigin属性意味着还需要对服务器进行配置，使其支持CORS。如果服务端没有正确配置CORS，跨域脚本是无法正常下载的。","tags":[{"name":"跨域","slug":"跨域","permalink":"https://jiaopianjun.cc/tags/跨域/"}]},{"title":"js中的各种width，height","date":"2018-10-10T06:28:00.000Z","path":"2018/10/10/js中的各种width和height.html","text":"默认系列12345678910offsetWidth //返回元素的宽度（包括元素宽度、内边距和边框，不包括外边距）offsetHeight //返回元素的高度（包括元素高度、内边距和边框，不包括外边距）clientWidth //返回元素的宽度（包括元素宽度、内边距，不包括边框和外边距）clientHeight //返回元素的高度（包括元素高度、内边距，不包括边框和外边距）style.width //返回元素的宽度（包括元素宽度，不包括内边距、边框和外边距）style.height //返回元素的高度（包括元素高度，不包括内边距、边框和外边距）scrollWidth //返回元素的宽度（包括元素宽度、内边距和溢出尺寸，不包括边框和外边距），无溢出的情况，与clientWidth相同scrollHeigh //返回元素的高度（包括元素高度、内边距和溢出尺寸，不包括边框和外边距），无溢出的情况，与clientHeight相同 垂直滚动12345678offsetTop// 返回元素的上外缘距离最近采用定位父元素内壁的距离，如果父元素中没有采用定位的，则是获取上外边缘距离文档内壁的距离。所谓的定位就是position属性值为relative、absolute或者fixed。返回值是一个整数，单位是像素。此属性是只读的。offsetLeft//此属性和offsetTop的原理是一样的，只不过方位不同，这里就不多介绍了。scrollLeft//此属性可以获取或者设置对象的最左边到对象在当前窗口显示的范围内的左边的距离，也就是元素被滚动条向左拉动的距离。返回值是一个整数，单位是像素。此属性是可读写的。scrollTop//此属性可以获取或者设置对象的最顶部到对象在当前窗口显示的范围内的顶边的距离，也就是元素滚动条被向下拉动的距离。返回值是一个整数，单位是像素。此属性是可读写的。 当鼠标事件发生时（不管是onclick，还是omousemove，onmouseover等）12345678clientX 鼠标相对于浏览器（这里说的是浏览器的有效区域）左上角x轴的坐标；不随滚动条滚动而改变；clientY 鼠标相对于浏览器（这里说的是浏览器的有效区域）左上角y轴的坐标；不随滚动条滚动而改变；pageX 鼠标相对于浏览器（这里说的是浏览器的有效区域）左上角x轴的坐标；随滚动条滚动而改变；pageY 鼠标相对于浏览器（这里说的是浏览器的有效区域）左上角y轴的坐标；随滚动条滚动而改变；screenX 鼠标相对于显示器屏幕左上角x轴的坐标；screenY 鼠标相对于显示器屏幕左上角y轴的坐标；offsetX 鼠标相对于事件源左上角X轴的坐标offsetY 鼠标相对于事件源左上角Y轴的坐标","tags":[{"name":"javascript","slug":"javascript","permalink":"https://jiaopianjun.cc/tags/javascript/"}]},{"title":"Vuepress 发布流程","date":"2018-10-08T03:16:00.000Z","path":"2018/10/08/Vuepress-发布流程.html","text":"好记性不如烂笔头12345671. 在docs文件夹 执行 vuepress build2. 进入 docs/.vuepress/dist 3. 如果绑定域名 则执行 echo ‘note.rooon.co’ &gt; CNAME4. git init5. git add -A6. git commit -m 'update'7. git push -f git@github.com:rooon/note.git master:gh-pages","tags":[{"name":"vuepress","slug":"vuepress","permalink":"https://jiaopianjun.cc/tags/vuepress/"}]},{"title":"Url参数获取和更改","date":"2018-09-27T08:31:00.000Z","path":"2018/09/27/获取和更改Url参数.html","text":"获取多个url参数123456789getUrlParam:function (name)&#123; var reg = new RegExp(\"(^|&amp;)\"+ name +\"=([^&amp;]*)(&amp;|$)\"); var r = window.location.search.substr(1).match(reg); if(r!=null) return unescape(r[2]); return null;&#125;``` ##### 获取单个url参数 getUrlParam:function (name){ var params = location.search.substr(1); var ArrParam = params.split(‘&amp;’); for(var i = 0; i &lt;ArrParam.length; i ++){ if(ArrParam[i].split(‘=’)[0] == name){ return ArrParam[i].split(‘=’)[1]; } }}1##### 修改url地址 changeURLPar:function(url,arg,arg_val){ var pattern=arg+’=([^&amp;])’; var replaceText=arg+’=’+arg_val; if(url.match(pattern)){ var tmp=’/(‘+ arg+’=)([^&amp;])/gi’; tmp=url.replace(eval(tmp),replaceText); return tmp; }else{ if(url.match(‘[\\?]’)){ return url+’&amp;’+replaceText; }else{ return url+’?’+replaceText; } } return url+’\\n’+arg+’\\n’+arg_val;}//用法var txt = window.location.hrefchangeURLPar(txt, ‘type’, 99)`","tags":[{"name":"javascript","slug":"javascript","permalink":"https://jiaopianjun.cc/tags/javascript/"},{"name":"URL参数","slug":"URL参数","permalink":"https://jiaopianjun.cc/tags/URL参数/"}]},{"title":"Css filter 介绍","date":"2018-09-26T01:53:00.000Z","path":"2018/09/26/Css-filter-介绍.html","text":"Css Fileter参数：12345678910111213141516171819blur(10px) 高斯模糊（px） 越大越模糊brightness(1%) 线性乘法 提高亮度或变暗 越小越黑contrast(1%) 对比度 越小越黑 越大越亮drop-shadow(1px 1px 10px 20px) 类似于box-shadowgrayscale(1%) 灰度图像 越大越灰hue-rotate(1deg) 色相旋转 0-360invert(1%) 反转输入图像 0-100opacity(1%) 设置透明度saturate(1%) 设置图像饱和度 越大饱和度越高sepia(1%) 图像转换未深褐色， 0-100 越大颜色越深","tags":[{"name":"css","slug":"css","permalink":"https://jiaopianjun.cc/tags/css/"}]},{"title":"H5移动端 rem 设置","date":"2018-09-21T08:22:00.000Z","path":"2018/09/21/H5移动端-rem-设置.html","text":"H5移动端如果使用rem进行布局，通过js 动态设置rem12345678910111213141516&lt;script type=\"text/javascript\"&gt; //为页面html动态设置font-size值 (function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = clientWidth / 7.5 + 'px'; //等价于clientWidth / 750 * 100 + 'px'; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false);//resize doc.addEventListener('DOMContentLoaded', recalc, false);//reload &#125;)(document, window);&lt;/script&gt;","tags":[{"name":"移动端","slug":"移动端","permalink":"https://jiaopianjun.cc/tags/移动端/"}]},{"title":"移动端常见布局方式","date":"2018-09-21T08:21:00.000Z","path":"2018/09/21/移动端常见布局方式.html","text":"1. 媒体查询方法1采用 media (max-width:600px)&#123;&#125;进行响应式开发 2.viewport定死宽度的方法1&lt;meta name=\"viewport\" content=\"width=750,target-densitydpi=high-dpi,minimum-scale=1.0,maximum-scale=2.0,user-scalable=0\"&gt; 3.Rem设置121.通过js设置html的font-size然后来计算2.通过media设置font-size计算 4.通过第三方库，如淘宝的flex布局或者","tags":[{"name":"移动端","slug":"移动端","permalink":"https://jiaopianjun.cc/tags/移动端/"}]},{"title":"jquery判断手机浏览器版本","date":"2018-09-21T08:20:00.000Z","path":"2018/09/21/jquery判断手机浏览器版本.html","text":"判断当前设备是移动端还是PC端，以作不同操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344function brower()&#123; var browser = getBrowserInfo() ; //alert(browser); var verinfo = (browser+\"\").replace(/[^0-9.]/ig,\"\"); if (verinfo=='7.0' || verinfo=='8.0' || verinfo=='6.0') &#123; alert(\"温馨提示：为了您的浏览体验请使用IE9及以上版本。如果您使用的是360浏览器或QQ浏览器等，请点击地址栏尾端的IE图标切换至【极速模式】\"); &#125;&#125;function getBrowserInfo()&#123; var agent = navigator.userAgent.toLowerCase() ; var regStr_ie = /msie [\\d.]+;/gi ; var regStr_ff = /firefox\\/[\\d.]+/gi var regStr_chrome = /chrome\\/[\\d.]+/gi ; var regStr_saf = /safari\\/[\\d.]+/gi ; //IE if(agent.indexOf(\"msie\") &gt; 0)&#123;return agent.match(regStr_ie) ;&#125; //firefox if(agent.indexOf(\"firefox\") &gt; 0)&#123;return agent.match(regStr_ff) ;&#125; //Chrome if(agent.indexOf(\"chrome\") &gt; 0)&#123;return agent.match(regStr_chrome) ;&#125; //Safari if(agent.indexOf(\"safari\") &gt; 0 &amp;&amp; agent.indexOf(\"chrome\") &lt; 0)&#123;return agent.match(regStr_saf) ;&#125;&#125;//手机端|电脑端function browserRedirect() &#123; var sUserAgent= navigator.userAgent.toLowerCase(); var bIsIpad= sUserAgent.match(/ipad/i) == \"ipad\"; var bIsIphoneOs= sUserAgent.match(/iphone os/i) == \"iphone os\"; var bIsMidp= sUserAgent.match(/midp/i) == \"midp\"; var bIsUc7= sUserAgent.match(/rv:1.2.3.4/i) == \"rv:1.2.3.4\"; var bIsUc= sUserAgent.match(/ucweb/i) == \"ucweb\"; var bIsAndroid= sUserAgent.match(/android/i) == \"android\"; var bIsCE= sUserAgent.match(/windows ce/i) == \"windows ce\"; var bIsWM= sUserAgent.match(/windows mobile/i) == \"windows mobile\"; if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) &#123; document.getElementById(\"a\").style.display=\"block\"; document.getElementById(\"b\").style.display=\"none\"; &#125; else &#123; document.getElementById(\"b\").style.display=\"block\"; document.getElementById(\"a\").style.display=\"none\"; &#125; &#125; window.onload=function()&#123;browserRedirect();&#125; 123456789101112131415161718192021222324var browser = &#123; versions: function () &#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123;//移动终端浏览器版本信息 trident: u.indexOf('Trident') &gt; -1, //IE内核 presto: u.indexOf('Presto') &gt; -1, //opera内核 webKit: u.indexOf('AppleWebKit') &gt; -1, //苹果、谷歌内核 gecko: u.indexOf('Gecko') &gt; -1 &amp;&amp; u.indexOf('KHTML') == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/) || !!u.match(/AppleWebKit/), //是否为移动终端 ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, //android终端或者uc浏览器 iPhone: u.indexOf('iPhone') &gt; -1 || u.indexOf('Mac') &gt; -1, //是否为iPhone或者QQHD浏览器 iPad: u.indexOf('iPad') &gt; -1, //是否iPad webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部 &#125;; &#125;(), language: (navigator.browserLanguage || navigator.language).toLowerCase() &#125; //document.writeln(\"语言版本: \"+browser.language);//document.writeln(\" 是否为移动终端: \"+browser.versions.mobile);//document.writeln(\" ios终端: \"+browser.versions.ios);//document.writeln(\" android终端: \"+browser.versions.android);//document.writeln(\" 是否为iPhone: \"+browser.versions.iPhone);//document.writeln(\" 是否iPad: \"+browser.versions.iPad);//document.writeln(navigator.userAgent);","tags":[{"name":"移动端","slug":"移动端","permalink":"https://jiaopianjun.cc/tags/移动端/"}]},{"title":"近期待解决技术点","date":"2018-09-12T09:18:00.000Z","path":"2018/09/12/近期待解决技术点.html","text":"js语言特性问题 原型链、作用域、继承 数组的操作，排序 map和forEach的区别 详细链接 object的属性和方法有哪些 vue的响应原理 详细链接 父子组件通信 vue-router的应用 vueX的核心api 小程序 ES6、webpack 状态码、jsonp、跨域 动画性能、前端优化方面","tags":[{"name":"笔记","slug":"笔记","permalink":"https://jiaopianjun.cc/tags/笔记/"},{"name":"复习","slug":"复习","permalink":"https://jiaopianjun.cc/tags/复习/"}]},{"title":"git 如何提交到github","date":"2018-09-06T03:22:00.000Z","path":"2018/09/06/git-如何提交到github.html","text":"好记性不如烂笔头，日常记录才能不会忘记 git 提交到 github流程12345671. git clone xxxx //克隆远程仓库到本地2. git pull //拉取服务器代码3. git status //查看当前目录工作状态4. git add + //将修改过的文件全部提交缓存5. git commit -m \"注释\" //提交到本地仓库6. git remote add origin git@github.com:defnngj/hello-world.git //连接远程仓库7. git push -u origin master //提交到mater 分支 git 其他命令12345678910git push origin master //把本地源码库push到Github上git pull origin master //从Github上pull到本地源码库git config --list //查看配置信息git status //查看项目状态信息git branch //查看项目分支git checkout -b host //添加一个名为host的分支git checkout master //切换到主干git merge host //合并分支host到主干git branch -d host //删除分支hostgit remote -v //查看当前在哪一个远程仓库","tags":[{"name":"git","slug":"git","permalink":"https://jiaopianjun.cc/tags/git/"}]},{"title":"学习文章分享一","date":"2018-09-04T07:53:59.000Z","path":"2018/09/04/学习文章分享一.html","text":"2018年 JSON.parse 三种实现方式 前端之问，程序员之问，职业之问 浏览器缓存、CacheStorage、Web Worker 与 Service Worker Vue SSR Demo 2017年 单页面应用路由实现原理：以 React-Router 为例 图解 HTTPS：Charles 捕获 HTTPS 的原理 React 事件代理与 stopImmediatePropagation 最小编辑距离问题：递归与动态规划 preact 源码学习系列之二：组件的渲染与更新 preact 源码学习系列之一：JSX解析与DOM渲染 V8引擎探索：如何注入全局变量 webpack源码学习系列之三：loader 机制 webpack源码学习系列之二：code-splitting（代码切割） webpack源码学习系列之一：如何实现一个简单的webpack 如何实现一个异步模块加载器–以requireJS为例 2016年 Mixin、多重继承与装饰者模式 你不知道的回调、异步与生成器 数组遍历、for…of、Interator接口与迭代器模式 vue源码学习系列之十一：组件化原理探索(父子组件通信) vue源码学习系列之十：组件化原理探索(动态props) vue源码学习系列之九：组件化原理探索(静态props) vue早期源码学习系列之八：如何实现”v-repeat”列表渲染 vue早期源码学习系列之七：如何实现”v-if”条件渲染 vue早期源码学习系列之六：如何实现计算属性 vue早期源码学习系列之五：批处理更新DOM vue早期源码学习系列之四：如何实现动态数据绑定 vue早期源码学习系列之三：如何写一个watch库 vue早期源码学习系列之二：如何监听一个数组的变化 vue早期源码学习系列之一：如何监听一个对象的变化 如何编写一个vue自定义指令 如何开发一个移动web UI组件库：适配篇 如何开发一个移动web UI组件库：vue插件篇 如何开发一个移动web UI组件库：构架篇 Hybrid App中web资源的离线存储与更新机制研究 我为什么要研究Hybrid App 利用hammer.js解决300ms延时 JSBridge实现原理探索：以toast为例 真机远程调试：chrome://inspect thief系列之四：从实现getJSON中探索XHR和promise 浏览器history api的研究 浅谈http报文与请求体格式 Mongodb与Mongoose的学习体会 自己动手写一个GithubStarManager thief系列之三：从实现链式调用中看类数组对象与级联 babel初学者的一些常见误区 如何在redux中捕获处理ajax请求错误 使用react-transition-group引发的this.setState异步问题 webpack打包bundle.js体积大小优化 webpack打包bundle.js依赖分析 thief系列之二：从获取DOM和增删类中看js如何构造一个类 异步回调更优雅的解决方式：async react-css-transition实战 thief系列之一：总序&amp;&amp;从第一行代码开始 将数组转化成自定义hash键的对象 redux使用的反思：状态存储 交互动画系列之三：react动画 交互动画系列之二：赛贝尔曲线 交互动画系列之一：解决bundle.js首次加载动画问题 rap与mock：接口定义与生成平台 try…catch、express与co错误捕获 自己动手写todolist的后端 nodejs redis实战–如何写登录模块 ie兼容性问题记录 ES6 generator 、yield 与co shell.js与yargs命令行开发 与脚手架大战：回合2 与脚手架大战：回合1 自己动手写express中间件 nodejs使用sequelize操作数据库 nodejs使用mysql包操作数据库 Selectivizr：让IE6~IE8支持CSS3高级选择器 终端交互——inquire.js 变量检查校验相关：is.js、validator 、JSVerbalExpressions How to remove “sudo” when npm install -g 一些小技巧的总结 IE8 max-width失效引起的对meta标签的思考 IE8和IE9跨域请求数据兼容性解决方案 jquery.cursor.js:自己编写的光标控制插件 es5-shim和es5-sham Error: Does Not Satisfy Its Siblings’ peerDependencies Requirements 函数自定义属性 浏览器特性检测工具：Modernizr 利用缓存缩短npm install的时间 ie8 chartjs兼容性解决方案 ie8 placeholder兼容性解决方案 ie8 上传文件后提示下载文件 从gulpfile.js的warning联想到软件的腐败 redux组织代码之：分割action css样式融合与类继承 react滚动加载之————react-lazy-load react组件动态处理className scss-lint实战碰到的一些问题以及解决方案 全局css的终结——css module 代码质量之：scss-lint 组件编写规范之：proptypes 2015年 react-router 与 history的版本匹配问题 react-native：寻找像写scss那样写react native 样式的方法 初探react-native踩到的一些坑以及解决方案 在react中使用箭头函数引发的对this的思考 代码质量之：eslint 单元测试之：mocha和chai redux精简代码之–actionType与redux-action-utils redux精简代码之–抽象select函数和mapDispatchToProps函数 react 禁止“事件冒泡” config.js文件引入env字段区分测试和开发环境 gulp-preprocess 让你的项目只需要一个配置文件 利用代码片段偷懒：dash snippets git技巧之 –set-upstream code review 记一次如何找到Object.assign()编译方法的历程 babel配置文件的使用 初探lodash","tags":[{"name":"分享","slug":"分享","permalink":"https://jiaopianjun.cc/tags/分享/"},{"name":"资料","slug":"资料","permalink":"https://jiaopianjun.cc/tags/资料/"}]},{"title":"移动前端开发收藏夹","date":"2018-09-04T07:51:22.000Z","path":"2018/09/04/移动前端开发收藏夹.html","text":"同类项目腾讯移动Web前端知识库 maxzhang博客 issuesQQ浏览器X5内核问题汇总 一些非常重要的工具类网站html5与css3技术应用评估 各种奇妙的hack 几乎所有设备的屏幕尺寸与像素密度表 移动设备参数表 ios端移动设备参数速查 浏览器兼容表 移动设备查询器 移动设备适配库 viewport与设备尺寸在线检测器 html5移动端兼容性速查 在线转换字体 css3选择器测试 兼容性速查表 浏览器的一些独特参数 各种各样的媒体查询收集 css3动画在线制作器 css3渐变在线制作器 移动端手势表 webkit独有的样式分析 响应式测试工具判断 iPad 和 iPhone 的版本和状态的 CSS 媒体查询代码 Viewport Resizer screenqueri responsivepx responsinator resizemybrowser quirktools 一篇webapp开发的最佳实践与中文总结原文 当前 WEB APP 开发的最佳实践 来自maxzhang的一些移动端经验总结干货移动Web单页应用开发实践——页面结构化 移动Web产品前端开发口诀——“快” 移动Web开发，4行代码检测浏览器是否支持position:fixed 使用border-image实现类似iOS7的1px底边 移动端web页面使用position:fixed问题总结 移动Web开发实践——解决position:fixed自适应BUG 移动手机浏览器m3u8格式视频流播放支持程度测试 从meta开始本节之后可能也涉及 meta 标签，但为了更加全面的摸透 meta 特地用一节的篇幅来系统概述。 一、meta 标签分两大部分：HTTP 标题信息（http-equiv）和页面描述信息（name）。1、http-equiv 属性的 Content-Type 值（显示字符集的设定）说明：设定页面使用的字符集，用以说明主页制作所使用的文字语言，浏览器会根据此来调用相应的字符集显示 page 内容。 用法： 1&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; 注意：该 meta 标签定义了 HTML 页面所使用的字符集为 utf-8 ，就是万国码。它可以在同一页面显示中文简体、繁体及其它语言（如日文，韩文）等。 2、name 属性的 viewport 值（移动屏幕的缩放）也就是可视区域。对于桌面浏览器，我们都很清楚 viewport 是什么，就是除去了所有工具栏、状态栏、滚动条等等之后用于看网页的区域，这是真正有效的区域。由于移动设备屏幕宽度不同于传统 web，因此我们需要改变 viewport 值。 实际上我们可以操作的属性有 4 个： width – // viewport 的宽度 （范围从 200 到 10,000，默认为 980 像素） height – // viewport 的高度 （范围从 223 到 10,000 ） initial-scale – // 初始的缩放比例 （范围从 &gt; 0 到 10） minimum-scale – // 允许用户缩放到的最小比例 maximum-scale – // 允许用户缩放到的最大比例 user-scalable – // 用户是否可以手动缩放 (no，yes) 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\" /&gt; 说明： 强制让文档与设备的宽度保持 1:1 ； 文档最大的宽度比列是1.0（ initial-scale 初始刻度值和 maximum-scale 最大刻度值）； user-scalable 定义用户是否可以手动缩放（ no 为不缩放），使页面固定设备上面的大小； 注意：实际测试中发现，有些安卓系统自带的浏览器并不支持这一条规则，能够对页面进行放大，一旦放大响应的 box 也随之放大，导致页面出现错乱问题，解决方法：定义页面的最小宽度 123body &#123; min-width: 320px;&#125; 3、name 属性的 format-detection 值（忽略页面中的数字识别为电话号码）1&lt;meta name=\"format-detection\" content=\"telephone=no\" /&gt; 说明： 使设备浏览网页时对数字不启用电话功能（不同设备解释不同，iTouch 点击数字为存入联系人，iPhone 为拨打电话），忽略将页面中的数字识别为电话号码。 若需要启用电话功能将 telephone=yes 即可，若在页面上面有 Google Maps, iTunes 和 YouTube 的链接会在ios设备上打开相应的程序组件。 4、name 属性的 apple-mobile-web-app-capable 值（网站开启对 web app 程序的支持）1&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt; 说明： 网站开启对 web app 程序的支持。 该 meta 可以看出内容为“苹果设备 web 应用程序 xx”，就是说该 meta 是专门定义 web 应用的。 5、name 属性的 apple-mobile-web-app-status-bar-style 值（改变顶部状态条的颜色）1&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /&gt; 说明： 在 web app 应用下状态条（屏幕顶部条）的颜色； 默认值为 default（白色），可以定为 black（黑色）和 black-translucent（灰色半透明）； 注意：若值为“black-translucent”将会占据页面位置，浮在页面上方（会覆盖页面 20px 高度 iphone4 和 itouch4 的 Retina 屏幕为 40px ）。 6、name 属性设置作者姓名及联系方式1&lt;meta name=\"author\" contect=\"liudanyun, liudy1024@163.com\" /&gt; 二、苹果 Web App 其他设置：当然，配合 Web App 的 icon 和启动界面需要额外的两端代码进行设定，如下所示： 1&lt;link rel=\"apple-touch-icon-precomposed\" href=\"iphone_logo.png\" /&gt; 说明：这个 link 就是设置 Web App 的放置主屏幕上 icon 文件路径。 使用： 该路径需要注意的就是放到将网站的文档根目录下但不是服务器的文档的根目录。 图片尺寸可以设定为 5757（px）或者 Retina 可以定为 114114（px），iPad 尺寸为 72*72（px） 1&lt;link rel=\"apple-touch-startup-image\" href=\"logo_startup.png\" /&gt; 说明：这个 link 就是设置启动时候的界面。 使用： 放置的路径和上面一样。 官方规定启动界面的尺寸必须为 320*640（px），原本以为 Retina 屏幕可以支持双倍，但是不支持，图片显示不出来。 如果对 Web App 的这两个 meta 还有不能详细理解的可以查看官方解释：Meta Tags 关于 link 方面还有更多的参数设置（例如：iPod、iPad、iPhone 不同尺寸不同图标），可以查看官方标准文档：Configuring Web Applications 本资料很多引用了指尖上的js系列，在此向作者表示感谢对于Touch的处理 处理简单手势 处理复杂手势 meta标签，这些meta标签在开发webapp时起到非常重要的作用 1234&lt;meta content=\"width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0\" name=\"viewport\" /&gt;&lt;meta content=\"yes\" name=\"apple-mobile-web-app-capable\" /&gt;&lt;meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\" /&gt;&lt;meta content=\"telephone=no\" name=\"format-detection\" /&gt; 第一个meta标签表示：强制让文档的宽度与设备的宽度保持1:1，并且文档最大的宽度比例是1.0，且不允许用户点击屏幕放大浏览；尤其要注意的是content里多个属性的设置一定要用分号+空格来隔开，如果不规范将不会起作用。 注意根据public_00提供的资料补充，content使用分号作为分隔，在老的浏览器是支持的，但不是规范写法。规范的写法应该是使用逗号分隔，参考:tip1 | tip2 其中： width - viewport的宽度 height - viewport的高度 initial-scale - 初始的缩放比例 minimum-scale - 允许用户缩放到的最小比例 maximum-scale - 允许用户缩放到的最大比例 user-scalable - 用户是否可以手动缩放第二个meta标签是iphone设备中的safari私有meta标签，它表示：允许全屏模式浏览；第三个meta标签也是iphone的私有标签，它指定的iphone中safari顶端的状态条的样式；第四个meta标签表示：告诉设备忽略将页面中的数字识别为电话号码 在设置了initial-scale=1 之后，我们终于可以以1:1 的比例进行页面设计了。关于viewport，还有一个很重要的概念是：iphone 的safari 浏览器完全没有滚动条，而且不是简单的“隐藏滚动条”，是根本没有这个功能。iphone 的safari 浏览器实际上从一开始就完整显示了这个网页，然后用viewport 查看其中的一部分。当你用手指拖动时，其实拖的不是页面，而是viewport。浏览器行为的改变不止是滚动条，交互事件也跟普通桌面不一样。(请参考：指尖的下JS 系列文章) 其中viewport相关的知识也可以参考大漠的文章此像素非彼像素 点击与click事件对于a标记的点击导航，默认是在onclick事件中处理的。而移动客户端对onclick的响应相比PC浏览器有着明显的几百毫秒延迟。 在移动浏览器中对触摸事件的响应顺序应当是： ontouchstart -&gt; ontouchmove -&gt; ontouchend -&gt; onclick 因此，如果确实要加快对点击事件的响应，就应当绑定ontouchend事件。 使用click会出现绑定点击区域闪一下的情况，解决：给该元素一个样式如下 1-webkit-tap-highlight-color: rgba(0,0,0,0); 如果不使用click，也不能简单的用touchstart或touchend替代，需要用touchstart的模拟一个click事件，并且不能发生touchmove事件，或者用zepto中的tap（轻击）事件。 1body&#123;-webkit-overflow-scrolling: touch;&#125; 用iphone或ipad浏览很长的网页滚动时的滑动效果很不错吧？不过如果是一个div，然后设置12345678910我看到很多网站为了实现这一效果，用了第三方类库，最常用的是iscroll（包括新浪手机页，百度等）我一开始也使用，不过自从用了```-webkit-overflow-scrolling: ```touch;样式后，就完全可以抛弃第三方类库了，把它加在```body&#123;&#125;```区域，所有的```overflow```需要滚动的都可以生效了。## 页面描述```html&lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;http://www.xxx.com/App_icon_114.png&quot; /&gt;&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;72x72&quot; href=&quot;http://www.xxx.com/App_icon_72.png&quot; /&gt;&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;http://www.xxx.com/App_icon_114.png&quot; /&gt; 这个属性是当用户把连接保存到手机桌面时使用的图标，如果不设置，则会用网页的截图。有了这，就可以让你的网页像APP一样存在手机里了 1&lt;link rel=\"apple-touch-startup-image\" href=\"/img/startup.png\" /&gt; 这个是APP启动画面图片，用途和上面的类似，如果不设置，启动画面就是白屏，图片像素就是手机全屏的像素 1&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\" /&gt; 这个描述是表示打开的web app的最上面的时间、信号栏是黑色的，当然也可以设置其它参数，详细参数说明在：Supported Meta Tags 12&lt;meta name=\"apple-touch-fullscreen\" content=\"yes\" /&gt;&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt; 这2个描述也很有用的，如果没有它，你的web app会用safari浏览器打开，有了它，就会用独立进程的无地址栏的打开，完全可以和普通的APP比拟了 下面还有个不错的css，是用来区分视网膜屏幕的，这样你可以在iphone这样的手机里载入2x的图片，就不会模糊了 1234@media only screen and (-webkit-min-device-pixel-ratio:1.5),only screen and (min--moz-device-pixel-ratio:1.5),only screen and (min-device-pixel-ratio:1.5),only screen and (min-resolution:200dpi)&#123;#logo&#123;background-image: url(logo@2x.png);&#125;&#125; 样式表:1234567891011121314&lt;link rel=”apple-touch-startup-image” href=”startup.png” /&gt; // 设置开始页面图片&lt;link rel=”apple-touch-icon” href=”iphon_tetris_icon.png”/&gt; // 在设置书签的时候可以显示好看的图标&lt;link rel=\"stylesheet\" media=\"all and (orientation:portrait)\" href=\"portrait.css\"&gt; // 肖像模式样式&lt;link rel=\"stylesheet\" media=\"all and (orientation:landscape)\"href=\"landscape.css\" // 风景模式样式//竖屏时使用的样式&lt;style media=\"all and (orientation:portrait)\" type=\"text/css\"&gt;#landscape &#123; display: none; &#125;&lt;/style&gt;//横屏时使用的样式&lt;style media=\"all and (orientation:landscape)\" type=\"text/css\"&gt;#portrait &#123; display: none; &#125;&lt;/style&gt; 手机浏览器常用手势动作监听封装(配合zepto,来自mansonchor)手机浏览器常用手势动作监听封装 事件 ： (请参考：指尖的下JS 系列文章)手势事件 touchstart //当手指接触屏幕时触发 touchmove //当已经接触屏幕的手指开始移动后触发 touchend //当手指离开屏幕时触发 touchcancel 触摸事件 gesturestart //当两个手指接触屏幕时触发 gesturechange //当两个手指接触屏幕后开始移动时触发 gestureend 屏幕旋转事件 onorientationchange 检测触摸屏幕的手指何时改变方向 orientationchange touch事件支持的相关属性 touches targetTouches changedTouches clientX // X coordinate of touch relative to the viewport (excludes scroll offset) clientY // Y coordinate of touch relative to the viewport (excludes scroll offset) screenX // Relative to the screen screenY // Relative to the screen pageX // Relative to the full page (includes scrolling) pageY // Relative to the full page (includes scrolling) target // Node the touch event originated from identifier // An identifying number, unique to each touch event 屏幕旋转事件：onorientationchange添加屏幕旋转事件侦听，可随时发现屏幕旋转状态（左旋、右旋还是没旋）。例子： 判断屏幕是否旋转12345678910111213141516function orientationChange() &#123; switch (window.orientation) &#123; case 0: alert(\"肖像模式 0,screen-width: \" + screen.width + \"; screen-height:\" + screen.height); break; case -90: alert(\"左旋 -90,screen-width: \" + screen.width + \"; screen-height:\" + screen.height); break; case 90: alert(\"右旋 90,screen-width: \" + screen.width + \"; screen-height:\" + screen.height); break; case 180: alert(\"风景模式 180,screen-width: \" + screen.width + \"; screen-height:\" + screen.height); break; &#125;;&#125;; 添加事件监听1234addEventListener('load', function()&#123; orientationChange(); window.onorientationchange = orientationChange;&#125;); 隐藏地址栏 &amp; 处理事件的时候，防止滚动条出现：1234// 隐藏地址栏 &amp; 处理事件的时候 ，防止滚动条出现addEventListener('load', function()&#123; setTimeout(function()&#123; window.scrollTo(0, 1); &#125;, 100);&#125;); 双手指滑动事件：12345678// 双手指滑动事件addEventListener('load',function()&#123; window.onmousewheel = twoFingerScroll;&#125;, false // 兼容各浏览器，表示在冒泡阶段调用事件处理程序 (true 捕获阶段));function twoFingerScroll(ev) &#123; var delta =ev.wheelDelta/120; //对 delta 值进行判断(比如正负) ，而后执行相应操作 return true;&#125;; 判断是否为iPhone：1234// 判断是否为 iPhone ：function isAppleMobile() &#123; return (navigator.platform.indexOf('iPad') != -1);&#125;; localStorage:123var v = localStorage.getItem('n') ? localStorage.getItem('n') : \"\"; // 如果名称是 n 的数据存在 ，则将其读出 ，赋予变量 v 。localStorage.setItem('n', v); // 写入名称为 n、值为 v 的数据localStorage.removeItem('n'); // 删除名称为 n 的数据 使用特殊链接：如果你关闭自动识别后 ，又希望某些电话号码能够链接到 iPhone 的拨号功能 ，那么可以通过这样来声明电话链接 , 12&lt;a href=\"tel:12345654321\"&gt;打电话给我&lt;/a&gt;&lt;a href=\"sms:12345654321\"&gt;发短信&lt;/a&gt; 或用于单元格： 1&lt;td onclick=\"location.href='tel:122'\"&gt;&lt;/td&gt; 自动大写与自动修正要关闭这两项功能，可以通过autocapitalize 与autocorrect 这两个选项： 1&lt;input type=\"text\" autocapitalize=\"off\" autocorrect=\"off\" /&gt; WebKit CSS:①“盒模型”的具体描述性质的包围盒块内容，包括边界，填充等等。 12345678910-webkit-border-bottom-left-radius: radius;-webkit-border-top-left-radius: horizontal_radius vertical_radius;-webkit-border-radius: radius; //容器圆角-webkit-box-sizing: sizing_model; 边框常量值：border-box/content-box-webkit-box-shadow: hoff voff blur color; //容器阴影（参数分别为：水平X 方向偏移量；垂直Y 方向偏移量；高斯模糊半径值；阴影颜色值）-webkit-margin-bottom-collapse: collapse_behavior; 常量值：collapse/discard/separate-webkit-margin-start: width;-webkit-padding-start: width;-webkit-border-image: url(borderimg.gif) 25 25 25 25 round/stretch round/stretch;-webkit-appearance: push-button; //内置的CSS 表现，暂时只支持push-button ②“视觉格式化模型”描述性质，确定了位置和大小的块元素。 12direction: rtlunicode-bidi: bidi-override; 常量：bidi-override/embed/normal ③“视觉效果”描述属性，调整的视觉效果块内容，包括溢出行为，调整行为，能见度，动画，变换，和过渡。 1234567891011121314clip: rect(10px, 5px, 10px, 5px)resize: auto; 常量：auto/both/horizontal/none/verticalvisibility: visible; 常量: collapse/hidden/visible-webkit-transition: opacity 1s linear; 动画效果 ease/linear/ease-in/ease-out/ease-in-out-webkit-backface-visibility: visibler; 常量：visible(默认值)/hidden-webkit-box-reflect: right 1px; 镜向反转-webkit-box-reflect: below 4px -webkit-gradient(linear, left top, left bottom,from(transparent), color-stop(0.5, transparent), to(white));-webkit-mask-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0,0,0,1)), to(rgba(0,0,0,0)));; //CSS 遮罩/蒙板效果-webkit-mask-attachment: fixed; 常量：fixed/scroll-webkit-perspective: value; 常量：none(默认)-webkit-perspective-origin: left top;-webkit-transform: rotate(5deg);-webkit-transform-style: preserve-3d; 常量：flat/preserve-3d; (2D 与3D) ④“生成的内容，自动编号，并列出”描述属性，允许您更改内容的一个组成部分，创建自动编号的章节和标题，和操纵的风格清单的内容。 1234567content: “Item” counter(section) ” “;This resets the counter.First section&gt;two sectionthree sectioncounter-increment: section 1;counter-reset: section; ⑤“分页媒体”描述性能与外观的属性，控制印刷版本的网页，如分页符的行为。 123page-break-after: auto; 常量：always/auto/avoid/left/rightpage-break-before: auto; 常量：always/auto/avoid/left/rightpage-break-inside: auto; 常量：auto/avoid ⑥“颜色和背景”描述属性控制背景下的块级元素和颜色的文本内容的组成部分。 123-webkit-background-clip: content; 常量：border/content/padding/text-webkit-background-origin: padding; 常量：border/content/padding/text-webkit-background-size: 55px; 常量：length/length_x/length_y ⑦ “字型”的具体描述性质的文字字体的选择范围内的一个因素。报告还描述属性用于下载字体定义。 1unicode-range: U+00-FF, U+980-9FF; ⑧“文本”描述属性的特定文字样式，间距和自动滚屏。 12345678910111213141516171819text-shadow: #00FFFC 10px 10px 5px;text-transform: capitalize; 常量：capitalize/lowercase/none/uppercaseword-wrap: break-word; 常量：break-word/normal-webkit-marquee: right large infinite normal 10s; 常量：direction(方向) increment(迭代次数) repetition(重复) style(样式) speed(速度);-webkit-marquee-direction: ahead/auto/backwards/down/forwards/left/reverse/right/up-webkit-marquee-incrementt: 1-n/infinite(无穷次)-webkit-marquee-speed: fast/normal/slow-webkit-marquee-style: alternate/none/scroll/slide-webkit-text-fill-color: #ff6600; 常量：capitalize, lowercase, none, uppercase-webkit-text-security: circle; 常量：circle/disc/none/square-webkit-text-size-adjust: none; 常量:auto/none;-webkit-text-stroke: 15px #fff;-webkit-line-break: after-white-space; 常量：normal/after-white-space-webkit-appearance: caps-lock-indicator;-webkit-nbsp-mode: space; 常量： normal/space-webkit-rtl-ordering: logical; 常量：visual/logical-webkit-user-drag: element; 常量：element/auto/none-webkit-user-modify: read- only; 常量：read-write-plaintext-only/read-write/read-only-webkit-user-select: text; 常量：text/auto/none ⑨“表格”描述的布局和设计性能表的具体内容。 12345678-webkit-border-horizontal-spacing: 2px;-webkit-border-vertical-spacing: 2px;-webkit-column-break-after: right; 常量：always/auto/avoid/left/right-webkit-column-break-before: right; 常量：always/auto/avoid/left/right–webkit-column-break-inside: logical; 常量：avoid/auto-webkit-column-count: 3; //分栏-webkit-column-rule: 1px solid #fff;style:dashed,dotted,double,groove,hidden,inset,none,outset,ridge,solid ⑩“用户界面”描述属性，涉及到用户界面元素在浏览器中，如滚动文字区，滚动条，等等。报告还描述属性，范围以外的网页内容，如光标的标注样式和显示当您按住触摸触摸目标，如在iPhone上的链接。 12345678-webkit-box-align: baseline,center,end,start,stretch 常量：baseline/center/end/start/stretch-webkit-box-direction: normal;常量：normal/reverse-webkit-box-flex: flex_valuet-webkit-box-flex-group: group_number-webkit-box-lines: multiple; 常量：multiple/single-webkit-box-ordinal-group: group_number-webkit-box-orient: block-axis; 常量：block-axis/horizontal/inline-axis/vertical/orientation–webkit-box-pack: alignment; 常量：center/end/justify/start 动画过渡这是 Webkit 中最具创新力的特性：使用过渡函数定义动画。 12345678-webkit-animation: title infinite ease-in-out 3s;animation 有这几个属性：-webkit-animation-name： //属性名，就是我们定义的keyframes-webkit-animation-duration：3s //持续时间-webkit-animation-timing-function： //过渡类型：ease/ linear(线性) /ease-in(慢到快)/ease-out(快到慢) /ease-in-out(慢到快再到慢) /cubic-bezier-webkit-animation-delay：10ms //动画延迟(默认0)-webkit-animation-iteration-count： //循环次数(默认1)，infinite 为无限-webkit-animation-direction： //动画方式：normal(默认 正向播放)； alternate(交替方向，第偶数次正向播放，第奇数次反向播放) 这些同样是可以简写的。但真正让我觉的很爽的是keyframes，它能定义一个动画的转变过程供调用，过程为0%到100%或from(0%)到to(100%)。简单点说，只要你有想法，你想让元素在这个过程中以什么样的方式改变都是很简单的。 12345-webkit-transform: 类型（缩放scale/旋转rotate/倾斜skew/位移translate）scale(num,num) 放大倍率。scaleX 和 scaleY(3)，可以简写为：scale(* , *)rotate(*deg) 转动角度。rotateX 和 rotateY，可以简写为：rotate(* , *)Skew(*deg) 倾斜角度。skewX 和skewY，可简写为：skew(* , *)translate(*,*) 坐标移动。translateX 和translateY，可简写为：translate(* , *)。 利用media query监听media query相信大部分人已经使用过了。其实javascript可以配合media query这么用： 123456789var mql = window.matchMedia(\"(orientation: portrait)\");mql.addListener(handleOrientationChange);handleOrientationChange(mql); function handleOrientationChange(mql) &#123; if (mql.matches) &#123; alert('The device is currently in portrait orientation ') &#125; else &#123; alert('The device is currently in landscape orientation') &#125;&#125; 我个人理解，是借助了media query接口做的事件监听，所以很强大！ 锁定 viewport1ontouchmove=\"event.preventDefault()\" //锁定viewport，任何屏幕操作不移动用户界面（弹出键盘除外）。 被点击元素的外观变化，可以使用样式来设定：1-webkit-tap-highlight-color: 颜色 侦测iPhone/iPod开发特定设备的移动网站，首先要做的就是设备侦测了。下面是使用Javascript侦测iPhone/iPod的UA，然后转向到专属的URL。 12345if((navigator.userAgent.match(/iPhone/i)) || (navigator.userAgent.match(/iPod/i))) &#123; if (document.cookie.indexOf(\"iphone_redirect=false\") == -1) &#123; window.location = \"http://m.example.com\"; &#125;&#125; 虽然Javascript是可以在水果设备上运行的，但是用户还是可以禁用。它也会造成客户端刷新和额外的数据传输，所以下面是服务器端侦测和转向： 1234if(strstr($_SERVER['HTTP_USER_AGENT'],'iPhone') || strstr($_SERVER['HTTP_USER_AGENT'],'iPod')) &#123; header('Location: http://yoursite.com/iphone'); exit();&#125; 阻止旋转屏幕时自动调整字体大小1html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 &#123;-webkit-text-size-adjust:none;&#125; iPhone才识别的CSS如果不想设备侦测，可以用CSS媒体查询来专为iPhone/iPod定义样式。 1@media screen and (max-device-width: 480px) &#123;&#125; 缩小图片网站的大图通常宽度都超过480像素，如果用前面的代码限制了缩放，这些图片在iPhone版显示显然会超过屏幕。好在iPhone机能还够，我们可以用CSS让iPhone自动将大图片缩小显示。 123@media screen and (max-device-width: 480px)&#123; img&#123;max-width:100%;height:auto;&#125;&#125; ##模拟:hover伪类因为iPhone并没有鼠标指针，所以没有hover事件。那么CSS :hover伪类就没用了。但是iPhone有Touch事件，onTouchStart 类似 onMouseOver，onTouchEnd 类似 onMouseOut。所以我们可以用它来模拟hover。使用Javascript： 12345var myLinks = document.getElementsByTagName('a');for(var i = 0; i &lt; myLinks.length; i++)&#123; myLinks[i].addEventListener(’touchstart’, function()&#123;this.className = “hover”;&#125;, false); myLinks[i].addEventListener(’touchend’, function()&#123;this.className = “”;&#125;, false);&#125; 然后用CSS增加hover效果： 1a:hover, a.hover &#123; /* 你的hover效果 */ &#125; 这样设计一个链接，感觉可以更像按钮。并且，这个模拟可以用在任何元素上。 ##flexbox布局模板 flex模板 深入了解flex布局 ##利用高质量图片优化retina屏幕的显示(来自 w3cplus) 经典的文章 使用CSS3的background-size优化苹果的Retina屏幕的图像显示 使用css sprites来优化你的网站在Retina屏幕下显示 一个案例 ##测试是否支持svg图片 1document.implementation.hasFeature(\"http:// www.w3.org/TR/SVG11/feature#Image\", \"1.1\") ##安卓中viewport的width大于device-width时文字无故折行 Android上当viewport的width大于device-width时出现文字无故折行的解决办法 ##active的兼容(来自薛端阳) 今天发现，要让a链接的Css active伪类生效，只需要给这个a链接的touch系列的任意事件touchstart/touchend绑定一个空的匿名方法即可hack成功 1234567891011&lt;style&gt; a &#123;color: #000;&#125; a:active &#123;color: #fff;&#125;&lt;/style&gt;&lt;a herf=”asdasd”&gt;asdasd&lt;/a&gt;&lt;script&gt; var a = document.getElementsByTagName(‘a’); for (var i = 0; i &lt; a.length; i++) &#123; a[i].addEventListener(‘touchstart’, function() &#123;&#125;, false); &#125;&lt;/script&gt; ##消除transition闪屏 两个方法 1234-webkit-transform-style: preserve-3d;/*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/-webkit-backface-visibility:?hidden;/*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/ ##消除ie10里面的那个叉号 Pseudo-elements input:-ms-clear{display:none;} ##关于ios与os端字体的优化(横竖屏会出现字体加粗不一致等) mac下网页中文字体优化 UIWebView font is thinner in portrait than landscape ##js事件click 事件普遍 300ms 的延迟在手机上绑定click 事件，会使得操作有300ms 的延迟，体验并不是很好。开发者大多数会使用封装的 tap 事件来代替click 事件，所谓的 tap 事件由 touchstart 事件 + touchmove 判断 + touchend 事件封装组成 ##ios点击会慢300ms IOS browsers have a 300ms click delay - But developers can bypass it Eliminate 300ms delay on click events in mobile Safarii 使用css3动画的时尽量利用3D加速，从而使得动画变得流畅。动画过程中的动画闪白可以通过backface-visibility 隐藏。 12-webkit-transform-style: preserve-3d;-webkit-backface-visibility: hidden; 常见的IPHONE 和 Android屏幕参数。 设备 分辨率 设备像素比率 Android LDPI 320×240 0.75 Iphone 3 &amp; Android MDPI 320×480 1 Android HDPI 480×800 1.5 Iphone 4 960×640 2.0 Iphone 4的一个 CSS 像素实际上表现为一块 2×2 的像素。所以图片像是被放大2倍一样，模糊不清晰。 解决办法： 1、页面引用 1234&lt;link rel=\"stylesheet\" media=\"screen and (-webkit-device-pixel-ratio: 0.75)\" href=\"ldpi.css\" /&gt;&lt;link rel=\"stylesheet\" media=\"screen and (-webkit-device-pixel-ratio: 1.0)\" href=\"mdpi.css\" /&gt;&lt;link rel=\"stylesheet\" media=\"screen and (-webkit-device-pixel-ratio: 1.5)\" href=\"hdpi.css\" /&gt;&lt;link rel=\"stylesheet\" media=\"screen and (-webkit-device-pixel-ratio: 2.0)\" href=\"retina.css\" /&gt; 2、CSS文件里 12345678910#header &#123; background:url(mdpi/bg.png);&#125;@media screen and (-webkit-device-pixel-ratio: 1.5) &#123; /*CSS for high-density screens*/ #header &#123; background:url(hdpi/bg.png); &#125;&#125; ie10的特殊鼠标事件IE10 事件监听 不让android识别邮箱1&lt;meta content=\"email=no\" name=\"format-detection\" /&gt; 禁止ios弹出各种操作窗口1-webkit-touch-callout:none 禁止用户选中文字1-webkit-user-select:none 动画效果中，使用translate比使用定位性能高Why Moving Elements With Translate() Is Better Than Pos:abs Top/left 拿到滚动条12window.scrollYwindow.scrollX 比如要绑定一个touchmove的事件，正常的情况下类似这样(来自呼吸二氧化碳) 123$('div').on('touchmove', function()&#123;//.….code&#123;&#125;); 而如果中间的code需要处理的东西多的话，fps就会下降影响程序顺滑度，而如果改成这样 1234$('div').on('touchmove', function() &#123; setTimeout(function() &#123; //.….code &#125;, 0); &#123;&#125;); 把代码放在setTimeout中，会发现程序变快. ##android监听返回键 【Javascript设计模式16】- 享元模式 ##关于ios系统中，webapp启动图片在不同设备上的适应性设置 不同设备上的适应性设置 ##关于ios系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格(焦点科技葛亮)可以通过正则去掉 1this.value = this.value.replace(/\\u2006/g, ''); ##关于android webview中，input元素输入时出现的怪异情况,见图: 怪异图 Android web视图,至少在HTC EVO和三星的Galaxy Nexus中，文本输入框在输入时表现的就像占位符。情况为一个类似水印的东西在用户输入区域，一旦用户开始输入便会消失(见图片)。在android的默认样式下当输入框获得焦点后,若存在一个绝对定位或者fixed的元素，布局会被破坏,其他元素与系统输入字段会发生重叠(如搜索图标将消失为搜索字段),可以观察到布局与原始输入字段有偏差(见截图)。这是一个相当复杂的问题，以下简单布局可以重现这个问题: 12&lt;label for=\"phone\"&gt;Phone: *&lt;/label&gt;&lt;input type=\"tel\" name=\"phone\" id=\"phone\" minlength=\"10\" maxlength=\"10\" inputmode=\"latin digits\" required=\"required\" /&gt; 解决方法 1-webkit-user-modify: read-write-plaintext-only 详细参考[Android]: Input Field Issues注意，该属性会导致中文不能输入词组，只能单个字。感谢鬼哥与飞（游勇飞）贡献此问题与解决方案 另外，在position:fixed后的元素里，尽量不要使用输入框。更多的bug可参考(移动端web页面应用position:fixed题目总结)[http://www.cosdiv.com/page/M0/S882/882353.html] 依旧无法解决（摩托罗拉ME863手机），则使用```-webkit-text-security: disc```; 隐藏输入密码从而解决。123456789##JS动态生成的select下拉菜单在Android2.x版本的默认浏览器里不起作用解决方法删除了```overflow-x:hidden```; 然后在JS生成下来菜单之后focus聚焦，这两步操作之后解决了问题。(来自岛都-小Qi)参考 ```HTML &lt;select&gt; control disabled in Android WebView (in emulator)``` [http://stackoverflow.com/questions/4697908/html-select-control-disabled-in-android-webview-in-emulator](http://stackoverflow.com/questions/4697908/html-select-control-disabled-in-android-webview-in-emulator)##andriod上去掉语音输入按钮 input::-webkit-input-speech-button {display: none}1234567891011121314151617181920212223 ##ios输入框最佳实践[Mobile-friendly input of a digits + spaces string (a credit card number)](http://stackoverflow.com/questions/11219242/mobile-friendly-input-of-a-digits-spaces-string-a-credit-card-number)[HTML5 input type number vs tel](http://stackoverflow.com/questions/8216278/html5-input-type-number-vs-tel)[iPhone: numeric keyboard for text input](http://stackoverflow.com/questions/6178556/iphone-numeric-keyboard-for-text-input)[Managing the Keyboard](https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/KeyboardManagement/KeyboardManagement.html) [HTML5 inputs and attribute support](http://www.miketaylr.com/code/input-type-attr.html)##iphone6的那些事[iPhone 6 屏幕揭秘](http://wileam.com/iphone-6-screen-cn/)##ios6跟iphone5的那些事ip5的媒体查询 @media (device-height: 568px) and (-webkit-min-device-pixel-ratio: 2) {/ iPhone 5 or iPod Touch 5th generation /}1234567 使用媒体查询，提供不同的启动图片：```html&lt;link href=\"startup-568h.png\" rel=\"apple-touch-startup-image\" media=\"(device-height: 568px)\"&gt;&lt;link href=\"startup.png\" rel=\"apple-touch-startup-image\" sizes=\"640x920\" media=\"(device-height: 480px)\"&gt; 拍照上传 12&lt;input type=file accept=\"video/*\"&gt;&lt;input type=file accept=\"image/*\"&gt; 不支持其他类型的文件 ，如音频，Pages文档或PDF文件。 也没有getUserMedia摄像头的实时流媒体支持。 可以使用的html5高级api:multipart POST表单提交上传XMLHttpRequest 2 AJAX上传（甚至进度支持）文件API ，在iOS 6允许JavaScript直接读取的字节数和客户端操作文件。 智能应用程序横幅 有了智能应用程序横幅，当网站上有一个相关联的本机应用程序时，Safari浏览器可以显示一个横幅。 如果用户没有安装这个应用程序将显示“安装”按钮，或已经安装的显示“查看”按钮可打开它。 在iTunes Link Maker搜索我们的应用程序和应用程序ID。 1&lt;meta name=\"apple-itunes-app\" content=\"app-id=9999999\"&gt; 可以使用 app-argument 提供字符串值，如果参加iTunes联盟计划，可以添加元标记数据 12&lt;meta name=\"apple-itunes-app\" content=\"app-id=9999999, app-argument=xxxxxx\"&gt;&lt;meta name=\"apple-itunes-app\" content=\"app-id=9999999, app-argument=xxxxxx, affiliate-data=partnerId=99&amp;siteID=XXXX\"&gt; 横幅需要156像素（设备是312 hi-dpi）在顶部，直到用户在下方点击内容或关闭按钮，你的网站才会展现全部的高度。 它就像HTML的DOM对象，但它不是一个真正的DOM。 CSS 3滤镜 1-webkit-filter: blur(5px) grayscale (.5) opacity(0.66) hue-rotate(100deg); 交叉淡变 1background-image: -webkit-cross-fade(url(\"logo1.png\"), url(\"logo2.png\"), 50%); Safari中的全屏幕 除了chrome-less 主屏幕meta标签，现在的iPhone和iPod Touch（而不是在iPad）支持全屏幕模式的窗口。 没有办法强制全屏模式，它需要由用户启动（工具栏上的最后一个图标）。需要引导用户按下屏幕上的全屏图标来激活全屏效果。 可以使用onresize事件检测是否用户切换到全屏幕。 支持requestAnimationFrameAPI 支持image-set,retina屏幕的利器 1-webkit-image-set(url(low.png) 1x, url(hi.jpg) 2x) 应用程序缓存限制增加至25MB。 Web View（pseudobrowsers，PhoneGap/Cordova应用程序，嵌入式浏览器） 上Javascript运行比Safari慢3.3倍（或者说，Nitro引擎在Safari浏览器是Web应用程序是3.3倍速度）。 autocomplete属性的输入遵循DOM规范 来自DOM4的Mutation Observers已经实现。 您可以使用WebKitMutationObserver构造器捕获DOM的变化 Safari不再总是对用 -webkit-transform:preserve-3d 的元素创建硬件加速 支持window.selection 的Selection API Canvas更新 ：createImageData有一个参数，现在有两个新的功能做好准备，用webkitGetImageDataHD和webkitPutImageDataHD提供高分辨率图像 。 更新SVG处理器和事件构造函数 ##IOS7的大更新 iOS 7 的 Safari 和 HTML5：问题，变化和新 API ios7的一些坑(英文) ios7的一些坑2(英文) ##webview相关 #Cache开启和设置 123browser.getSettings().setAppCacheEnabled(true);browser.getSettings().setAppCachePath(\"/data/data/[com.packagename]/cache\");browser.getSettings().setAppCacheMaxSize(5*1024*1024); // 5MB #LocalStorage相关设置 123456789101112browser.getSettings().setDatabaseEnabled(true);browser.getSettings().setDomStorageEnabled(true);String databasePath = browser.getContext().getDir(\"databases\", Context.MODE_PRIVATE).getPath();browser.getSettings().setDatabasePath(databasePath);//Android webview的LocalStorage有个问题，关闭APP或者重启后，就清楚了，所以需要browser.getSettings().setDatabase相关的操作，把LocalStoarge存到DB中 myWebView.setWebChromeClient(new WebChromeClient()&#123; @Override public void onExceededDatabaseQuota(String url, String databaseIdentifier, long currentQuota, long estimatedSize, long totalUsedQuota, WebStorage.QuotaUpdater quotaUpdater) &#123; quotaUpdater.updateQuota(estimatedSize * 2); &#125;&#125; ##浏览器自带缩放按钮取消显示 1browser.getSettings().setBuiltInZoomControls(false); ##几个比较好的实践 使用localstorage缓存html 使用lazyload，还要记得lazyload占位图虽然小，但是最好能提前加载到缓存 延时加载执行js 主要原因就在于Android Webview的onPageFinished事件，Android端一般是用这个事件来标识页面加载完成并显示的，也就是说在此之前，会一直loading，但是Android的OnPageFinished事件会在Javascript脚本执行完成之后才会触发。如果在页面中使用JQuery，会在处理完DOM对象，执行完$(document).ready(function() {});事件自会后才会渲染并显示页面。 ##移动浏览器篇 【UC浏览器】video标签脱离文档流 场景：标签的父元素(祖辈元素)设置transform样式后，标签会脱离文档流。 测试环境：UC浏览器 8.7/8.6 + Android 2.3/4.0 。 Demo：http://t.cn/zj3xiyu 解决方案：不使用transform属性。translate用top、margin等属性替代。 【UC浏览器】video标签总在最前 场景：标签总是在最前（可以理解为video标签的```z-index```属性是```Max```）。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374测试环境：UC浏览器 8.7/8.6 + Android 2.3/4.0 。 【UC浏览器】position:fixed 属性在UC浏览器的奇葩现象场景：设置了position: fixed 的元素会遮挡z-index值更高的同辈元素。 在8.6的版本,这个情况直接出现。 在8.7之后的版本,当同辈元素的height大于713这个「神奇」的数值时,才会被遮挡。测试环境：UC浏览器 8.8_beta/8.7/8.6 + Android 2.3/4.0 。Demo：&lt;http://t.cn/zYLTSg6&gt; 【QQ手机浏览器】不支持HttpOnly场景：带有HttpOnly属性的Cookie，在QQ手机浏览器版本从4.0开始失效。JavaScript可以直接读取设置了HttpOnly的Cookie值。测试环境：QQ手机浏览器 4.0/4.1/4.2 + Android 4.0 。 【MIUI原生浏览器】浏览器地址栏hash不改变场景：location.hash 被赋值后，地址栏的地址不会改变。 但实际上 location.href 已经更新了，通过JavaScript可以顺利获取到更新后的地址。 虽然不影响正常访问，但用户无法将访问过程中改变hash后的地址存为书签。测试环境：MIUI 4.0 【Chrome Mobile】fixed元素无法点击 场景：父元素设置position: fixed; 子元素设置position: absolute; 此时，如果父元素/子元素还设置了overflow: hidden 则出现“父元素遮挡该子元素“的bug。 视觉(view)层并没有出现遮挡，只是无法触发绑定在该子元素上的事件。可理解为：「看到点不到」。补充： 页面往下滚动，触发position: fixed;的特性时，才会出现这个bug，在最顶不会出现。测试平台： 小米1S，Android4.0的Chrome18demo： &lt;http://maplejan.sinaapp.com/demo/fixed_chromemobile.html&gt;解决办法： 把父元素和子元素的overflow: hidden去掉。以上来源于 &lt;http://www.cnblogs.com/maplejan/archive/2013/04/26/3045928.html&gt;【微信浏览器】因为微信浏览器屏蔽了一部分链接图片，所以需要引导用户去打开新页面，可以用以下方式判断微信浏览器的ua```javascriptfunction is_weixn()&#123; var ua = navigator.userAgent.toLowerCase(); if(ua.match(/MicroMessenger/i)==&quot;micromessenger&quot;) &#123; return true; &#125; else &#123; return false; &#125;&#125; 后端判断也很简单，比如php 123456function is_weixin()&#123; if ( strpos($_SERVER['HTTP_USER_AGENT'], 'MicroMessenger') !== false ) &#123; return true; &#125; return false;&#125; 实现微信浏览器内打开App Store链接 ##库的使用实践 ###zepto.js zepto的一篇使用注意点讲解 zepto的著名的tap“点透”bug zepto源码注释 ###使用zeptojs内嵌到android webview影响正常滚动时 去掉61行,其实就是使用原生的滚动12### iscroll4 iscroll4的几个bug(来自http://www.mansonchor.com/blog/blog_detail_64.html内有详细讲解) 12 1.滚动容器点击input框、select等表单元素时没有响应 onBeforeScrollStart: function (e) { e.preventDefault(); }12改为 onBeforeScrollStart: function (e) { var nodeType = e.explicitOriginalTarget © e.explicitOriginalTarget.nodeName.toLowerCase():(e.target © e.target.nodeName.toLowerCase():’’);if(nodeType !=’select’&amp;&amp; nodeType !=’option’&amp;&amp; nodeType !=’input’&amp;&amp; nodeType!=’textarea’) e.preventDefault(); }123452.往iscroll容器内添加内容时，容器闪动的bug源代码的 has3d = ‘WebKitCSSMatrix’ in window &amp;&amp; ‘m11’ in new WebKitCSSMatrix()12改成 has3d = false12345678910111213141516171819202122232425262728293031323334353637 在配置iscroll时，useTransition设置成false3.过长的滚动内容，导致卡顿和app直接闪退1). 不要使用checkDOMChanges。虽然checkDOMChanges很方便，定时检测容器长度是否变化来refresh，但这也意味着你要消耗一个Interval的内存空间2). 隐藏iscroll滚动条，配置时设置hScrollbar和vScrollbar为false。3). 不得已的情况下，去掉各种效果，momentum、useTransform、useTransition都设置为false4.左右滚动时，不能正确响应正文上下拉动iscroll的闪动问题也与渲染有关系，可以参考[运用webkit绘制渲染页面原理解决iscroll4闪动的问题](http://www.iunbug.com/archives/2012/09/19/411.html \"iscroll4\")[iscroll4升级到5要注意的问题](http://blog.csdn.net/gcz564539969/article/details/9156141 \"iscroll5\")##移动端字体问题(待补充)[dp、sp、px傻傻分不清楚](http://zhuanlan.zhihu.com/zhezhexiong/19565895)[Resolution Independent Mobile UI](http://www.sencha.com/blog/resolution-independent-mobile-ui)[Pixel density, retina display and font-size in CSS](http://stackoverflow.com/questions/12058574/pixel-density-retina-display-and-font-size-in-css)[各种ratio](http://bjango.com/articles/min-device-pixel-ratio/)##跨域问题手机浏览器也是浏览器，在ajax调用外部api的时候也存在跨域问题。当然利用phonegap打包后，由于协议不一样就不存在跨域问题了。但页面通常是需要跟后端进行调试的。一般会报类似 XMLHttpRequest cannot load XXXOrigin null is not allowed by Access-Control-Allow-Origin.12以及 XMLHttpRequest cannot load http://. Request header field Content-Type is not allowed by Access-Control-Allow-Headers.”12这时候可以让后端加上两个http头 Access-Control-Allow-Origin “*”Access-Control-Allow-Headers “Origin, X-Requested-With, Content-Type, Accept”12345678910111213141516第一个头可以避免跨域问题，第二个头可以方便ajax请求设置content-type等配置项##phonegap部分*Should not happen: no rect-based-test nodes found*在android项目中的assets中的html页面中加入以下代码，便可解决问题```csswindow,html,body&#123; overflow-x:hidden !important; -webkit-overflow-scrolling: touch !important; overflow: scroll !important;&#125; 参考：Android WebView JellyBean -&gt; Should not happen: no rect-based-test nodes found ##拿联系人的时候报ContactFindOptions is not defined 出现这个问题可能是因为navigator取contacts时绑定的window.onload 注意使用phonegap的api时，一定要在devicereay事件的处理函数中使用api 12345678910document.addEventListener(\"deviceready\", onDeviceReady, false); function onDeviceReady() &#123; callFetchContacts(); &#125;function callFetchContacts()&#123; var options = new ContactFindOptions(); options.multiple = true; var fields = [\"displayName\", \"name\",\"phoneNumbers\"]; navigator.contacts.find(fields, onSuccess, onError,options); &#125; ##调试篇 ###手机抓包与配host 在PC上，我们可以很方便地配host，但是手机上如何配host，这是一个问题。 这里主要使用fiddler和远程代理，实现手机配host的操作，具体操作如下： 首先，保证PC和移动设备在同一个局域网下； PC上开启fiddler，并在设置中勾选“allow remote computers to connect” 首先，保证PC和移动设备在同一个局域网下； PC上开启fiddler，并在设置中勾选“allow remote computers to connect” fiddler 手机上设置代理，代理IP为PC的IP地址，端口为8888（这是fiddler的默认端口）。通常手机上可以直接设置代理，如果没有，可以去下载一个叫ProxyDroid的APP来实现代理的设置。 此时你会发现，用手机上网，走的其实是PC上的fiddler，所有的请求包都会在fiddler中列出来，配合willow使用，即可实现配host，甚至是反向代理的操作。","tags":[{"name":"分享","slug":"分享","permalink":"https://jiaopianjun.cc/tags/分享/"},{"name":"资料","slug":"资料","permalink":"https://jiaopianjun.cc/tags/资料/"}]},{"title":"css实现网格背景","date":"2018-08-31T01:35:37.000Z","path":"2018/08/31/css实现网格背景.html","text":"代码如下： 12345678.grid&#123; background:#ccc; background-image: linear-gradient(white 0px,transparent 0), linear-gradient(90deg, white 0px,transparent 0), linear-gradient(hsla(0,0%,100%,.3) 1px,transparent 0), linear-gradient(90deg,hsla(0,0%,100%,.3) 1px,transparent 0); background-size:75px 75px,75px 75px,15px 15px,15px 15px;&#125; 效果图：","tags":[{"name":"css","slug":"css","permalink":"https://jiaopianjun.cc/tags/css/"}]},{"title":"Python定时发送信息到微信","date":"2018-08-28T02:35:48.000Z","path":"2018/08/28/Python定时发送信息到微信.html","text":"1.想要一个定时提醒天气情况的场景，就想到了用python，这个是基于wxpy 来实现的 注意点： 123需要安装对应插件包python2 和 python3 有引入包不一样注意环境想在服务器一直运行 可以参考 tmux 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234# -*- coding: utf-8 -*import timeimport randomimport requestsfrom wxpy import *import socketimport httpimport jsonimport urlparse#from urllib.parse import urlencodeimport datetimeimport urllibfrom threading import Timerfrom datetime import datetimeimport sysreload(sys)sys.setdefaultencoding('utf8')def get_everydayWords(): url = 'http://open.iciba.com/dsapi/' r = requests.get(url) content = json.loads(r.text) return '每日一句：\\n'+content['content'] +'\\n'+content['note'] + \"\\n\"def get_huangli(): data = &#123;&#125; data[\"appkey\"] = '' //填写自己申请的key 地址：jisuapi.com data[\"year\"] = datetime.now().year data[\"month\"] = datetime.now().month data[\"day\"] = datetime.now().day url_values =urllib.urlencode(data) url = \"http://api.jisuapi.com/huangli/date\" + \"?\" + url_values r = requests.get(url) jsonarr = json.loads(r.text) if jsonarr[\"status\"] != u\"0\": print(jsonarr[\"msg\"]) return \"今日无黄历信息\" result = jsonarr[\"result\"] xingqi = '星期' + result['week'] yangli = '阳历日期：' + result['yangli'] nongli = '农历日期：' + result['nongli'] wuxing = '今日五行：' + result['wuxing'] chong ='今日注意的生肖:' + result[\"chong\"] suici = '岁次：' + ','.join(result['suici']) star = '本月星座：' + result['star'] shengxiao = '今年生肖：' + result['shengxiao'] yi = '宜：' + ','.join(result['yi']) ji = '忌：' + ','.join(result['ji']) return xingqi + '黄历：' + '\\n' + '\\n' + yangli + '\\n' + nongli + '\\n' + wuxing + '\\n' + chong + \"\\n\" + suici + \"\\n\" + star + \"\\n\" + shengxiao + \"\\n\" + yi + \"\\n\" + ji + \"\\n\"def get_html(url, data=None): # 模拟浏览器来获取网页的html代码 header = &#123; 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.8', 'Connection': 'keep-alive', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.235' &#125; # 设定超时时间，防止被网站认为是爬虫 timeout = random.choice(range(80, 180)) while True: try: rep = requests.get(url, headers=header, timeout=timeout) rep.encoding = \"utf-8\" if rep.text[2] != 's': # 该api调用时有失败的可能，一个简单的判断调用是否成功 break except timeout as e: print(\"3:\", e) time.sleep(random.choice(range(8, 15))) except socket.error as e: print(\"4:\", e) time.sleep(random.choice(range(20, 60))) except http.client.BadStatusLine as e: print(\"5:\", e) time.sleep(random.choice(range(30, 80))) except http.client.IncompleteRead as e: print(\"6:\", e) time.sleep(random.choice(range(5, 15))) except: print ('获取内容失败') time.sleep(10) result = '' temp = rep.json() result = rep.json() nowTime=datetime.now().strftime('%Y-%m-%d %H:%M:%S') result = result['data'] ondeday = result['yesterday'] result2 = '今日'+ ondeday['date'] + '\\n' \\ + '温度：'+ ondeday['low'] + ' --- ' + ondeday['high'] + '\\n' \\ + '日出：' + ondeday['sunrise'] + ' --- ' + '日落：' + ondeday['sunset'] + '\\n' \\ + '风向：' + ondeday['fx'] + ' --- ' + ondeday['fl'] + '\\n' \\ + '天气：' + ondeday['type'] + '\\n' \\ + '提示：' + ondeday['notice'] + '\\n' \\ + '湿度：' + result['shidu'] + '\\n' \\ + '空气质量：' + result['quality'] + '\\n' \\ + 'pm25：' + str(result['pm25']) + '\\n' \\ + '------------------------------' + '\\n' for item in result['forecast']: result2 = result2 + '日期：'+item['date'] + '\\n' \\ + '风力：' + item['fl'] + '\\n' \\ + '风向：' + item['fx'] + '\\n' \\ + '最高温：' + item['high'] + '\\n' \\ + '最低温：' + item['low'] + '\\n' \\ + '温馨提醒：' + item['notice'] + '\\n' \\ + '日出时间：' + item['sunrise'] + '\\n' \\ + '日落时间：' + item['sunset'] + '\\n' \\ + '天气：' + item['type'] + '\\n' \\ + '------------------------------' + '\\n' \\ result2 = result2 + '发送时间：' + nowTime + '\\n' return result2def get_now(city, data=None): # 模拟浏览器来获取网页的html代码 header = &#123; 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.8', 'Connection': 'keep-alive', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.235' &#125; url = 'https://free-api.heweather.com/s6/weather/now?location='+city+'&amp;key=614d3a7941034ba48088f689788e789f' # 设定超时时间，防止被网站认为是爬虫 timeout = random.choice(range(80, 180)) while True: try: rep = requests.get(url, headers=header, timeout=timeout) rep.encoding = \"utf-8\" if rep.text[2] != 's': # 该api调用时有失败的可能，一个简单的判断调用是否成功 break except timeout as e: print(\"3:\", e) time.sleep(random.choice(range(8, 15))) except socket.error as e: print(\"4:\", e) time.sleep(random.choice(range(20, 60))) except http.client.BadStatusLine as e: print(\"5:\", e) time.sleep(random.choice(range(30, 80))) except http.client.IncompleteRead as e: print(\"6:\", e) time.sleep(random.choice(range(5, 15))) except: print ('获取内容失败') time.sleep(10) result = '' temp = rep.json() temp = temp['HeWeather6'][0] update = temp['update'] now = temp['now'] nowTime=datetime.now().strftime('%Y-%m-%d %H:%M:%S') result = '实时天气预报---' + '更新时间：'+ update['loc'] + '\\n'+'\\n'\\ + '当前天气：'+ now['cond_txt'] + '\\n'\\ + '当前温度：'+ now['tmp'] + '°C' + '\\n'\\ + '体感温度：'+ now['fl'] + '°C' + '\\n'\\ + '风向：'+ now['wind_dir'] + ' ' + now['wind_sc'] + '级 '+ now['wind_spd'] + '公里/小时'+ '\\n'\\ + '相对湿度：'+ now['hum'] + '%' + '\\n'\\ + '降水量：'+ now['pcpn'] + 'ml' + '\\n'\\ + '能见度：'+ now['vis'] + '公里' + '\\n'\\ + '云量：'+ now['cloud'] + '\\n' result = result + '发送时间：' + nowTime return resultdef auto_send(): # unix时间戳设定为每天早上7：30分自动发送消息 while True: time_now = int(time.time()) now = datetime.now() now_str = now.strftime('%Y/%m/%d %H:%M:%S')[11:] t = Timer(1,auto_send) # t.start() print(now_str) #发送全部 7点24 发送 每天早上 if now_str in ['07:24:00']: for i in ['苏州']: url = 'https://www.sojson.com/open/api/weather/json.shtml?city=%s' %i weather = get_html(url) word = get_everydayWords() huangli = get_huangli() # 选择对象发送消息 bot.file_helper.send(weather) print(bot.groups().search(u'')) my_friend = bot.friends().search(u'Lie')[0] my_friend2 = bot.friends().search(u'cc')[0] # my_group = bot.groups().search('Test')[0] my_friend.send(word + weather + huangli) my_friend2.send(word + weather + huangli) my_group.send(word + weather + huangli) if now_str in ['09:00:00','10:00:00','11:00:00','12:00:00','13:00:00','14:00:00','15:00:00','16:00:00','16:08:00','17:00:00','18:00:00','19:00:00','20:00:00','21:00:00',]: city = '苏州' weather = get_now(url) word = get_everydayWords() huangli = get_huangli() # 选择对象发送消息 bot.file_helper.send(weather) // 这是发送给登陆微信的微信助手 print(bot.groups().search(u'')) my_friend = bot.friends().search(u'Lie')[0] // 好友 my_friend2 = bot.friends().search(u'cc')[0] my_group = bot.groups().search('Test')[0] // 群组 my_friend.send(weather) my_friend2.send(weather) my_group.send(weather)if __name__ == \"__main__\": tuling = Tuling(api_key='') //填写自己的图灵机器人key bot = Bot(cache_path=True,console_qr = True) // 添加缓存，不用每次都扫码登陆，如果是linux 则显示二维码，需安装对应插件包 myself = bot.self bot.enable_puid('wxpy_puid.pkl') @bot.register(msg_types=TEXT) // 图灵机器人调用 def auto_reply_all(msg): tuling.do_reply(msg) auto_send() bot.join()","tags":[{"name":"Python","slug":"Python","permalink":"https://jiaopianjun.cc/tags/Python/"},{"name":"微信","slug":"微信","permalink":"https://jiaopianjun.cc/tags/微信/"}]},{"title":"七夕呀","date":"2018-08-17T09:22:49.000Z","path":"2018/08/17/七夕.html","text":"周五啦，也是七夕啦，怎么就这么巧呢，外面狂风大暴雨呀！记录一下","tags":[{"name":"七夕","slug":"七夕","permalink":"https://jiaopianjun.cc/tags/七夕/"},{"name":"2018","slug":"2018","permalink":"https://jiaopianjun.cc/tags/2018/"},{"name":"日记","slug":"日记","permalink":"https://jiaopianjun.cc/tags/日记/"}]},{"title":"node学习图谱","date":"2018-08-15T09:10:58.000Z","path":"2018/08/15/node学习图谱.html","text":"nodejs入门.png","tags":[{"name":"node","slug":"node","permalink":"https://jiaopianjun.cc/tags/node/"}]},{"title":"一次坎坷的上线历程","date":"2018-08-12T14:02:43.000Z","path":"2018/08/12/一次坎坷的上线之旅.html","text":"在掘金上看到别人的博客，带有后端系统，然后就想自己试下部署一下，过程正是一言难尽，但是也学到了很多东西。","tags":[]},{"title":"如何激活Windows10","date":"2018-08-11T01:08:23.000Z","path":"2018/08/11/如何激活Windows10.html","text":"1.首先右击桌面左下角的“Windows”按钮（即开始按钮），选择点击“命令提示符（管理员）”。 2.弹出窗口后输入命令：slmgr.vbs /upk，按回车，卸载原来的产品激活，即提示“已成功卸载了产品密钥”。 3.继续我们输入如下命令：slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX（此为版本对应的密钥，自己查看并按上面对应选择），接着回车键后弹出“成功的安装了产品密钥”。 4.继续以下命令：slmgr /skms zh.us.to，回车弹出“密钥管理服务计算机名成功的设置为zh.us.to”的提示 5.当再输入以下命令时：slmgr /ato，回车键后将弹出“成功的激活了产品”的提示窗口。 6.以上步骤即激活了win10系统了，如果需要查看一下此密钥的激活天数，可以输入以下命令：slmgr /xpr，回车键后，将弹出窗口，提示”批量激活的过期时间”。当此激活操作过期后，我们只需要重新激活一次，即可再享受180天激活机会。 密钥： Win10正式专业版密钥（32位和64位均可正常使用）： W269N-WFGWX-YVC9B-4J6C9-T83GX Win10正式企业版密钥（32位和64位均可正常使用）： NPPR9-FWDCX-D2C8J-H872K-2YT43 其他密钥，也可用： 专业版：VK7JG-NPHTM-C97JM-9MPGT-3V66T 企业版：XGVPP-NMH47-7TTHJ-W3FW7-8HV2C 教育版：YNMGQ-8RYV3-4PGQ3-C8XTP-7CFBY 专业版N：2B87N-8KFHP-DKV6R-Y2C8J-PKCKT 企业版N：WGGHN-J84D6-QYCPR-T7PJ7-X766F 教育版N：84NGF-MHBT6-FXBX8-QWJK7-DRR8H 企业版S：FWN7H-PF93Q-4GGP8-M8RF3-MDWWW 单语言版：BT79Q-G7N6G-PGBYW-4YWX6-6F4BT","tags":[{"name":"其他","slug":"其他","permalink":"https://jiaopianjun.cc/tags/其他/"}]},{"title":"前端整理","date":"2018-07-11T03:58:43.000Z","path":"2018/07/11/前端整理.html","text":"HTML1.为什么HTML5 不需要写那么长得声明？ 1因为 Html5 不是基于SGML的，所以不需要写dtd声明，但是需要写doctype来规范浏览器的行为 2.HTML5新增了哪些标签？ 1header,footer,nav,article,section等 3.cookie,localStorage,sessionStorage的区别？ 123456区别，cookie 是用于和服务端通信，其他两个则不会cookie 有大小限制相对于其他两个localStorage 数据永远存储，除非你主动删除sessionStorage 数据在浏览器关闭之前一直存在 4.行内元素，快元素，空元素有哪些？ 123行内元素：span,b,em,a,img块元素： p,div,h1,ul,ol,dt空元素： img,input 5.Canvas,Svg有什么区别？ 12canvas 绘制后是一个dom 放大 会失真，svg 是由多个dom节点组成，可以由js操作 6.页面导入样式得时候，link 和 import 有什么区别？ 123link 是 xthml 标签，除了可以加载css 还可以加载其他事务，import 只能用于加载csslink 方式得样式 优先级高于import 7.对浏览器内核得理解？ 1234分为 渲染引擎 和 js 引擎渲染引擎负责取的网页内容，整理讯息，以及计算网页得显示方式。js引擎负责 执行JavaScript 实现网页动态效果 8.HTML语义化理解？ 1用正确得标签做正确得事，就是在网络加载错误，css么有加载得情况下，也能让网页所表达得意思被用户知道 9.Html离线存储？ 1在浏览器得html头部加上manifest 属性，如果是第一次访问浏览器会根据manifest 得内容进行下载存储离线内容，如果已经访问过则从离线存储中进行加载，然后在比对服务器 如果有新内容在更新离线存储 10.浏览器输入地址，到页面显示得过程？ 1首先 从DNS解析域名 获取ip地址，根据ip地址 找到服务器，服务器根据地址请求 返回页面相关数据，浏览器获取到数据进行页面加载渲染页面 html 状态码 12345100：信息状态码200：成功状态码300：重定向400：客户端错误500：服务器错误 CSS 盒子模型 12标准：content + padding border marginIE：content padding border + margin CSS 多行文本垂直居中 12345678子元素：display: table-cell;vertical-align: middle;子元素必须为行内元素还可以用定位得方法display：flextransfrom 等 3.display:none 和 visibility:hidden 得区别 12前者dom 会从dom 树中消失 后者不会前者会造成页面回流，后者会触发重绘 4.如何避免margin 重叠 123456外层元素padding代替内层元素透明边框 border:1px solid transparent;内层元素绝对定位 postion:absolute:外层元素 overflow:hidden;内层元素 加float:left;或display:inline-block;内层元素padding:1px; 5.css设置垂直居中方法 1234567891.定位：position：absolute;left:50%;top:50%:margin-left:-元素宽度；margin-top:-元素高度2、transform:translate(-50%，-50%)3、display：flex 6.CSS3有哪些新特性 1234567text-shadowborder-radiustext-decorationbox-shadowtransformanimation等 7.css 绘制三角形 1234567利用border 将border得三边设置透明例如：width:0;height:0;border-width:20px;border-style:solid;border-color:transparent transparent transparent red 8.box-sizing 123content-box 默认盒子模型border-box 怪异盒子模型，设置 border padding 会计算在总宽度之内 例如 200 * 200 设置 padding: 10; border:1px; 则实际盒子可使用大小未179*179box-sizing 继承父元素 9.css有哪些可以继承和不可继承得属性 12继承：font系列 color cursor不继承：width,height,padding,margin,border,background 10.隐藏元素得方法 1234561. display:none;2. opacity:0;3. visibility:hidden;4. position:absolute;left:-999999;5. transfrom:scale(0)6. height:0 11.rgba 和 opacity12rgba 作用于元素自身，子元素不会继承opacity 作用于自身和子元素，包括文字 em px rem 区别 123em 相对于 其父元素字体大小变化rem 相对于html字体大小px 固定大小 13.BFC 123456决定了元素如何对其内容进行定位，以及与其他元素得关系和相互作用float属性不为noneposition为absolute或fixeddisplay为inline-block, table-cell, table-caption, flex, inline-flexoverflow不为visible JavaScript1.js的基本数据类型 1boolean,string,number,undefined,null 2.JS有哪些内置对象 12数据封装类对象：object,null,boolean,number,string其他对象: function,arguments,math,date,regexp,error 3.js 强制转换类型和隐式转换类型 123456789强制转换类型 String（），Number（），Boolean（）隐式转换通常发生在运算符加减乘除，等于，还有小于，大于等。。例如：console.log(10-'20')//-10 numberconsole.log(10-'one') //NaN not a numberconsole.log(10-'101a') //NaNconsole.log(10*'20') //200 number 4.js 原型 和 原型链 1234原型：每个对象都会在其内部初始化一个属性，这个属性就是prototype 就是该对象得原型原型链：当我们访问一个对象得属性时，如果这个对象内部不存在这个属性，那我们就去prototype 中找这个属性，这个prototype又会有自己得prototype，这样一直找下去 就是我们所说得原型链关系特点： JavaScript 对象是通过引用来传递得，当修改原型时，与之相关得对象也会继承这一改变。 5.如何判断一个变量的类型 12tyoeofinstancdof 6.如何获取一个对象内包含的属性 1Object.keys() 7.如何阻止冒泡和默认事件？ 123451.event.stopPropagation()方法2.event.preventDefault()方法3.return false ； 8.如何进行事件委托 1利用 on 进行绑定，绑定到不会变化得body 或者 需要操作得 不会变动得那一层父元素上 9.模拟下拉菜单，如何点击其他空白地方 收起菜单 12345678910可以在body 上绑定事件，进行点击得时候判单 如果不是点击得下拉菜单则将菜单关闭$('body').on(\"click\",function(e)&#123; var target = $(e.target); if(target.closest(\"#phone,#first\").length == 0)&#123; $(\"#phone\").hide(); $(\"#phone\").attr(\"value\",\"divm\"); &#125;; e.stopPropagation();&#125;) 10.js如何进行浮点计算 1将计算得数值 乘以 10 倍在计算 11.数组得相关操作 123456789101. pop 删除数组最后一个元素2. push 往数组最后一个插入数据3. shift 删除数组第一个元素4. unshift 往数组第一个插入元素5. concat 连接两个数组6. join 把所有元素放入一个字符串7. sort 对数组进行排序8. reverse 将数组倒序返回9. slice 从数组返回选定数组10. splice 删除元素并往数组添加新元素 12.浅拷贝和深拷贝123456789101. 浅拷贝 相当于复制了一个路径地址，共用得还是一个内存地址，改变复制得元素，源元素也会改变2.深拷贝 彻底复制，两个内存地址 ，两个相互独立如何深拷贝splicejq extend递归JSON.stringify(obj),JSON.parse(_obj); 13.js如何跨域 123456因为浏览器得同源规则，使得 不同域名，端口，协议，ip 得页面受这个限制解决方法：1. JSONP2. CORS3. 通过porxy 代码 由服务器来进行转发 14.document.load 和 document.ready 得区别 12前者在页面所有元素都加载之后才会执行，后者在页面dom 加载后就执行 15.this 的指向问题 123指向调用它的那个对象如果有new关键字，this指向new出来得实例对象在事件中，this 指向触发这个事件得对象 16.aplly/call 1231. 都是调用一个对象的一个方法，用另一个对象替换当前对象2. apply 最多只能接受两个参数 后一个参数为数组，call 则可以接受多个3. 实现继承或者转换对象指针 17.异步加载js的方法 12341. html5 async：脚本可用就执行 defer: 页面加载完成后才执行2. iframe3. ajax eval4. 动态生成script 插入 18.js中有一个函数，执行对象查找时，永远不会去查找原型 1hasOwnProperty 19.如何获取字符串中指定部分？ 1234可以用 1. substring（start,end）// 若有参数为负数则变未0，两个参数选择小得为起始位置，截取得长度为较大和较小之间得差2. substr(start,length)3. slice(start,end) // 截取得长度第二个参数减去第一个得差 第一个参数大于第二个 返回空 20.js 函数防抖 和 事件节流 12函数防抖： 比如说校验手机号码，输入一个校验一次 就比较频繁，可以设置 200毫秒后在校验事件节流： 比如说有一个操作很频繁得事件，例如滚动监听，我们可以给他一个 阈值，一次 只能执行一次。 JQUERY1.Jq 中如何将数组转换为字符串，然后在转换回来 12345678910可以通过 JSON.stringify 来实现$.fn.stringifyArray = function(array)&#123; return JSON.stringify(array)&#125;$.fn.parseArray = function(array)&#123; retrun JSON.parse(array)&#125;$(\"\").stringifyArray(array) 调用 2.jquery.extend 和 jquery.fn.extend 得区别 12前者 是用于 为jq添加类方法 需要jq类来调用后者 可以用来编写 jq 扩展方法，以便于其他地方jq实例可以调用 3.jq实现原理简单描述1为了避免声明了一些全局变量而污染，把代码放在一个“沙箱执行”，jQuery具体的实现，都被包含在了一个立即执行函数构造的闭包里面，然后在暴露出命名空间（可以为API，函数，对象） 4.针对Jq的优化 123class 得选择性能相对于 id 开销会更大，因为需要遍历所有元素频繁操作dom 可以先缓存起来 比如：var $li = $(\"#ul li\") 5.针对 slideUp 动画，如果目标元素是被外部驱动，当鼠标快速连续触发外部元素，会使得动画执行滞后，怎么处理 1执行动画之前，先将其stop 6.jq如何处理缓存得 12post 本身就禁用缓存get 可以在url 加上随机数 或者 时间戳 7.jq 如何加密解密url 12加密： encodeURIComponent解密： decodeURIComponent 8.如何禁止浏览器后退 1window.history.forward(1) VUE1.多组件 单页面复用 1可以用 ：is 来调用 避免使用 v-if 来判断使用 2.vue 双向绑定的原理 1vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的 3.vue-router 有几种导航钩子 1231. 全局 ruter.beforeEach(to,from,next) 跳转前进行拦截判断2. 组件内钩子3. 单独路由独享组件 4.vuex状态如何更新以及原理 123只能通过mutation来进行state的更新，getter 缓存state的值，用于多路径复用action提交的是一个mutation 5.vue-router 实现原理 12在地址中加入#已欺骗浏览器，地址的改变由于正在进行页内导航使用h5 的 window.history 功能，使用 URL 的 hash 来模拟一个完整的 URL 6.vue 如何组件通信 1231. 全局使用 vuex2. 父子组件之间 props emit3. 非父子组件之间 on emit 7.vue 得getter 和 setter 12getter 用来获取值setter 用来赋值触发 upadte 更新 8.vue响应式原理 1231、vue响应式原理就是对你数据的变化，vue会有一个响应，去完成某件事。2、vue的响应式原理就是基于vue知道了数据发生了变化，那么vue是如何知道数据发生了变化呢？3、数据劫持 vue.js 采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter,getter，在数据变动时发布消息给订阅者，触发相应的监听回调 9.vue中keep-live 的作用 1将组件保留在缓存中，可以保留组件状态，避免重新渲染 10.vue 指令 v-el 1将页面已存在得dom元素作为vue实例得挂载目标 11.vue 服务的渲染的优缺点 1有利于页面加载渲染和seo ES61.判断是否是一个数组， 12Array.isArray();instanceof","tags":[{"name":"面试","slug":"面试","permalink":"https://jiaopianjun.cc/tags/面试/"}]},{"title":"响应式网站移动端hover处理","date":"2018-07-03T07:33:24.000Z","path":"2018/07/03/响应式网站移动端hover处理.html","text":"12添加js： document.body.addEventListener('touchstart', function()&#123; &#125;);同时为根节点添加css： -webkit-tap-highlight-color:transparent;","tags":[{"name":"移动端","slug":"移动端","permalink":"https://jiaopianjun.cc/tags/移动端/"}]},{"title":"增加右侧link ICON 样式","date":"2018-07-03T07:08:11.000Z","path":"2018/07/03/增加右侧link-ICON-样式.html","text":"1234增加右侧友情链接样式，改用为阿里 iconfont增加了掘金 ins vuex 等链接","tags":[{"name":"hexo","slug":"hexo","permalink":"https://jiaopianjun.cc/tags/hexo/"}]},{"title":"炫酷 Css3 loading 效果（三）","date":"2018-06-21T10:12:32.000Z","path":"2018/06/21/炫酷-Css3-loading-效果(三).html","text":"1.HTML1234567891011121314151617&lt;div class=\"loader\"&gt; &lt;div class=\"loader-bg\"&gt; &lt;span&gt;LOADING&lt;/span&gt; &lt;/div&gt; &lt;div class=\"drops\"&gt; &lt;div class=\"drop1\"&gt;&lt;/div&gt; &lt;div class=\"drop2\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;defs&gt; &lt;filter id=\"liquid\"&gt; &lt;feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"10\" result=\"blur\" /&gt; &lt;feColorMatrix in=\"blur\" mode=\"matrix\" values=\"1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 18 -7\" result=\"liquid\" /&gt; &lt;/filter&gt; &lt;/defs&gt;&lt;/svg&gt; 2.CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120@-webkit-keyframes animate &#123; 50% &#123; -ms-transform: rotate(360deg) scale(0.8); -webkit-transform: rotate(360deg) scale(0.8); transform: rotate(360deg) scale(0.8); &#125;&#125;@keyframes animate &#123; 50% &#123; -ms-transform: rotate(360deg) scale(0.8); -webkit-transform: rotate(360deg) scale(0.8); transform: rotate(360deg) scale(0.8); &#125; &#125;@keyframes fade-in &#123;0% &#123; opacity: 0;&#125;100% &#123; opacity: 1;&#125;&#125;@keyframes drop &#123;0% &#123; bottom: 0px; opacity: 1;&#125;80% &#123; opacity: 1;&#125;100% &#123; opacity: 1; bottom: -200px;&#125;&#125;@keyframes wave &#123;0% &#123; background-position: 0 160px; background-size: 170px 300px;&#125;100% &#123; background-position: 500px -18px; background-size: 250px 150px;&#125;&#125;.loader &#123;width: 120px;height: 120px;position: fixed;margin: auto;left: 0;right: 0;top: 0;bottom: 0;text-align: center;line-height: 120px;font-family: sans-serif;color: #ffffff;font-size: 16px;&#125;.loader span &#123;z-index: 3;&#125;.loader-bg &#123;position: absolute;left: 0;right: 0;top: 0;bottom: 0;background: transparent repeat-x 0 100px/150px 300px url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAAEsCAYAAACG+vy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABLdJREFUeNrs299nXGkcx/FPMhVKSZUQSinLUEooJSxlWEIJvS1lydXeLqX/Qf+H3i5bpVQverVEo9XYUkqJhhJql2UJIeSq2ovzDacju82PTjKTeb04TjMTjTyZ9zznPOfMxPmHK4Ejmkpy9X+e30myNoq/2Bl/W/ZwKckPtc3V/kLr+Zn6nsN6U/t/k3xMsp5kK8nb1mMC4USdTXKl3vkvVwTdCqIz4J99bR/f045mvfbvKiCBMJAgekluJLlVQQyzbu2v9z3+d8XythXNukA47Dv1QkXRO4aZ4ThcrO1m67GtJC9rW07yWiD814unl2SxopgZk997uoLZjWa7FcxK7QUypmaS3KltznAkSc7VzLnQmmH+SPK49pv7/Y8mLPOOpE69Wy7VvmNIDmS5QnmUZEMgp2u2+LXCmDEc38WbCuX3WgAQyAjqVhg/p7kox2C8TPJbxbItkOE3n+RummVZjs92zSoPJpPcS7P6wfBYTPIiyStxnNhJ/lKSPyeT3E/yV5LnSX5JMmt8TsRU/VHeJ3ma5EdDcvImzj9c+bzH46tJntWx2IZhGviJ91KdYzjxHpFA2j4keZLmgstymjszOfpssVgn3QuxTDvSgbR9aoWyXDMN+3c9zQW92/n67liG1EGvpHfS3MrQq683K5LVNPe/rNYKAI3dGwQX01zQsxhyygPpdyFf3wOTNHdXrrSi+TBmY9pN8lMdOvUqEsbkEOswtiqatTRXLddq2zwF4zeV5lrFfJpVp3mHTmaQg5quF0//suU/Fcq71n4nzT3+wzozXOnb5ryEBDIos7X19nhuO82HYHY/fvmx/r3eOsdZy9FX1Dp9L/LdT9nN1vlCtwIXgkCGyrns72OZ/Ta+ceh2MS6EcgoCOazLtcF3MWkIQCAgEBAICAQEAgIBgYBAQCCAQEAgIBAQCAgEBAICAYGAQEAggEBAICAQEAgIBAQCAgGBgEAAgYBAQCAgEBAICAQEAgIBgYBAAIGAQEAgIBAQCAgEBAICAYEAAgGBgEBAICAQEAgIBAQCAgGBAAIBgYBAQCAgEBAICAQEAgIBBAICAYGAQEAgIBAQCAgEBAICAQQCAgGBgEBAICAQEAgIBAQCAjEEIBAQCAgEBAICAYGAQEAgIBBAICAQEAgIBAQCAgGBgEBAICAQQCAgEBAICAQEAgIBgYBAQCCAQEAgIBAQCAgEBAICAYGAQEAggEBAICAQEAgIBAQCAgGBgEAAgYBAQCAgEBAICAQEAgIBgYBAAIGAQEAgIBAQCAgEBAICAYEAAgGBgEBAICAQEAgIBAQCAgGBAAIBgYBAQCAgEBAICAQEAgIBgRgCEAgIBAQCAgGBgEBAICAQEAggEBAICAQEAgIBgYBAQCAgEBAIIBAQCAgEBAICAYGAQEAgIBBAICAQEAgIBAQCAgGBgEBAICAQQCAgEBAICAQEAgIBgYBAQCCAQEAgIBAQCAgEBAICAYGAQEAggEBAICAQEAgIBAQCAgGBgEAAgYBAQCAgEBAICAQEAgIBgYBAAIGAQEAgIBAQCAgEBAICAYGAQAwBCAQEAgIBgYBAQCAgEBAICAQQCAgEBAICAYGAQEAgIBAQCIy3LwMAZISJmhIzD54AAAAASUVORK5CYII='); z-index: 2;animation: wave 1s ease-out forwards;&#125;.drops &#123;-webkit-filter: url('#liquid');filter: url('#liquid');position:absolute;top:0;left:0;bottom:0;right:0;z-index: 1;opacity: 0;animation: fade-in .1s linear .4s forwards;&#125;.drop1 , .drop2 &#123;width: 21px;height: 24px;border-radius: 50%;position: absolute;left: 0;right: 0;bottom: 0;margin: auto;background-color: #10a7c1&#125;.drop1 &#123;width: 90px;height: 16px;bottom: 2px;border-radius: 0;&#125;.drop2 &#123;animation: drop 1.3s cubic-bezier(1,.19,.66,.12) .5s infinite;&#125;","tags":[{"name":"css","slug":"css","permalink":"https://jiaopianjun.cc/tags/css/"}]},{"title":"炫酷 Css3 loading 效果（二）","date":"2018-06-21T10:12:21.000Z","path":"2018/06/21/炫酷-Css3-loading-效果(二).html","text":"1.HTML12345678&lt;div id=\"loading-center\"&gt; &lt;div id=\"loading-center-absolute\"&gt; &lt;div class=\"object\" id=\"object_four\"&gt;&lt;/div&gt; &lt;div class=\"object\" id=\"object_three\"&gt;&lt;/div&gt; &lt;div class=\"object\" id=\"object_two\"&gt;&lt;/div&gt; &lt;div class=\"object\" id=\"object_one\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 2.CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#loading-center-absolute &#123; position: absolute; left: 50%; top: 50%; height: 200px; width: 200px; margin-top: -100px; margin-left: -100px; &#125;.object&#123; -moz-border-radius: 50% 50% 50% 50%; -webkit-border-radius: 50% 50% 50% 50%; border-radius: 50% 50% 50% 50%; position: absolute; border-left: 5px solid #1c8a95; border-right: 5px solid #1c8a95; border-top: 5px solid transparent; border-bottom: 5px solid transparent; -webkit-animation: animate 2s infinite; animation: animate 2s infinite; &#125;#object_one&#123; left: 75px; top: 75px; width: 50px; height: 50px;&#125; #object_two&#123; left: 65px; top: 65px; width: 70px; height: 70px; -webkit-animation-delay: 0.1s; animation-delay: 0.1s;&#125; #object_three&#123; left: 55px; top: 55px; width: 90px; height: 90px; -webkit-animation-delay: 0.2s; animation-delay: 0.2s;&#125;#object_four&#123; left: 45px; top: 45px; width: 110px; height: 110px; -webkit-animation-delay: 0.3s; animation-delay: 0.3s;&#125;@-webkit-keyframes animate &#123; 50% &#123; -ms-transform: rotate(180deg); -webkit-transform: rotate(180deg); transform: rotate(180deg); &#125; 100% &#123; -ms-transform: rotate(0deg); -webkit-transform: rotate(0deg); transform: rotate(0deg); &#125; &#125;@keyframes animate &#123; 50% &#123; -ms-transform: rotate(180deg); -webkit-transform: rotate(180deg); transform: rotate(180deg); &#125; 100% &#123; -ms-transform: rotate(0deg); -webkit-transform: rotate(0deg); transform: rotate(0deg); &#125; &#125;------------------------------------------- #loading-center&#123; width: 100%; height: 100%; position: relative; &#125; #loading-center-absolute &#123; position: absolute; left: 50%; top: 50%; height: 200px; width: 200px; margin-top: -100px; margin-left: -100px; -ms-transform: rotate(-135deg); -webkit-transform: rotate(-135deg); transform: rotate(-135deg); &#125; .object&#123; -moz-border-radius: 50% 50% 50% 50%; -webkit-border-radius: 50% 50% 50% 50%; border-radius: 50% 50% 50% 50%; position: absolute; border-top: 5px solid #1c8a95; border-bottom: 5px solid transparent; border-left: 5px solid #1c8a95; border-right: 5px solid transparent; -webkit-animation: animate 2s infinite; animation: animate 2s infinite; &#125; #object_one&#123; left: 75px; top: 75px; width: 50px; height: 50px; &#125; #object_two&#123; left: 65px; top: 65px; width: 70px; height: 70px; -webkit-animation-delay: 0.2s; animation-delay: 0.2s; &#125; #object_three&#123; left: 55px; top: 55px; width: 90px; height: 90px; -webkit-animation-delay: 0.4s; animation-delay: 0.4s; &#125; #object_four&#123; left: 45px; top: 45px; width: 110px; height: 110px; -webkit-animation-delay: 0.6s; animation-delay: 0.6s; &#125;","tags":[{"name":"css","slug":"css","permalink":"https://jiaopianjun.cc/tags/css/"}]},{"title":"炫酷 Css3 loading 效果","date":"2018-06-21T10:12:05.000Z","path":"2018/06/21/炫酷-Css3-loading-效果.html","text":"1.HTML123456&lt;div class=\"circle-loader\"&gt; &lt;div class=\"circle-line\"&gt; &lt;div class=\"circle circle-blue\"&gt;&lt;/div&gt; &lt;div class=\"circle circle-blue\"&gt;&lt;/div&gt; &lt;div class=\"circle circle-blue\"&gt;&lt;/div&gt; &lt;/div&gt; 12345678910111213141516 &lt;div class=\"circle-line\"&gt; &lt;div class=\"circle circle-yellow\"&gt;&lt;/div&gt; &lt;div class=\"circle circle-yellow\"&gt;&lt;/div&gt; &lt;div class=\"circle circle-yellow\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"circle-line\"&gt; &lt;div class=\"circle circle-red\"&gt;&lt;/div&gt; &lt;div class=\"circle circle-red\"&gt;&lt;/div&gt; &lt;div class=\"circle circle-red\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"circle-line\"&gt; &lt;div class=\"circle circle-green\"&gt;&lt;/div&gt; &lt;div class=\"circle circle-green\"&gt;&lt;/div&gt; &lt;div class=\"circle circle-green\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 2.CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161@-webkit-keyframes rotate-animation &#123; 0% &#123; -webkit-transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; -webkit-transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;@keyframes rotate-animation &#123; 0% &#123; -webkit-transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; -webkit-transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;@-webkit-keyframes move-animation &#123; 0% &#123; -webkit-transform: translate(0, 0); transform: translate(0, 0); &#125; 25% &#123; -webkit-transform: translate(-64px, 0); transform: translate(-64px, 0); &#125; 75% &#123; -webkit-transform: translate(32px, 0); transform: translate(32px, 0); &#125; 100% &#123; -webkit-transform: translate(0, 0); transform: translate(0, 0); &#125;&#125;@-webkit-keyframes move-animation &#123; 0%&#123; -webkit-transform: translate(0,0);transform: translate(0,0); &#125; &#125;@keyframes move-animation &#123; 0% &#123; -webkit-transform: translate(0, 0); transform: translate(0, 0); &#125; 25% &#123; -webkit-transform: translate(-64px, 0); transform: translate(-64px, 0); &#125; 75% &#123; -webkit-transform: translate(32px, 0); transform: translate(32px, 0); &#125; 100% &#123; -webkit-transform: translate(0, 0); transform: translate(0, 0); &#125;&#125;body &#123; background-color: #F5F5F5;&#125;.circle-loader &#123; display: block; width: 64px; height: 64px; margin-left: -32px; margin-top: -32px; position: absolute; left: 50%; top: 50%; -webkit-transform-origin: 16px 16px; transform-origin: 16px 16px; -webkit-animation: rotate-animation 5s infinite; animation: rotate-animation 5s infinite; -webkit-animation-timing-function: linear; animation-timing-function: linear;&#125;.circle-loader .circle &#123; -webkit-animation: move-animation 2.5s infinite; animation: move-animation 2.5s infinite; -webkit-animation-timing-function: linear; animation-timing-function: linear; position: absolute; left: 50%; top: 50%;&#125;.circle-loader .circle-line &#123; width: 64px; height: 24px; position: absolute; top: 4px; left: 0; -webkit-transform-origin: 4px 4px; transform-origin: 4px 4px;&#125;.circle-loader .circle-line:nth-child(0) &#123; -webkit-transform: rotate(0deg); transform: rotate(0deg);&#125;.circle-loader .circle-line:nth-child(1) &#123; -webkit-transform: rotate(90deg); transform: rotate(90deg);&#125;.circle-loader .circle-line:nth-child(2) &#123; -webkit-transform: rotate(180deg); transform: rotate(180deg);&#125;.circle-loader .circle-line:nth-child(3) &#123; -webkit-transform: rotate(270deg); transform: rotate(270deg);&#125;.circle-loader .circle-line .circle:nth-child(1) &#123; width: 8px; height: 8px; top: 50%; left: 50%; margin-top: -4px; margin-left: -4px; border-radius: 4px; -webkit-animation-delay: -0.3s; animation-delay: -0.3s;&#125;.circle-loader .circle-line .circle:nth-child(2) &#123; width: 16px; height: 16px; top: 50%; left: 50%; margin-top: -8px; margin-left: -8px; border-radius: 8px; -webkit-animation-delay: -0.6s; animation-delay: -0.6s;&#125;.circle-loader .circle-line .circle:nth-child(3) &#123; width: 24px; height: 24px; top: 50%; left: 50%; margin-top: -12px; margin-left: -12px; border-radius: 12px; -webkit-animation-delay: -0.9s; animation-delay: -0.9s;&#125;.circle-loader .circle-blue &#123; background-color: #1f4e5a;&#125;.circle-loader .circle-red &#123; background-color: #ff5955;&#125;.circle-loader .circle-yellow &#123; background-color: #ffb265;&#125;.circle-loader .circle-green &#123; background-color: #00a691;&#125;","tags":[{"name":"css","slug":"css","permalink":"https://jiaopianjun.cc/tags/css/"}]},{"title":"Vue打包相关问题","date":"2018-06-21T01:29:05.000Z","path":"2018/06/21/Vue打包相关问题.html","text":"1.静态资源路径不对1234567891011在build/util.js 文件中在if(options.extract) &#123; retrun ExtractTextPlugin,extract(&#123; use: loaders, publicPath:'../../', //添加这一行 fallback: 'vue-style-loader' &#125;)&#125; else &#123; return ['vue-style-loader'].concat(loaders)&#125; 2.打包后 自定义动画效果消失1234567在build/vue-loader.conf.js中将loaders:utils.cssLoaders(&#123; sourceMap: sourceMapEnabled, extract: isProduction //改为 extract: false&#125;)","tags":[{"name":"vue","slug":"vue","permalink":"https://jiaopianjun.cc/tags/vue/"}]},{"title":"Vue 添加滚动监听","date":"2018-06-20T03:54:50.000Z","path":"2018/06/20/Vue添加滚动监听.html","text":"1234567891011121314151617181920data () &#123; return &#123; scrolled: false &#125;&#125;,ready () &#123; window.addEventListener('scroll', this.handleScroll);&#125;,methods:&#123; handleScroll () &#123; this.scrolled = window.scrollY; console.log(this.scrolled) &#125;,&#125;，destroyed () &#123; window.removeEventListener('scroll', this.handleScroll)&#125;,created: function () &#123; window.addEventListener('scroll', this.handleScroll)&#125;","tags":[{"name":"vue","slug":"vue","permalink":"https://jiaopianjun.cc/tags/vue/"}]},{"title":"Vue 安装 vuex sass 和 引入 Jq","date":"2018-06-14T06:37:48.000Z","path":"2018/06/14/Vue安装vuexsass和引入Jq.html","text":"1.安装vuex1231. npm install vuex --save2. 在src 目录下新建 store 文件夹 123456789101112131415161718192021222324253. 在store 中新建 store.js import Vue from 'vue' import vuex from 'vuex' Vue.use(vuex); import peinfo from './peinfo.js' export default new vuex.Store(&#123; modules:&#123; peinfo:peinfo &#125; &#125;) peinfo.js export default &#123; state: &#123; list: [] &#125;, mutations:&#123; perinfo(state,data)&#123; state.list = data.data &#125; &#125;&#125; 2. 安装sass123456789npm install --save-dev sass-loadernpm install --save-dev node-sass在build文件夹下的webpack.base.conf.js的rules里面添加配置&#123; test: /\\.sass$/, loaders: ['style', 'css', 'sass']&#125; 3. 引入JQ1234567891011121.首先在package.json里的dependencies加入\"jquery\" : \"^3.2.1\",2.npm install jquery -- save-dev3.找到build文件夹下的webpack.base.conf.js文件，打开，添加：var webpack=require('webpack')4.在module.exports里输入： plugins: [ new webpack.optimize.CommonsChunkPlugin('common.js'), new webpack.ProvidePlugin(&#123; jQuery: \"jquery\", $: \"jquery\" &#125;) ],5. 在入口文件main.js中输入： import $ from 'jquery' 4.安装axios12345671. npm install axios2. 在mian.js import axios from 'axios' import VueAxios from 'vue-axios' Vue.use(VueAxios, axios)","tags":[{"name":"vue","slug":"vue","permalink":"https://jiaopianjun.cc/tags/vue/"}]},{"title":"基于Vue的点对点聊天项目","date":"2018-06-14T03:21:11.000Z","path":"2018/06/14/基于Vue的点对点聊天项目.html","text":"前提 一个基于平台内部的聊天项目，需要实现用户之间可以相互聊天发送消息，可以添加好友等功能。且消息必须是实时性的，并且用户下线后再次上线可以接受离线消息。 技术栈Vue.js + Html5 + CSS3 + Sass + Vuex + Axios + Websocket 等 源码Github 项目实例因为项目接口为线上接口 本地运行会报错 你可以将本地loaclhost 地址 指向 stone.snail.com或者直接访问 线上地址 在 另一个项目社区 注册账号 返回后即可体验 技术难点 实现从好友列表到聊天列表的发起 消息的存储 上下线状态的即时变动 收到消息即使提醒以及未读消息的数量 好友删除的通知 等等 项目运行git clone https://github.com/jiaopianjun/echat.gitnpm installnpm run dev 项目截图 1.png 2.png 3.png 4.png 6.png","tags":[]},{"title":"Vue全家桶web端社区项目","date":"2018-06-14T03:20:54.000Z","path":"2018/06/14/Vue全家桶web端社区项目.html","text":"前提项目需求：建立一个平台能够提供给玩家交流的地方。 功能需求 一个聚合页面，提供当前最新的帖子 个人模块：显示头像，个人昵称，个人已经加入的主题 热门讨论： 提供热门帖子 主题推荐 主题页面： 显示当前主题下 的帖子， 可提供 精华 攻略 等小标签的分类 可以 选择 时间 热门 进行排序 帖子页面： 显示 当前帖子的标签 如 官方 置顶 等。 同时分权限等级 可以 进行 置顶 删除等操作 评论： 可以对当前帖子进行评论，也可以对某条帖子进行评论，也可以回复其他评论者 帖子发表： 可以选择 帖子类型 标签等 技术栈Vue + Js + Sass + Css3 + Vue-resouse 等 源码Github 项目地址可以直接访问线上地址 社区 注册后 登录 即可 体验 发帖 回帖 等操作 项目运行 git clone https://github.com/jiaopianjun/social.git npm install npm run dev项目截图 首页 主题首页 发帖页面 回帖操作 权限管理","tags":[]},{"title":"常用css代码片段（二）","date":"2018-06-13T06:20:04.000Z","path":"2018/06/13/常用css代码片段(二).html","text":"1.限制单行文本超出显示省略号123456789div&#123; width: 65px; height: 30px; line-height: 30px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 14px;&#125; 2.限制多行文本超出省略号1234567div&#123; overflow : hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;&#125; 3.css三角形绘制123456789101112131415161718192021222324252627282930313233/*向上*/.div&#123; width:0; height:0; border-width:0 30px 30px; border-style:solid; border-color:transparent transparent #333;/*透明 透明 灰*/&#125;/*向下*/.div&#123; width:0; height:0; border-width:30px 30px 0; border-style:solid; border-color:#333 transparent transparent;/*灰 透明 透明 */&#125;/*向左*/.div&#123; width:0; height:0; border-width:30px 30px 30px 0; border-style:solid; border-color:transparent #333 transparent transparent;/*透明 灰 透明 透明 */&#125;/*向右*/.div span&#123; display:block; width:0; height:0; border-width:28px 0 28px 28px; border-style:solid; border-color:transparent transparent transparent #fc0;/*透明 透明 透明 黄*/&#125; 4.自适应文本框自动换行，限宽不限高123456789div&#123; display: inline-block; min-height: 15px; max-width: 78%; padding: 12px 10px; text-align: left; font-family: Microsoft YaHei; word-wrap: break-word;&#125;","tags":[{"name":"css","slug":"css","permalink":"https://jiaopianjun.cc/tags/css/"}]},{"title":"常用CSS代码片段（一）","date":"2018-06-13T06:06:28.000Z","path":"2018/06/13/常用CSS代码片段(一).html","text":"1、垂直对齐1234567.verticalcenter&#123; position: relative; top: 50%; -webkit-transform: translateY(-50%); -o-transform: translateY(-50%); transform: translateY(-50%);&#125; 2、伸展一个元素到窗口高度 1234567html, body &#123; height: 100%;&#125;div &#123; height: 100%;&#125; 3、基于文件格式使用不同的样式123456789101112131415a[href^=\"http://\"]&#123; padding-right: 20px; background: url(external.gif) no-repeat center right;&#125;/* emails */a[href^=\"mailto:\"]&#123; padding-right: 20px; background: url(email.png) no-repeat center right;&#125;/* pdfs */a[href$=\".pdf\"]&#123; padding-right: 20px; background: url(pdf.png) no-repeat center right;&#125; 4、创建跨浏览器的图像灰度1234567891011&lt;svg xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;filter id=\"grayscale\"&gt; &lt;feColorMatrix type=\"matrix\" values=\"0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\"/&gt; &lt;/filter&gt;&lt;/svg&gt;img &#123; filter: url(filters.svg#grayscale); /* Firefox 3.5+ */ filter: gray; /* IE6-9 */ -webkit-filter: grayscale(1); /* Google Chrome, Safari 6+ &amp; Opera 15+ */&#125; 5、背景渐变动画123456789button &#123; background-image: linear-gradient(#5187c4, #1c2f45); background-size: auto 200%; background-position: 0 100%; transition: background-position 0.5s;&#125; button:hover &#123; background-position: 0 0;&#125; 6、CSS：表格列宽自适用123456789101112131415161718192021222324.box-shadow &#123; background-color: #FF8020; width: 160px; height: 90px; margin-top: -45px; margin-left: -80px; position: absolute; top: 50%; left: 50%;&#125;.box-shadow:after &#123; content: \"\"; width: 150px; height: 1px; margin-top: 88px; margin-left: -75px; display: block; position: absolute; left: 50%; z-index: -1; -webkit-box-shadow: 0px 0px 8px 2px #000000; -moz-box-shadow: 0px 0px 8px 2px #000000; box-shadow: 0px 0px 8px 2px #000000;&#125; 8、包裹长文本 image 1234pre &#123; white-space: pre-line; word-wrap: break-word;&#125; 9、制造模糊文本1234.blurry-text &#123; color: transparent; text-shadow: 0 0 5px rgba(0,0,0,0.5);&#125; 10、用CSS动画实现省略号动画123456789101112131415.loading:after &#123; overflow: hidden; display: inline-block; vertical-align: bottom; animation: ellipsis 2s infinite; content: \"\\2026\"; /* ascii code for the ellipsis character */&#125;@keyframes ellipsis &#123; from &#123; width: 2px; &#125; to &#123; width: 15px; &#125;&#125; 11、样式重置12345678910111213141516171819202122html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; outline: none; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125;html &#123; height: 101%; &#125;body &#123; font-size: 62.5%; line-height: 1; font-family: Arial, Tahoma, sans-serif; &#125;article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section &#123; display: block; &#125;ol, ul &#123; list-style: none; &#125;blockquote, q &#123; quotes: none; &#125;blockquote:before, blockquote:after, q:before, q:after &#123; content: ''; content: none; &#125;strong &#123; font-weight: bold; &#125; table &#123; border-collapse: collapse; border-spacing: 0; &#125;img &#123; border: 0; max-width: 100%; &#125;p &#123; font-size: 1.2em; line-height: 1.0em; color: #333; &#125; 12、典型的CSS清除浮动1234.clearfix:after &#123; content: \".\"; display: block; clear: both; visibility: hidden; line-height: 0; height: 0; &#125;.clearfix &#123; display: inline-block; &#125;html[xmlns] .clearfix &#123; display: block; &#125;* html .clearfix &#123; height: 1%; &#125; 13、新版清除浮动（2011）1234.clearfix:before, .container:after &#123; content: \"\"; display: table; &#125;.clearfix:after &#123; clear: both; &#125;/* IE 6/7 */.clearfix &#123; zoom: 1; &#125; 14、跨浏览器的透明123456.transparent &#123; filter: alpha(opacity=50); /* internet explorer */ -khtml-opacity: 0.5; /* khtml, old safari */ -moz-opacity: 0.5; /* mozilla, netscape */ opacity: 0.5; /* fx, safari, opera */&#125; 15、CSS引用模板123456789101112131415161718blockquote &#123; background: #f9f9f9; border-left: 10px solid #ccc; margin: 1.5em 10px; padding: .5em 10px; quotes: \"\\201C\"\"\\201D\"\"\\2018\"\"\\2019\";&#125;blockquote:before &#123; color: #ccc; content: open-quote; font-size: 4em; line-height: .1em; margin-right: .25em; vertical-align: -.4em;&#125;blockquote p &#123; display: inline;&#125; 16、个性圆角1234567891011121314151617#container &#123; -webkit-border-radius: 4px 3px 6px 10px; -moz-border-radius: 4px 3px 6px 10px; -o-border-radius: 4px 3px 6px 10px; border-radius: 4px 3px 6px 10px;&#125;/* alternative syntax broken into each line */#container &#123; -webkit-border-top-left-radius: 4px; -webkit-border-top-right-radius: 3px; -webkit-border-bottom-right-radius: 6px; -webkit-border-bottom-left-radius: 10px; -moz-border-radius-topleft: 4px; -moz-border-radius-topright: 3px; -moz-border-radius-bottomright: 6px; -moz-border-radius-bottomleft: 10px;&#125; 17、通用媒体查询12345678910111213141516171819202122232425262728293031323334353637/* Smartphones (portrait and landscape) ----------- */@media only screen and (min-device-width : 320px) and (max-device-width : 480px) &#123; /* Styles */&#125;/* Smartphones (landscape) ----------- */@media only screen and (min-width : 321px) &#123; /* Styles */&#125;/* Smartphones (portrait) ----------- */@media only screen and (max-width : 320px) &#123; /* Styles */&#125;/* iPads (portrait and landscape) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) &#123; /* Styles */&#125;/* iPads (landscape) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : landscape) &#123; /* Styles */&#125;/* iPads (portrait) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : portrait) &#123; /* Styles */&#125;/* Desktops and laptops ----------- */@media only screen and (min-width : 1224px) &#123; /* Styles */&#125;/* Large screens ----------- */@media only screen and (min-width : 1824px) &#123; /* Styles */&#125;/* iPhone 4 ----------- */@media only screen and (-webkit-min-device-pixel-ratio:1.5), only screen and (min-device-pixel-ratio:1.5) &#123; /* Styles */&#125; 18、现代字体栈12345678910111213141516* Times New Roman-based serif */font-family: Cambria, \"Hoefler Text\", Utopia, \"Liberation Serif\", \"Nimbus Roman No9 L Regular\", Times, \"Times New Roman\", serif;/* A modern Georgia-based serif */font-family: Constantia, \"Lucida Bright\", Lucidabright, \"Lucida Serif\", Lucida, \"DejaVu Serif,\" \"Bitstream Vera Serif\", \"Liberation Serif\", Georgia, serif;/*A more traditional Garamond-based serif */font-family: \"Palatino Linotype\", Palatino, Palladio, \"URW Palladio L\", \"Book Antiqua\", Baskerville, \"Bookman Old Style\", \"Bitstream Charter\", \"Nimbus Roman No9 L\", Garamond, \"Apple Garamond\", \"ITC Garamond Narrow\", \"New Century Schoolbook\", \"Century Schoolbook\", \"Century Schoolbook L\", Georgia, serif;/*The Helvetica/Arial-based sans serif */font-family: Frutiger, \"Frutiger Linotype\", Univers, Calibri, \"Gill Sans\", \"Gill Sans MT\", \"Myriad Pro\", Myriad, \"DejaVu Sans Condensed\", \"Liberation Sans\", \"Nimbus Sans L\", Tahoma, Geneva, \"Helvetica Neue\", Helvetica, Arial, sans-serif;/*The Verdana-based sans serif */font-family: Corbel, \"Lucida Grande\", \"Lucida Sans Unicode\", \"Lucida Sans\", \"DejaVu Sans\", \"Bitstream Vera Sans\", \"Liberation Sans\", Verdana, \"Verdana Ref\", sans-serif;/*The Trebuchet-based sans serif */font-family: \"Segoe UI\", Candara, \"Bitstream Vera Sans\", \"DejaVu Sans\", \"Bitstream Vera Sans\", \"Trebuchet MS\", Verdana, \"Verdana Ref\", sans-serif;/*The heavier \"Impact\" sans serif */font-family: Impact, Haettenschweiler, \"Franklin Gothic Bold\", Charcoal, \"Helvetica Inserat\", \"Bitstream Vera Sans Bold\", \"Arial Black\", sans-serif;/*The monospace */font-family: Consolas, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", Monaco, \"Courier New\", Courier, monospace; 19、自定义文本选择123::selection &#123; background: #e2eae2; &#125;::-moz-selection &#123; background: #e2eae2; &#125;::-webkit-selection &#123; background: #e2eae2; &#125; 20、为logo隐藏H11234567h1 &#123; text-indent: -9999px; margin: 0 auto; width: 320px; height: 85px; background: transparent url(\"images/logo.png\") no-repeat scroll;&#125; 21、图片边框偏光12345678910img.polaroid &#123; background:#000; /*Change this to a background image or remove*/ border:solid #fff; border-width:6px 6px 20px 6px; box-shadow:1px 1px 5px #333; /* Standard blur at 5px. Increase for more depth */ -webkit-box-shadow:1px 1px 5px #333; -moz-box-shadow:1px 1px 5px #333; height:200px; /*Set to height of your image or desired div*/ width:200px; /*Set to width of your image or desired div*/&#125; 22、锚链接伪类1234a:link &#123; color: blue; &#125;a:visited &#123; color: purple; &#125;a:hover &#123; color: red; &#125;a:active &#123; color: yellow; &#125; 23、奇特的CSS引用1234567891011121314151617181920212223242526272829303132.has-pullquote:before &#123; /* Reset metrics. */ padding: 0; border: none; /* Content */ content: attr(data-pullquote); /* Pull out to the right, modular scale based margins. */ float: right; width: 320px; margin: 12px -140px 24px 36px; /* Baseline correction */ position: relative; top: 5px; /* Typography (30px line-height equals 25% incremental leading) */ font-size: 23px; line-height: 30px;&#125;.pullquote-adelle:before &#123; font-family: \"adelle-1\", \"adelle-2\"; font-weight: 100; top: 10px !important;&#125;.pullquote-helvetica:before &#123; font-family: \"Helvetica Neue\", Arial, sans-serif; font-weight: bold; top: 7px !important;&#125;.pullquote-facit:before &#123; font-family: \"facitweb-1\", \"facitweb-2\", Helvetica, Arial, sans-serif; font-weight: bold; top: 7px !important;&#125; 24、CSS3：全屏背景1234567html &#123; background: url('images/bg.jpg') no-repeat center center fixed; -webkit-background-size: cover; -moz-background-size: cover; -o-background-size: cover; background-size: cover;&#125; 25、内容垂直居中12345.container &#123; min-height: 6.5em; display: table-cell; vertical-align: middle;&#125; 26、强制出现垂直滚动条1html &#123; height: 101% &#125; 27、CSS3渐变模板123456789#colorbox &#123; background: #629721; background-image: -webkit-gradient(linear, left top, left bottom, from(#83b842), to(#629721)); background-image: -webkit-linear-gradient(top, #83b842, #629721); background-image: -moz-linear-gradient(top, #83b842, #629721); background-image: -ms-linear-gradient(top, #83b842, #629721); background-image: -o-linear-gradient(top, #83b842, #629721); background-image: linear-gradient(top, #83b842, #629721);&#125; 28、@font-face模板1234567891011@font-face &#123; font-family: 'MyWebFont'; src: url('webfont.eot'); /* IE9 Compat Modes */ src: url('webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('webfont.woff') format('woff'), /* Modern Browsers */ url('webfont.ttf') format('truetype'), /* Safari, Android, iOS */ url('webfont.svg#svgFontName') format('svg'); /* Legacy iOS */&#125;body &#123; font-family: 'MyWebFont', Arial, sans-serif;&#125; 29、缝合CSS3元素123456789101112131415161718192021222324252627282930313233p &#123; position:relative; z-index:1; padding: 10px; margin: 10px; font-size: 21px; line-height: 1.3em; color: #fff; background: #ff0030; -webkit-box-shadow: 0 0 0 4px #ff0030, 2px 1px 4px 4px rgba(10,10,0,.5); -moz-box-shadow: 0 0 0 4px #ff0030, 2px 1px 4px 4px rgba(10,10,0,.5); box-shadow: 0 0 0 4px #ff0030, 2px 1px 6px 4px rgba(10,10,0,.5); -webkit-border-radius: 3px; -moz-border-radius: 3px; border-radius: 3px;&#125;p:before &#123; content: \"\"; position: absolute; z-index: -1; top: 3px; bottom: 3px; left :3px; right: 3px; border: 2px dashed #fff;&#125;p a &#123; color: #fff; text-decoration:none;&#125;p a:hover, p a:focus, p a:active &#123; text-decoration:underline;&#125; 30、CSS3 斑马线123tbody tr:nth-child(odd) &#123; background-color: #ccc;&#125; 31、有趣的&amp;12345.amp &#123; font-family: Baskerville, 'Goudy Old Style', Palatino, 'Book Antiqua', serif; font-style: italic; font-weight: normal;&#125; 32、大字段落12345678p:first-letter&#123; display: block; margin: 5px 0 0 5px; float: left; color: #ff3366; font-size: 5.4em; font-family: Georgia, Times New Roman, serif;&#125; 33、内部CSS3 盒阴影12345#mydiv &#123; -moz-box-shadow: inset 2px 0 4px #000; -webkit-box-shadow: inset 2px 0 4px #000; box-shadow: inset 2px 0 4px #000;&#125; 34、外部CSS3 盒阴影12345#mydiv &#123; -webkit-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52); -moz-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52); box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52);&#125; 35、三角形列表项目符号1234567891011121314151617ul &#123; margin: 0.75em 0; padding: 0 1em; list-style: none;&#125;li:before &#123; content: \"\"; border-color: transparent #111; border-style: solid; border-width: 0.35em 0 0.35em 0.45em; display: block; height: 0; width: 0; left: -1em; top: 0.9em; position: relative;&#125; 36、固定宽度的居中布局1234#page-wrap &#123; width: 800px; margin: 0 auto;&#125; 37、CSS3 列文本123456789#columns-3 &#123; text-align: justify; -moz-column-count: 3; -moz-column-gap: 12px; -moz-column-rule: 1px solid #c4c8cc; -webkit-column-count: 3; -webkit-column-gap: 12px; -webkit-column-rule: 1px solid #c4c8cc;&#125; 38、CSS固定页脚12345678910111213#footer &#123; position: fixed; left: 0px; bottom: 0px; height: 30px; width: 100%; background: #444;&#125;/* IE 6 */* html #footer &#123; position: absolute; top: expression((0-(footer.offsetHeight)+(document.documentElement.clientHeight ? document.documentElement.clientHeight : document.body.clientHeight)+(ignoreMe = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop))+'px');&#125; 39、IE6的PNG透明修复12345678910111213141516.bg &#123; width:200px; height:100px; background: url(/folder/yourimage.png) no-repeat; _background:none; _filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='/folder/yourimage.png',sizingMethod='crop');&#125;/* 1px gif method */img, .png &#123; position: relative; behavior: expression((this.runtimeStyle.behavior=\"none\")&amp;&amp;(this.pngSet?this.pngSet=true:(this.nodeName == \"IMG\" &amp;&amp; this.src.toLowerCase().indexOf('.png')&gt;-1?(this.runtimeStyle.backgroundImage = \"none\", this.runtimeStyle.filter = \"progid:DXImageTransform.Microsoft.AlphaImageLoader(src='\" + this.src + \"', sizingMethod='image')\", this.src = \"images/transparent.gif\"):(this.origBg = this.origBg? this.origBg :this.currentStyle.backgroundImage.toString().replace('url(\"','').replace('\")',''), this.runtimeStyle.filter = \"progid:DXImageTransform.Microsoft.AlphaImageLoader(src='\" + this.origBg + \"', sizingMethod='crop')\", this.runtimeStyle.backgroundImage = \"none\")),this.pngSet=true));&#125; 40、跨浏览器设置最小高度12345#container &#123; min-height: 550px; height: auto !important; height: 550px;&#125; 41、CSS3 鲜艳的输入12345678910111213141516input[type=text], textarea &#123; -webkit-transition: all 0.30s ease-in-out; -moz-transition: all 0.30s ease-in-out; -ms-transition: all 0.30s ease-in-out; -o-transition: all 0.30s ease-in-out; outline: none; padding: 3px 0px 3px 3px; margin: 5px 1px 3px 0px; border: 1px solid #ddd;&#125;input[type=text]:focus, textarea:focus &#123; box-shadow: 0 0 5px rgba(81, 203, 238, 1); padding: 3px 0px 3px 3px; margin: 5px 1px 3px 0px; border: 1px solid rgba(81, 203, 238, 1);&#125; 42、基于文件类型的链接样式123456789101112131415/* external links */a[href^=\"http://\"] &#123; padding-right: 13px; background: url('external.gif') no-repeat center right;&#125;/* emails */a[href^=\"mailto:\"] &#123; padding-right: 20px; background: url('email.png') no-repeat center right;&#125;/* pdfs */a[href$=\".pdf\"] &#123; padding-right: 18px; background: url('acrobat.png') no-repeat center right;&#125; 43、强制换行1234567pre &#123; white-space: pre-wrap; /* css-3 */ white-space: -moz-pre-wrap; /* Mozilla, since 1999 */ white-space: -pre-wrap; /* Opera 4-6 */ white-space: -o-pre-wrap; /* Opera 7 */ word-wrap: break-word; /* Internet Explorer 5.5+ */&#125; 44、在可点击的项目上强制手型123a[href], input[type='submit'], input[type='image'], label[for], select, button, .pointer &#123; cursor: pointer;&#125; 45、网页顶部盒阴影123456789101112body:before &#123; content: \"\"; position: fixed; top: -10px; left: 0; width: 100%; height: 10px; -webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8); -moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8); box-shadow: 0px 0px 10px rgba(0,0,0,.8); z-index: 100;&#125; 46、CSS3对话气泡123456789101112131415161718192021222324252627282930313233343536.chat-bubble &#123; background-color: #ededed; border: 2px solid #666; font-size: 35px; line-height: 1.3em; margin: 10px auto; padding: 10px; position: relative; text-align: center; width: 300px; -moz-border-radius: 20px; -webkit-border-radius: 20px; -moz-box-shadow: 0 0 5px #888; -webkit-box-shadow: 0 0 5px #888; font-family: 'Bangers', arial, serif; &#125;.chat-bubble-arrow-border &#123; border-color: #666 transparent transparent transparent; border-style: solid; border-width: 20px; height: 0; width: 0; position: absolute; bottom: -42px; left: 30px;&#125;.chat-bubble-arrow &#123; border-color: #ededed transparent transparent transparent; border-style: solid; border-width: 20px; height: 0; width: 0; position: absolute; bottom: -39px; left: 30px;&#125; 47、H1-H5默认样式1234567891011121314151617181920212223h1,h2,h3,h4,h5&#123; color: #005a9c;&#125;h1&#123; font-size: 2.6em; line-height: 2.45em;&#125;h2&#123; font-size: 2.1em; line-height: 1.9em;&#125;h3&#123; font-size: 1.8em; line-height: 1.65em;&#125;h4&#123; font-size: 1.65em; line-height: 1.4em;&#125;h5&#123; font-size: 1.4em; line-height: 1.25em;&#125; ###### 48、纯CSS背景噪音1234body &#123; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEWFhYWDg4N3d3dtbW17e3t1dXWBgYGHh4d5eXlzc3OLi4ubm5uVlZWPj4+NjY19fX2JiYl/f39ra2uRkZGZmZlpaWmXl5dvb29xcXGTk5NnZ2c8TV1mAAAAG3RSTlNAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAvEOwtAAAFVklEQVR4XpWWB67c2BUFb3g557T/hRo9/WUMZHlgr4Bg8Z4qQgQJlHI4A8SzFVrapvmTF9O7dmYRFZ60YiBhJRCgh1FYhiLAmdvX0CzTOpNE77ME0Zty/nWWzchDtiqrmQDeuv3powQ5ta2eN0FY0InkqDD73lT9c9lEzwUNqgFHs9VQce3TVClFCQrSTfOiYkVJQBmpbq2L6iZavPnAPcoU0dSw0SUTqz/GtrGuXfbyyBniKykOWQWGqwwMA7QiYAxi+IlPdqo+hYHnUt5ZPfnsHJyNiDtnpJyayNBkF6cWoYGAMY92U2hXHF/C1M8uP/ZtYdiuj26UdAdQQSXQErwSOMzt/XWRWAz5GuSBIkwG1H3FabJ2OsUOUhGC6tK4EMtJO0ttC6IBD3kM0ve0tJwMdSfjZo+EEISaeTr9P3wYrGjXqyC1krcKdhMpxEnt5JetoulscpyzhXN5FRpuPHvbeQaKxFAEB6EN+cYN6xD7RYGpXpNndMmZgM5Dcs3YSNFDHUo2LGfZuukSWyUYirJAdYbF3MfqEKmjM+I2EfhA94iG3L7uKrR+GdWD73ydlIB+6hgref1QTlmgmbM3/LeX5GI1Ux1RWpgxpLuZ2+I+IjzZ8wqE4nilvQdkUdfhzI5QDWy+kw5Wgg2pGpeEVeCCA7b85BO3F9DzxB3cdqvBzWcmzbyMiqhzuYqtHRVG2y4x+KOlnyqla8AoWWpuBoYRxzXrfKuILl6SfiWCbjxoZJUaCBj1CjH7GIaDbc9kqBY3W/Rgjda1iqQcOJu2WW+76pZC9QG7M00dffe9hNnseupFL53r8F7YHSwJWUKP2q+k7RdsxyOB11n0xtOvnW4irMMFNV4H0uqwS5ExsmP9AxbDTc9JwgneAT5vTiUSm1E7BSflSt3bfa1tv8Di3R8n3Af7MNWzs49hmauE2wP+ttrq+AsWpFG2awvsuOqbipWHgtuvuaAE+A1Z/7gC9hesnr+7wqCwG8c5yAg3AL1fm8T9AZtp/bbJGwl1pNrE7RuOX7PeMRUERVaPpEs+yqeoSmuOlokqw49pgomjLeh7icHNlG19yjs6XXOMedYm5xH2YxpV2tc0Ro2jJfxC50ApuxGob7lMsxfTbeUv07TyYxpeLucEH1gNd4IKH2LAg5TdVhlCafZvpskfncCfx8pOhJzd76bJWeYFnFciwcYfubRc12Ip/ppIhA1/mSZ/RxjFDrJC5xifFjJpY2Xl5zXdguFqYyTR1zSp1Y9p+tktDYYSNflcxI0iyO4TPBdlRcpeqjK/piF5bklq77VSEaA+z8qmJTFzIWiitbnzR794USKBUaT0NTEsVjZqLaFVqJoPN9ODG70IPbfBHKK+/q/AWR0tJzYHRULOa4MP+W/HfGadZUbfw177G7j/OGbIs8TahLyynl4X4RinF793Oz+BU0saXtUHrVBFT/DnA3ctNPoGbs4hRIjTok8i+algT1lTHi4SxFvONKNrgQFAq2/gFnWMXgwffgYMJpiKYkmW3tTg3ZQ9Jq+f8XN+A5eeUKHWvJWJ2sgJ1Sop+wwhqFVijqWaJhwtD8MNlSBeWNNWTa5Z5kPZw5+LbVT99wqTdx29lMUH4OIG/D86ruKEauBjvH5xy6um/Sfj7ei6UUVk4AIl3MyD4MSSTOFgSwsH/QJWaQ5as7ZcmgBZkzjjU1UrQ74ci1gWBCSGHtuV1H2mhSnO3Wp/3fEV5a+4wz//6qy8JxjZsmxxy5+4w9CDNJY09T072iKG0EnOS0arEYgXqYnXcYHwjTtUNAcMelOd4xpkoqiTYICWFq0JSiPfPDQdnt+4/wuqcXY47QILbgAAAABJRU5ErkJggg==); background-color: #0094d0;&#125; 49、持久的列表排序1234567891011121314151617181920ol.chapters &#123; list-style: none; margin-left: 0;&#125;ol.chapters &gt; li:before &#123; content: counter(chapter) \". \"; counter-increment: chapter; font-weight: bold; float: left; width: 40px;&#125;ol.chapters li &#123; clear: left;&#125;ol.start &#123; counter-reset: chapter;&#125;ol.continue &#123; counter-reset: chapter 11;&#125; 50、CSS悬浮提示文本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061a &#123; border-bottom:1px solid #bbb; color:#666; display:inline-block; position:relative; text-decoration:none;&#125;a:hover,a:focus &#123; color:#36c;&#125;a:active &#123; top:1px; &#125;/* Tooltip styling */a[data-tooltip]:after &#123; border-top: 8px solid #222; border-top: 8px solid hsla(0,0%,0%,.85); border-left: 8px solid transparent; border-right: 8px solid transparent; content: \"\"; display: none; height: 0; width: 0; left: 25%; position: absolute;&#125;a[data-tooltip]:before &#123; background: #222; background: hsla(0,0%,0%,.85); color: #f6f6f6; content: attr(data-tooltip); display: none; font-family: sans-serif; font-size: 14px; height: 32px; left: 0; line-height: 32px; padding: 0 15px; position: absolute; text-shadow: 0 1px 1px hsla(0,0%,0%,1); white-space: nowrap; -webkit-border-radius: 5px; -moz-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px;&#125;a[data-tooltip]:hover:after &#123; display: block; top: -9px;&#125;a[data-tooltip]:hover:before &#123; display: block; top: -41px;&#125;a[data-tooltip]:active:after &#123; top: -10px;&#125;a[data-tooltip]:active:before &#123; top: -42px;&#125; 51、深灰色的圆形按钮12345678910111213141516171819202122232425262728293031.graybtn &#123; -moz-box-shadow:inset 0px 1px 0px 0px #ffffff; -webkit-box-shadow:inset 0px 1px 0px 0px #ffffff; box-shadow:inset 0px 1px 0px 0px #ffffff; background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #ffffff), color-stop(1, #d1d1d1) ); background:-moz-linear-gradient( center top, #ffffff 5%, #d1d1d1 100% ); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffff', endColorstr='#d1d1d1'); background-color:#ffffff; -moz-border-radius:6px; -webkit-border-radius:6px; border-radius:6px; border:1px solid #dcdcdc; display:inline-block; color:#777777; font-family:arial; font-size:15px; font-weight:bold; padding:6px 24px; text-decoration:none; text-shadow:1px 1px 0px #ffffff;&#125;.graybtn:hover &#123; background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #d1d1d1), color-stop(1, #ffffff) ); background:-moz-linear-gradient( center top, #d1d1d1 5%, #ffffff 100% ); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#d1d1d1', endColorstr='#ffffff'); background-color:#d1d1d1;&#125;.graybtn:active &#123; position:relative; top:1px;&#125; 52、在可打印的网页中显示URLs12345@media print &#123; a:after &#123; content: \" [\" attr(href) \"] \"; &#125; &#125; 53、禁用移动Webkit的选择高亮12345678body &#123; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;&#125; 54、CSS3 圆点图案12345body &#123; background: radial-gradient(circle, white 10%, transparent 10%), radial-gradient(circle, white 10%, black 10%) 50px 50px; background-size: 100px 100px;&#125; 55、CSS3 方格图案1234567body &#123; background-color: white; background-image: linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black), linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black); background-size: 100px 100px; background-position: 0 0, 50px 50px;&#125; 56、Github的fork色带1234567891011121314151617181920212223242526.ribbon &#123; background-color: #a00; overflow: hidden; /* top left corner */ position: absolute; left: -3em; top: 2.5em; /* 45 deg ccw rotation */ -moz-transform: rotate(-45deg); -webkit-transform: rotate(-45deg); /* shadow */ -moz-box-shadow: 0 0 1em #888; -webkit-box-shadow: 0 0 1em #888;&#125;.ribbon a &#123; border: 1px solid #faa; color: #fff; display: block; font: bold 81.25% 'Helvetiva Neue', Helvetica, Arial, sans-serif; margin: 0.05em 0 0.075em 0; padding: 0.5em 3.5em; text-align: center; text-decoration: none; /* shadow */ text-shadow: 0 0 0.5em #444;&#125; 57、CSS font属性缩写123p &#123; font: italic small-caps bold 1.2em/1.0em Arial, Tahoma, Helvetica;&#125; 58、论文页面的卷曲效果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950ul.box &#123; position: relative; z-index: 1; /* prevent shadows falling behind containers with backgrounds */ overflow: hidden; list-style: none; margin: 0; padding: 0; &#125;ul.box li &#123; position: relative; float: left; width: 250px; height: 150px; padding: 0; border: 1px solid #efefef; margin: 0 30px 30px 0; background: #fff; -webkit-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; -moz-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; &#125;ul.box li:before,ul.box li:after &#123; content: ''; z-index: -1; position: absolute; left: 10px; bottom: 10px; width: 70%; max-width: 300px; /* avoid rotation causing ugly appearance at large container widths */ max-height: 100px; height: 55%; -webkit-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); -moz-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); -webkit-transform: skew(-15deg) rotate(-6deg); -moz-transform: skew(-15deg) rotate(-6deg); -ms-transform: skew(-15deg) rotate(-6deg); -o-transform: skew(-15deg) rotate(-6deg); transform: skew(-15deg) rotate(-6deg); &#125;ul.box li:after &#123; left: auto; right: 10px; -webkit-transform: skew(15deg) rotate(6deg); -moz-transform: skew(15deg) rotate(6deg); -ms-transform: skew(15deg) rotate(6deg); -o-transform: skew(15deg) rotate(6deg); transform: skew(15deg) rotate(6deg); &#125; 59、鲜艳的锚链接123456789101112131415161718192021222324a &#123; color: #00e;&#125;a:visited &#123; color: #551a8b;&#125;a:hover &#123; color: #06e;&#125;a:focus &#123; outline: thin dotted;&#125;a:hover, a:active &#123; outline: 0;&#125;a, a:visited, a:active &#123; text-decoration: none; color: #fff; -webkit-transition: all .3s ease-in-out;&#125;a:hover, .glow &#123; color: #ff0; text-shadow: 0 0 10px #ff0;&#125; 60、带CSS3特色的横幅显示12345678910111213141516171819202122232425262728.featureBanner &#123; position: relative; margin: 20px&#125;.featureBanner:before &#123; content: \"Featured\"; position: absolute; top: 5px; left: -8px; padding-right: 10px; color: #232323; font-weight: bold; height: 0px; border: 15px solid #ffa200; border-right-color: transparent; line-height: 0px; box-shadow: -0px 5px 5px -5px #000; z-index: 1;&#125;.featureBanner:after &#123; content: \"\"; position: absolute; top: 35px; left: -8px; border: 4px solid #89540c; border-left-color: transparent; border-bottom-color: transparent;&#125; 转载于博客http://blog.poetries.top","tags":[{"name":"css","slug":"css","permalink":"https://jiaopianjun.cc/tags/css/"}]},{"title":"面试题（一）","date":"2018-06-11T10:02:27.000Z","path":"2018/06/11/面试题一.html","text":"HTML Doctype作用？严格模式与混杂模式如何区分？它们有何意义? HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？ 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 页面导入样式时，使用link和@import有什么区别？ 介绍一下你对浏览器内核的理解？ 常见的浏览器内核有哪些？ html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ 简述一下你对HTML语义化的理解？ HTML5的离线储存怎么使用，工作原理能不能解释一下？ 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？ 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ iframe有那些缺点？ Label的作用是什么？是怎么用的？（加 for 或 包裹） HTML5的form如何关闭自动完成功能？ 如何实现浏览器内多个标签页之间的通信? (阿里) webSocket如何兼容低浏览器？(阿里) 页面可见性（Page Visibility）API 可以有哪些用途？ 如何在页面上实现一个圆形的可点击区域？ 实现不使用 border 画出1px高的线，在不同浏览器的Quirksmode和CSSCompat模式下都能保持同一效果。 网页验证码是干嘛的，是为了解决什么安全问题？ tite与h1的区别、b与strong的区别、i与em的区别？ CSS 介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？ CSS选择符有哪些？哪些属性可以继承？ CSS优先级算法如何计算？ CSS3新增伪类有那些？ 如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？ display有哪些值？说明他们的作用。 position的值relative和absolute定位原点是？ CSS3有哪些新特性？ 请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？ 用纯CSS创建一个三角形的原理是什么？ 一个满屏 品 字布局 如何设计? 常见兼容性问题？ li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？ 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？ 为什么要初始化CSS样式。 absolute的containing block计算方式跟正常流有什么不同？ CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？ position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？ 对BFC规范(块级格式化上下文：block formatting context)的理解？ CSS权重优先级是如何计算的？ 请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式 移动端的布局用过媒体查询吗？ 使用 CSS 预处理器吗？喜欢那个？ CSS优化、提高性能的方法有哪些？ 浏览器是怎样解析CSS选择器的？ 在网页中的应该使用奇数还是偶数的字体？为什么呢？ margin和padding分别适合什么场景使用？ 抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题] 元素竖向的百分比设定是相对于容器的高度吗？ 全屏滚动的原理是什么？用到了CSS的那些属性？ 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？ 视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？） ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。 如何修改chrome记住密码后自动填充表单的黄色背景 ？ 你对line-height是如何理解的？ 设置元素浮动后，该元素的display值是多少？（自动变成display:block） 怎么让Chrome支持小于12px 的文字？ 让页面里的字体变清晰，变细用CSS怎么做？（-webkit-font-smoothing: antialiased;） font-style属性可以让它赋值为“oblique” oblique是什么意思？ position:fixed;在android下无效怎么处理？ 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里） display:inline-block 什么时候会显示间隙？(携程 overflow: scroll时不能平滑滚动的问题怎么处理？ 有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。 png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？ 什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做） style标签写在body后与body前有什么区别？ JavaScript 介绍JavaScript的基本数据类型。 说说写JavaScript的基本规范？ JavaScript原型，原型链 ? 有什么特点？ JavaScript有几种类型的值？（堆：原始数据类型和 栈：引用数据类型），你能画一下他们的内存图吗？ Javascript如何实现继承？ Javascript创建对象的几种方式？ Javascript作用链域? 谈谈This对象的理解。 eval是做什么的？ 什么是window对象? 什么是document对象? null，undefined的区别？ 写一个通用的事件侦听器函数(机试题)。 [“1”, “2”, “3”].map(parseInt) 答案是多少？ 关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 什么是闭包（closure），为什么要用它？ javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ 如何判断一个对象是否属于某个类？ new操作符具体干了什么呢? 用原生JavaScript的实现过什么功能吗？ Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？ 对JSON的了解？ [].forEach.call($$(““),function(a){ a.style.outline=”1px solid #”+(~~(Math.random()(1&lt;&lt;24))).toString(16) }) - 能解释一下这段代码的意思吗？ js延迟加载的方式有哪些？ Ajax 是什么? 如何创建一个Ajax？ 同步和异步的区别? 如何解决跨域问题? 页面编码和被请求的资源编码如果不一致如何处理？ 模块化开发怎么做？ AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？ requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？） 让你自己设计实现一个requireJS，你会怎么做？ 谈一谈你对ECMAScript6的了解？ ECMAScript6 怎么写class么，为什么会出现class这种东西? 异步加载的方式有哪些？ documen.write和 innerHTML的区别? DOM操作——怎样添加、移除、移动、复制、创建和查找节点? .call() 和 .apply() 的含义和区别？ 数组和对象有哪些原生方法，列举一下？ JS 怎么实现一个类。怎么实例化这个类 JavaScript中的作用域与变量声明提升？ 如何编写高性能的Javascript？ 那些操作会造成内存泄漏？ JQuery的源码看过吗？能不能简单概况一下它的实现原理？ jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？ jquery中如何将数组转化为json字符串，然后再转化回来？ jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？ jquery.extend 与 jquery.fn.extend的区别？ jQuery 的队列是如何实现的？队列可以用在哪些地方？ 谈一下Jquery中的bind(),live(),delegate(),on()的区别？ JQuery一个对象可以同时绑定多个事件，这是如何实现的？ 是否知道自定义事件。jQuery里的fire函数是什么意思，什么时候用？ jQuery 是通过哪个方法和 Sizzle 选择器结合的？（jQuery.fn.find()进入Sizzle） 针对 jQuery性能的优化方法？ Jquery与jQuery UI有啥区别？ JQuery的源码看过吗？能不能简单说一下它的实现原理？ jquery 中如何将数组转化为json字符串，然后再转化回来？ jQuery和Zepto的区别？各自的使用场景？ 针对 jQuery 的优化方法？ Zepto的点透问题如何解决？ jQueryUI如何自定义组件? 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？ 如何判断当前脚本运行在浏览器还是node环境中？（阿里） 移动端最小触控区域是多大？ jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢? 把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？ 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？（click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。） 知道各种JS框架(Angular, Backbone, Ember, React, Meteor, Knockout…)么? 能讲出他们各自的优点和缺点么? Underscore 对哪些 JS 原生对象进行了扩展以及提供了哪些好用的函数方法？ 解释JavaScript中的作用域与变量声明提升？ 那些操作会造成内存泄漏？ JQuery一个对象可以同时绑定多个事件，这是如何实现的？ Node.js的适用场景？ (如果会用node)知道route, middleware, cluster, nodemon, pm2, server-side rendering么? 解释一下 Backbone 的 MVC 实现方式？ 什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点? 知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么? 如何测试前端代码么? 知道BDD, TDD, Unit Test么? - 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)? 前端templating(Mustache, underscore, handlebars)是干嘛的, 怎么用? 简述一下 Handlebars 的基本用法？ 简述一下 Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？ 用js实现千位分隔符?(来源：前端农民工，提示：正则+replace) 检测浏览器版本版本有哪些方式？ 我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，你来说下会执行几次事件，然后会先执行冒泡还是捕获] 其他问题 原来公司工作流程是怎么样的，如何与其他人协作的？如何夸部门合作的？ 你遇到过比较难的技术问题是？你是如何解决的？ 设计模式 知道什么是singleton, factory, strategy, decrator么? 常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？ 页面重构怎么操作？ 列举IE与其他浏览器不一样的特性？ 99%的网站都需要被重构是那本书上写的？ 什么叫优雅降级和渐进增强？ 是否了解公钥加密和私钥加密。 WEB应用从服务器主动推送Data到客户端有那些方式？ 对Node的优点和缺点提出了自己的看法？ 你有用过哪些前端性能优化的方法？ http状态码有那些？分别代表是什么意思？ 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好） 部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？ 从打开app到刷新出内容，整个过程中都发生了什么，如果感觉慢，怎么定位问题，怎么解决? 除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？ 你用的得心应手用的熟练地编辑器&amp;开发环境是什么样子？ 对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？ 你怎么看待Web App 、hybrid App、Native App？ 你移动端前端开发的理解？（和 Web 前端开发的主要区别是什么？） 你对加班的看法？ 平时如何管理你的项目？ 说说最近最流行的一些东西吧？常去哪些网站？ 如何设计突发大规模并发架构？ 说说最近最流行的一些东西吧？常去哪些网站？ 是否了解开源的工具 bower、npm、yeoman、grunt、gulp，一个 npm 的包里的 package.json 具备的必要的字段都有哪些？（名称、版本号，依赖） 每个模块的代码结构都应该比较简单，且每个模块之间的关系也应该非常清晰，随着功能和迭代次数越来越多，你会如何去保持这个状态的？ Git知道branch, diff, merge么? 如何设计突发大规模并发架构？ 当团队人手不足，把功能代码写完已经需要加班的情况下，你会做前端代码的测试吗？ 说说最近最流行的一些东西吧？平时常去哪些网站？ 知道什么是SEO并且怎么优化么? 知道各种meta data的含义么? 移动端（Android IOS）怎么做好用户体验? 简单描述一下你做过的移动APP项目研发流程？ 你在现在的团队处于什么样的角色，起到了什么明显的作用？ 你认为怎样才是全端工程师（Full Stack developer）？ 介绍一个你最得意的作品吧？ 你有自己的技术博客吗，用了哪些技术？ 对前端安全有什么看法？ 是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？ 项目中遇到国哪些印象深刻的技术难题，具体是什么问题，怎么解决？。 最近在学什么东西？ 你的优点是什么？缺点是什么？ 如何管理前端团队? 最近在学什么？能谈谈你未来3，5年给自己的规划吗？","tags":[{"name":"面试","slug":"面试","permalink":"https://jiaopianjun.cc/tags/面试/"}]},{"title":"前端性能优化","date":"2018-06-11T10:02:27.000Z","path":"2018/06/11/前端性能优化.html","text":"如何进行网站性能优化 content方面 减少HTTP请求：合并文件、CSS精灵、inline Image 减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询 避免重定向：多余的中间访问 使Ajax可缓存 非必须组件延迟加载 未来所需组件预加载 减少DOM元素数量 将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量 减少iframe数量 不要404 Server方面 使用CDN 添加Expires或者Cache-Control响应头 对组件使用Gzip压缩 配置ETag Flush Buffer Early Ajax使用GET进行请求 避免空src的img标签 Cookie方面 减小cookie大小 引入资源的域名不要包含cookie css方面 将样式表放到页面顶部 不使用CSS表达式 不使用IE的Filter Javascript方面 将脚本放到页面底部 将javascript和css从外部引入 压缩javascript和css 删除不需要的脚本 减少DOM访问 合理设计事件监听器 图片方面 优化图片：根据实际颜色需要选择色深、压缩 优化css精灵 不要在HTML中拉伸图片 保证favicon.ico小并且可缓存 移动方面 保证组件小于25k Pack Components into a Multipart Document 你有用过哪些前端性能优化的方法？ 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 当需要设置的样式很多时设置className而不是直接操作style 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性) 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢 谈谈性能优化问题 代码层面：避免使用css表达式，避免使用高级选择器，通配选择器 缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等 请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载 请求带宽：压缩文件，开启GZIP 代码层面的优化 用hash-table来优化查找 少用全局变量 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能 用setTimeout来避免页面失去响应 缓存DOM节点查找的结果 避免使用CSS Expression 避免全局查询 避免使用with(with会创建自己的作用域，会增加作用域链长度) 多个变量声明合并 避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率 尽量避免写在HTML标签中写Style属性 前端性能优化最佳实践？ 性能评级工具（PageSpeed 或 YSlow） 合理设置 HTTP 缓存：Expires 与 Cache-control 静态资源打包，开启 Gzip 压缩（节省响应流量） CSS3 模拟图像，图标base64（降低请求数） 模块延迟(defer)加载/异步(async)加载 Cookie 隔离（节省请求流量） localStorage（本地存储） 使用 CDN 加速（访问最近服务器） 启用 HTTP/2（多路复用，并行加载） 前端自动化（gulp/webpack）","tags":[{"name":"面试题","slug":"面试题","permalink":"https://jiaopianjun.cc/tags/面试题/"}]},{"title":"Vue基础知识","date":"2018-06-11T10:02:27.000Z","path":"2018/06/11/Vue基础知识.html","text":"1.如何构建一个Vue项目1234561.首先安装node npm install node2.安装vue脚手架 vue-cli npm install -g vue-cli3.新建vue项目 vue init webpack newblog4.进入项目 cd newblog npm install 下载依赖模块5.npm run dev 运行项目6.npm run build 打包项目 2.Vue实例1.如何创建 var vm = new Vue({ el: &apos;#example&apos;, //挂载DOM 表示在这个id 范围内可以使用vue方法 data:{ text:&apos;实例&apos; //vue 数据 可以用在视图当中 }, created:function(){ // 生命周期钩子函数 console.log(this.text) // this指向vm 实例 } }) 例如： &lt;p&gt;{{data}}&lt;/p&gt; 结果==== &lt;p&gt;实例&lt;/p&gt; 2.生命周期钩子函数 beforecreated // 实例创建之前 created // 实例创建后 beforemounted // 实例挂载之前 mounted // 实例挂载后 beforeupdate // 实例更新之前 update // 实例更新后 beforedestory // 实例销毁之前 destory // 实例销毁后 生命周期钩子的 this 上下文指向调用它的Vue实例 注意： 不要在选项属性或者回调函数中使用箭头函数 3.模板语法 3.1 文本 &lt;span&gt; {{text}} &lt;/span&gt; v-once // 设置后text数据更新变化 这里都不会在变动 3.2 原始 Html 比如说 text 的值是 &lt;span&gt;2&lt;/span&gt; 现在你要插入一个 div 中 用 &lt;div v-html=&quot;text&quot;&gt;&lt;/div&gt; 3.3 特性 v-bind 例如 &lt;div v-bind:id=&quot;id&quot;&gt;&lt;/div&gt; 或者 &lt;div :id=&quot;id&quot;&gt;&lt;/div&gt; 3.4 使用JavaScript 表达式 {{ text + 1}} 3.5 指令 v-for 循环 v-if 将dom移除页面隐藏 v-show 页面隐藏 dom display:none 3.6 参数 比如 href id class 可以写成 :href :id :class 这个用到的是 v-bind 还有 click focus blur 可以写成 @click @focus @blur 这个用到的是 v-on 3.7 修饰符 修饰符 (Modifiers) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。 例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()： &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt; 4.计算属性和侦听器 4.1 计算属性 在 computed 中书写计算的方法和脚本 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 4.2 计算属性 vs 侦听属性 Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。 4.3 侦听器 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 5.Class 与 Style 绑定 操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是属性，所以我们可以用 v-bind 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 5.1 绑定 HTML Class &lt;div v-bind:class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt; 5.1.1 与普通样式共存 div class=&quot;static&quot; v-bind:class=&quot;{ active: isActive, &apos;text-danger&apos;: hasError }&quot;&gt;&lt;/div&gt; 结果为：&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt; 5.1.2 也可以绑定一个方法 &lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt; data: { isActive: true, error: null }, computed: { classObject: function () { return { active: this.isActive &amp;&amp; !this.error, &apos;text-danger&apos;: this.error &amp;&amp; this.error.type === &apos;fatal&apos; } } } 5.2 数组语法 我们可以把一个数组传给 v-bind:class，以应用一个 class 列表： &lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt; data: { activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos; } 渲染结果为： &lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt; 也可以根据条件来切换class 的演示 可以用 三元表达式 例如： &lt;div v-bind:class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;&lt;/div&gt; 或者这样写： &lt;div v-bind:class=&quot;[{ active: isActive }, errorClass]&quot;&gt;&lt;/div&gt; 这样 errorClass 一直存在 而activeClass只有当isActive为true的时候才存在 5.3 用在组件上 当在一个自定义组件上使用 class 属性时，这些类将被添加到该组件的根元素上面。这个元素上已经存在的类不会被覆盖。 例如： Vue.component(&apos;my-component&apos;, { template: &apos;&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;&apos; }) &lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt; 渲染为： &lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt; 6.绑定内联样式 6.1 对象语法 v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名： &lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize + &apos;px&apos; }&quot;&gt;&lt;/div&gt; data: { activeColor: &apos;red&apos;, fontSize: 30 } 或者也可以绑定一个对象属性 &lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt; data: { styleObject: { color: &apos;red&apos;, fontSize: &apos;13px&apos; } } 6.2 数组语法 v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上： &lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt; 6.3 自动添加前缀 当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。 6.4 多重值 可以为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值，例如： &lt;div :style=&quot;{ display: [&apos;-webkit-box&apos;, &apos;-ms-flexbox&apos;, &apos;flex&apos;] }&quot;&gt;&lt;/div&gt; 这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex。 7.条件渲染 7.1 v-if &lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt; &lt;h1 v-else&gt;No&lt;/h1&gt; 7.2 v-else 用在 v-if 之后 充当 if else 7.3 v-if-else 用在 v-if 之后 充当 if else if 7.4 用 key 管理可复用的元素 7.5 v-show 根据条件展示元素的选项 dom 等于 display：none 注意，v-show 不支持 &lt;template&gt; 元素，也不支持 v-else。 7.6 v-if v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 7.7 v-if 与 v-for 一起使用 v-for 比 v-if 优先级更高 8.列表渲染 8.1 v-for 把一个数组对应为一组元素 v-for 指令根据一组数组的选项列表进行渲染。v-for 指令需要使用 item in items 形式的特殊语法，items 是源数据数组并且 item 是数组元素迭代的别名。 实例： &lt;ul id=&quot;example-1&quot;&gt; &lt;li v-for=&quot;item in items&quot;&gt; {{ item.message }} &lt;/li&gt; &lt;/ul&gt; 或者： &lt;ul id=&quot;example-2&quot;&gt; &lt;li v-for=&quot;(item, index) in items&quot;&gt; {{ parentMessage }} - {{ index }} - {{ item.message }} &lt;/li&gt; &lt;/ul&gt; 或者： &lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt; var example1 = new Vue({ el: &apos;#example-1&apos;, data: { items: [ { message: &apos;Foo&apos; }, { message: &apos;Bar&apos; } ] } }) 结果： Foo Bar 8.2 一个对象的 v-for 可以用 v-for 通过一个对象的属性来迭代，可以提供第二个的参数为键名，第三个参数为索引 &lt;div v-for=&quot;(value, key, index) in object&quot;&gt; {{ index }}. {{ key }}: {{ value }} &lt;/div&gt; 8.3 key 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的且唯一的 id。这个特殊的属性相当于 Vue 1.x 的 track-by ，但它的工作方式类似于一个属性，所以你需要用 v-bind 来绑定动态值 (在这里使用简写)： &lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt; &lt;!-- 内容 --&gt; &lt;/div&gt; 8.4 数组更新检测 push() pop() shift() unshift() splice() sort() reverse() 8.5 注意事项 Vue不能检测修改数组长度 以及 利用索引改变值的状态变化 可以通过 set 来 提交更新 8.6 对象更改检测注意事项 还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：所以可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性。 8.7 显示过滤/排序结果 有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。 8.8 v-for with v-if 当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。 9.事件处理 9.1 监听事件 用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码 写法： &lt;div v-bind:click=&quot;dj&quot;&gt;&lt;/div&gt; 或者 &lt;div @/click=&quot;dj&quot;&gt;&lt;/div&gt; 9.2 事件处理方法 可以在 methods 中定义方法 然后调用 9.3 内联处理器中的方法 &lt;div id=&quot;example-3&quot;&gt; &lt;button v-on:click=&quot;say(&apos;hi&apos;)&quot;&gt;Say hi&lt;/button&gt; &lt;button v-on:click=&quot;say(&apos;what&apos;)&quot;&gt;Say what&lt;/button&gt; &lt;/div&gt; new Vue({ el: &apos;#example-3&apos;, methods: { say: function (message) { alert(message) } } }) 结果: 点击say hi 弹出 hi 点击say what 弹出 what 有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入 &lt;button v-on:click=&quot;warn(&apos;Form cannot be submitted yet.&apos;, $event)&quot;&gt; Submit &lt;/button&gt; // ... methods: { warn: function (message, event) { // 现在我们可以访问原生事件对象 if (event) event.preventDefault() alert(message) } } 9.4 事件修饰符 在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。 .stop .prevent .capture .self .once .passive &lt;!-- 阻止单击事件继续传播 --&gt; &lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt; &lt;!-- 提交事件不再重载页面 --&gt; &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt; &lt;!-- 修饰符可以串联 --&gt; &lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt; &lt;!-- 只有修饰符 --&gt; &lt;form v-on:submit.prevent&gt;&lt;/form&gt; &lt;!-- 添加事件监听器时使用事件捕获模式 --&gt; &lt;!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 --&gt; &lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt; &lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt; &lt;!-- 即事件不是从内部元素触发的 --&gt; &lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt; &lt;!-- 点击事件将只会触发一次 --&gt; &lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt; &lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt; &lt;!-- 而不会等待 `onScroll` 完成 --&gt; &lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt; &lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt; 9.5 按键修饰符 在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符： &lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt; &lt;input v-on:keyup.13=&quot;submit&quot;&gt; 记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名： &lt;!-- 同上 --&gt; &lt;input v-on:keyup.enter=&quot;submit&quot;&gt; &lt;!-- 缩写语法 --&gt; &lt;input @keyup.enter=&quot;submit&quot;&gt; 全部的按键别名： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 9.6 自动匹配按键修饰符 你也可直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符： &lt;input @keyup.page-down=&quot;onPageDown&quot;&gt; 在上面的例子中，处理函数仅在 $event.key === &apos;PageDown&apos; 时被调用 9.7 系统修饰键 可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 .ctrl .alt .shift .meta 例如： &lt;!-- Alt + C --&gt; &lt;input @keyup.alt.67=&quot;clear&quot;&gt; &lt;!-- Ctrl + Click --&gt; &lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt; .exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。 &lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt; &lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt; &lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt; &lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt; &lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt; &lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt; 9.8 鼠标按钮修饰符 .left .right .middle 10 表单输入绑定 10.1 基础用法 你可以用 v-model 指令在表单 &lt;input&gt; 及 &lt;textarea&gt; 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 10.2 文本 &lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt; &lt;p&gt;Message is: {{ message }}&lt;/p&gt; 10.3 多行文本 &lt;span&gt;Multiline message is:&lt;/span&gt; &lt;p style=&quot;white-space: pre-line;&quot;&gt;{{ message }}&lt;/p&gt; &lt;br&gt; &lt;textarea v-model=&quot;message&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt; 10.4 复选框 单个复选框，绑定到布尔值： &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt; &lt;label for=&quot;checkbox&quot;&gt;{{ checked }}&lt;/label&gt; true 多个复选框，绑定到同一个数组： &lt;div id=&apos;example-3&apos;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;john&quot;&gt;John&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;Checked names: {{ checkedNames }}&lt;/span&gt; &lt;/div&gt; new Vue({ el: &apos;#example-3&apos;, data: { checkedNames: [] } }) 10.5 单选按钮 &lt;div id=&quot;example-4&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt; &lt;label for=&quot;one&quot;&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt; &lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;Picked: {{ picked }}&lt;/span&gt; &lt;/div&gt; new Vue({ el: &apos;#example-4&apos;, data: { picked: &apos;&apos; } }) 10.6 选择框 注意：单选绑定到一个对象 &lt;div id=&quot;example-5&quot;&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: {{ selected }}&lt;/span&gt; &lt;/div&gt; new Vue({ el: &apos;...&apos;, data: { selected: &apos;&apos; } }) 多选：绑定到一个数组 &lt;div id=&quot;example-6&quot;&gt; &lt;select v-model=&quot;selected&quot; multiple style=&quot;width: 50px;&quot;&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;span&gt;Selected: {{ selected }}&lt;/span&gt; &lt;/div&gt; new Vue({ el: &apos;#example-6&apos;, data: { selected: [] } }) 用 v-for 渲染的动态选项： &lt;select v-model=&quot;selected&quot;&gt; &lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt; {{ option.text }} &lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: {{ selected }}&lt;/span&gt; new Vue({ el: &apos;...&apos;, data: { selected: &apos;A&apos;, options: [ { text: &apos;One&apos;, value: &apos;A&apos; }, { text: &apos;Two&apos;, value: &apos;B&apos; }, { text: &apos;Three&apos;, value: &apos;C&apos; } ] } }) 10.7 值绑定 对于单选按钮，复选框及选择框的选项，v-model 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)： &lt;!-- 当选中时，`picked` 为字符串 &quot;a&quot; --&gt; &lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;a&quot;&gt; &lt;!-- `toggle` 为 true 或 false --&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot;&gt; &lt;!-- 当选中第一个选项时，`selected` 为字符串 &quot;abc&quot; --&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option value=&quot;abc&quot;&gt;ABC&lt;/option&gt; &lt;/select&gt; 10.8 复选框 &lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; true-value=&quot;yes&quot; false-value=&quot;no&quot;&gt; // 当选中时 vm.toggle === &apos;yes&apos; // 当没有选中时 vm.toggle === &apos;no&apos; 10.9 单选按钮 &lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; v-bind:value=&quot;a&quot;&gt; // 当选中时 vm.pick === vm.a 10.10 选择框的选项 &lt;select v-model=&quot;selected&quot;&gt; &lt;!-- 内联对象字面量 --&gt; &lt;option v-bind:value=&quot;{ number: 123 }&quot;&gt;123&lt;/option&gt; &lt;/select&gt; // 当选中时 typeof vm.selected // =&gt; &apos;object&apos; vm.selected.number // =&gt; 123 10.11 修饰符 .lazy 在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步： &lt;!-- 在“change”时而非“input”时更新 --&gt; &lt;input v-model.lazy=&quot;msg&quot; &gt; .number 如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符： &lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt; 这通常很有用，因为即使在 type=&quot;number&quot; 时，HTML 输入元素的值也总会返回字符串。 .trim 如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符： &lt;input v-model.trim=&quot;msg&quot;&gt; 11.组件基础 11.1 基本示例 这里有一个 Vue 组件的示例： // 定义一个名为 button-counter 的新组件 Vue.component(&apos;button-counter&apos;, { data: function () { return { count: 0 } }, template: &apos;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me {{ count }} times.&lt;/button&gt;&apos; }) 组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 &lt;button-counter&gt;。我们可以在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用： &lt;div id=&quot;components-demo&quot;&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;/div&gt; new Vue({ el: &apos;#components-demo&apos; }) 11.2 组件的复用 你可以将组件进行任意次数的复用 每个组件都会各自独立维护它的 count。因为你每用一次组件，就会有一个它的新实例被创建。 11.3 data 必须是一个函数 一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝 11.4 组件的组织 通常一个应用会以一棵嵌套的组件树的形式来组织： 全局注册和局部注册。至此，我们的组件都只是通过 Vue.component 全局注册的 11.5 通过 Prop 向子组件传递数据 Prop 是你可以在组件上注册的一些自定义特性。当一个值传递给一个 prop 特性的时候，它就变成了那个组件实例的一个属性。为了给博文组件传递一个标题，我们可以用一个 props 选项将其包含在该组件可接受的 prop 列表中： 一个组件默认可以拥有任意数量的 prop，任何值都可以传递给任何 prop。在上述模板中，你会发现我们能够在组件实例中访问这个值，就像访问 data 中的值一样。 11.6 单个根元素 &lt;div class=&quot;blog-post&quot;&gt; &lt;h3&gt;{{ title }}&lt;/h3&gt; &lt;div v-html=&quot;content&quot;&gt;&lt;/div&gt; &lt;/div&gt; 应该外包包一层才能正确运行，否则会报错 11.7 通过事件向父级组件发送消息 我们可以调用内建的 $emit 方法并传入事件的名字，来向父级组件触发一个事件： 实例： 子组件内 &lt;button v-on:click=&quot;$emit(&apos;enlarge-text&apos;)&quot;&gt; Enlarge text &lt;/button&gt; 父组件内 通过v-on来监听这个事件 &lt;blog-post v-on:enlarge-text=&quot;postFontSize += 0.1&quot;&gt;&lt;/blog-post&gt; 11.8 动态组件 有的时候，在不同组件之间进行动态切换是非常有用的，比如在一个多标签的界面里： 上述内容可以通过 Vue 的 &lt;component&gt; 元素加一个特殊的 is 特性来实现： &lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt; &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt; 在上述示例中，currentTabComponent 可以包括 已注册组件的名字，或 一个组件的选项对象 11.9 在组件上使用 v-model 自定义事件也可以用于创建支持 v-model 的自定义输入组件。记住： &lt;input v-model=&quot;searchText&quot;&gt; 等价于： &lt;input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event.target.value&quot; &gt; 当用在组件上时，v-model 则会这样： &lt;custom-input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event&quot; &gt;&lt;/custom-input&gt; 为了让它正常工作，这个组件内的 &lt;input&gt; 必须： 将其 value 特性绑定到一个名叫 value 的 prop 上 在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出 写成代码之后是这样的： Vue.component(&apos;custom-input&apos;, { props: [&apos;value&apos;], template: ` &lt;input v-bind:value=&quot;value&quot; v-on:input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot; &gt; ` }) 现在 v-model 就应该可以在这个组件上完美地工作起来了： &lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt; 11.10 解析 DOM 模板时的注意事项 有些 HTML 元素，诸如 &lt;ul&gt;、&lt;ol&gt;、&lt;table&gt; 和 &lt;select&gt;，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 &lt;li&gt;、&lt;tr&gt; 和 &lt;option&gt;，只能出现在其它某些特定的元素内部。 这会导致我们使用这些有约束条件的元素时遇到一些问题。例如： &lt;table&gt; &lt;blog-post-row&gt;&lt;/blog-post-row&gt; &lt;/table&gt; 这个自定义组件 &lt;blog-post-row&gt; 会被作为无效的内容提升到外部，并导致最终渲染结果出错。幸好这个特殊的 is 特性给了我们一个变通的办法： &lt;table&gt; &lt;tr is=&quot;blog-post-row&quot;&gt;&lt;/tr&gt; &lt;/table&gt; 需要注意的是如果我们从以下来源使用模板的话，这条限制是不存在的： 字符串 (例如：template: &apos;...&apos;) 单文件组件 (.vue) &lt;script type=&quot;text/x-template&quot;&gt;","tags":[{"name":"vue","slug":"vue","permalink":"https://jiaopianjun.cc/tags/vue/"}]},{"title":"浏览器本地存储","date":"2018-06-11T10:02:27.000Z","path":"2018/06/11/浏览器本地存储.html","text":"浏览器本地存储 在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStorage html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储 而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的 web storage和cookie的区别 Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用 除此之外，WebStorage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie 但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 cookie 和session 的区别： 1、cookie数据存放在客户的浏览器上，session数据放在服务器上。 2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用COOKIE。 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 5、所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中 描述 cookies、sessionStorage 和 localStorage 的区别？ 与服务器交互： cookie 是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密） cookie 始终会在同源 http 请求头中携带（即使不需要），在浏览器和服务器间来回传递 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存 存储大小： cookie 数据根据不同浏览器限制，大小一般不能超过 4k sessionStorage 和 localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 有效期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage 数据在当前浏览器窗口关闭后自动删除 cookie 设置的cookie过期时间之前一直有效，与浏览器是否关闭无关","tags":[{"name":"面试题","slug":"面试题","permalink":"https://jiaopianjun.cc/tags/面试题/"}]},{"title":"什么是 Ajax? 如何创建一个Ajax？","date":"2018-06-11T10:02:27.000Z","path":"2018/06/11/Ajax.html","text":"什么是 Ajax? 如何创建一个Ajax？ AJAX(Asynchronous Javascript And XML) = 异步 JavaScript + XML 在后台与服务器进行异步数据交换，不用重载整个网页，实现局部刷新。 创建 ajax 步骤： 1.创建 XMLHttpRequest 对象 2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的类型、验证信息 3.设置响应 HTTP 请求状态变化的回调函数 4.发送 HTTP 请求 5.获取异步调用返回的数据 6.使用 JavaScript 和 DOM 实现局部刷新 12345678910111213141516171819var xhr = new XMLHttpRequest();xhr.open(\"POST\", url, true);xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; (xhr.status == 200 || xhr.status == 304)) &#123; fn.call(this, xhr.responseText); &#125;&#125;;xhr.send(data);$.ajax(&#123; url:'', type:'', data:&#123;&#125;, dataType:'', josnp:'jsoncallback', success:function()&#123; &#125;&#125;)","tags":[{"name":"javascript","slug":"javascript","permalink":"https://jiaopianjun.cc/tags/javascript/"}]},{"title":"Html常见问题","date":"2018-06-11T09:40:27.000Z","path":"2018/06/11/Html常见问题.html","text":"html和xhtml 有什么区别？html 是一种基本的web网页设计语言，Xhtml 是一种基于xml 的指置标语言 xhtml 必须有闭合标签，必须字母为小写，必须要有根元素 什么是语义化HTML？直观的标签能够对搜索引擎的抓取有好处，用正确的标签做正确的事 便于对浏览器和搜索引擎的解析 对于HTML语义化的理解？即使在没有css的情况下 页面代码也能很好的被阅读理解，用正确的标签 能够对浏览器和搜索引擎的支持更好。便于后期的维护。 常见的浏览器内核IE(trident) chrome safari(webkit) firefox(gecko) opera(presto) HTML5为什么只需要写！DOCTYPE HTML？html5 不是基于sgml ,所以不需要对DTD进行引用，但是需要doctype 来规范浏览器的行为（让浏览器按照他们应该的方式来运行） Doctype作用？标准模式与兼容模式各种什么区别？处于文档的第一行，告诉浏览器用什么方法来解析文档内容 如果式标准 就按照浏览器的最高配置来解析 如果式兼容模式 则会以宽松的方式 向后进行兼容的方式来显示 html document是干嘛的？html 超文本标记语言 html document对象 每个载入浏览器的html文档都会成为document对象 由于docement 是window对象的一部分 所以 可以通过 window.document属性对其进行访问 html5哪些操作可以SEO优化title meta header footer nav aside article 行内元素和块状元素的区别？行内元素无法设置宽高padding 等 span a input b em hr img 块级元素可以 p div ul li dt dd ol li 页面导入样式时，使用link和@import有什么区别？link 属于html 标签 页面加载到就会执行 import 由css 提供 css 加载完之后 执行 介绍以下你对浏览器内核的理解？分为渲染引擎和js 引擎 渲染引擎 负责 取得网页的html css 图像 等信息 然后根据css 将页面渲染出来 js 引擎 则负责页面数据或者动态效果的处理 box-sizing常用的属性有哪些？分别有什么作用？box-sizing：content-box|border-box|inherit padding 和border 不会超出设定的大小 video 预加载preload audio 暂停和播放play() pause() css 定义p 标签 ie6 黑色 ie7 红色 其他绿色*color:red; _color:#000; color:green 前端有哪三层构成，分别是什么？结构层 html dom结构 表示层 css 渲染 行为层 js操作","tags":[{"name":"html","slug":"html","permalink":"https://jiaopianjun.cc/tags/html/"}]},{"title":"JS  foo()","date":"2018-06-11T09:14:20.000Z","path":"2018/06/11/JS-foo.html","text":"1234function Food（ getName＝function（）（ alert（）） return this｝ 1234567891011121314 Foo. getName＝function （） alert （2） Foo. prototype getName＝function（）f alert（3）） var getName＝ function （（alert（4） function getName（）（ alert（5）） 请问以下的输出结果分别是什么: Foo. getName） getName（ Foo（）.getName（ get Name（）（ new Foo. getNamel） I new Foo（）.getName（） new new Foo（）.getNamel）5","tags":[{"name":"javascript","slug":"javascript","permalink":"https://jiaopianjun.cc/tags/javascript/"}]},{"title":"移动端常见兼容性问题","date":"2018-06-11T09:11:17.000Z","path":"2018/06/11/移动端常见兼容性问题.html","text":"1.border-radius百分比失效1解决方法：设置一个较大值比如 border-radius:9999px; placeholder属性设置的文字向上偏移的厉害1解决办法：line-height:normal 如果一个应用了css3 transform的元素里面包含fixed定位的元素，在webkit核心的浏览器下，该fixed定位的元素会失效，其实际定位效果类似绝对定位，会跟着滚动条的滚动而滚动！1避免在应用了css3 transform的元素内部嵌套fixed定位的元素。 webkit上的input,button,及select的默认样式可以通过以下代码禁用，然后自定义。 1-webkit-appearance:none; video标签的父元素(祖辈元素)设置transform样式后，标签会脱离文档流1避免使用transform，如果需要设置位移，可使用绝对定位加top/left代替 webkit上的input,button,及select的默认样式可以通过以下代码禁用，然后自定义。1-webkit-appearance:none; body设置100%高度后，在移动浏览器里面可能会被底部的导航栏挡住:1document.documentElement.style.height = window.innerHeight + 'px' 字体设置建议：123body &#123; font-family: \"Helvetica Neue\", Helvetica, STHeiTi, sans-serif;&#125; 移动端边框1像素的问题12345解决方法：1.border-image 设置2.使用媒体查询，定义不同像素下的边线宽度 用 transform:scaleY() 来设置3.利用伪类来实现4.定死viewport 通过JS 来控制rem 来实现 设置全局的CSS样式，避免图中的长按弹出菜单与选中文本的行为1234567a, img &#123; -webkit-touch-callout: none; /* 禁止长按链接与图片弹出菜单 */&#125;html, body &#123; -webkit-user-select: none; /* 禁止选中文本（如无文本选中需求，此为必选项） */ user-select: none;&#125; 安卓浏览器看背景图片，有些设备会模糊12原因：因为devicePixelRatio，手机分辨率太小，如果按照分辨率来显示网页，这样字会非常小，所以苹果当初就把iPhone 4的960*640分辨率，在网页里只显示了480*320，这样devicePixelRatio＝2。解决方法： 设置2x的背景图片 然后利用background-size：contain 防止手机中网页放大和缩小1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0\" /&gt; apple-mobile-web-app-capable1234apple-mobile-web-app-capable是设置Web应用是否以全屏模式运行。写法：&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt;content 默认为no format-detection 页面上数字不被识别为电话12345format-detection 启动或禁用自动识别页面中的电话号码。写法：&lt;meta name=\"format-detection\" content=\"telephone=no\" &gt;content 可以设置 启动或禁止 禁止复制、选中文本1user-select:none； Retina屏的1px边框1border-width:thin; 某些Android手机圆角失效1background-clip: padding-box; IOS中input键盘事件keyup、keydown、keypress支持不是很好1通过html5 的 oninput 来代替 解决 ios 设置input 按钮样式会被默认样式覆盖12border: 0; -webkit-appearance: none; 解决 IOS键盘字母输入，默认首字母大写1&lt;input type=\"text\" autocapitalize=\"off\"/&gt; 设置 select 下拉选择设置右对齐1direction: rtl; 解决 通过transform进行skew变形，rotate旋转会造成出现锯齿现象123-webkit-transform: rotate(-4deg) skew(10deg) translateZ(0); transform: rotate(-4deg) skew(10deg) translateZ(0); outline: 1px solid rgba(255,255,255,0) 移动端点击300ms延迟12345678910产生原因：苹果发明，为了让浏览器明白用户是点击 还是双击缩放而诞生1.禁用浏览器的缩放功能 &lt;meta name=\"viewport\" content=\"user-scalable=no\"&gt; &lt;meta name=\"viewport\" content=\"initial-scale=1,maximum-scale=1\"&gt;2.更改默认的视口宽度，当网页为响应式的时候设置。因为已经做过响应式或者自适应所以缩放就没有必要了。也就去掉点击延时的必要 &lt;meta name=\"viewport\" content=\"width=device-width\"&gt;3.使用touchend 事件处理4.使用第三方封装js 如tap.js 移动端滚动穿透问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849问题：移动端弹出fixed弹窗的话，在弹窗上滑动会导致下层的页面跟着滚动，这个叫 “滚动穿透”解决方案：1.在弹出层的touchmove事件中调用preventDefault2.body 设置 overflow：hidden （适合PC）3.css设置 position: fixed; width: 100%; js设置 (function()&#123; var scrollTop = 0; // 显示弹出层 open.onclick = function()&#123; // 在弹出层显示之前，记录当前的滚动位置 scrollTop = getScrollTop(); // 使body脱离文档流 document.body.classList.add('dialog-open'); // 把脱离文档流的body拉上去！否则页面会回到顶部！ document.body.style.top = -scrollTop + 'px'; mask.style.display = 'block'; &#125; // 隐藏弹出层 close.onclick = function()&#123; mask.style.display = 'none'; // body又回到了文档流中（我胡汉三又回来啦！） document.body.classList.remove('dialog-open'); // 滚回到老地方 to(scrollTop); &#125; function to(scrollTop)&#123; document.body.scrollTop = document.documentElement.scrollTop = scrollTop; &#125; function getScrollTop()&#123; return document.body.scrollTop || document.documentElement.scrollTop; &#125; &#125;()); function fixedBody()&#123; var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; document.body.style.cssText += 'position:fixed;top:-'+scrollTop+'px;'; &#125; function looseBody() &#123; var body = document.body; body.style.position = ''; var top = body.style.top; document.body.scrollTop = document.documentElement.scrollTop = -parseInt(top); body.style.top = ''; &#125; 移动端点击穿透问题12345678910111213问题描述：如果在移动页面有两个元素 A BA 在 B 之上。 如果A监听touch事件(zepto的tap事件)，而且B上有个链接(或者监听click事件)，那么当touch A后，先后触发了touchStart和touchEnd事件，touchEnd后A层隐藏，而此刻会触发在document最前面B的click事件；这就是点透行为。原理：在移动端 事件执行的顺序是touchstart &gt; touchend &gt; click 解决方法：1.尽量使用touch事件代替click事件2.用preventDefault阻止a标签的click3.延迟一定的时间(300ms+)来处理事件 （不推荐）$(\"#haorooms\").on(\"touchend\",function(event) &#123; event.preventDefault(); &#125;) 解决 iOS 系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格1this.value = this.value.replace(/\\u2006/g,''); 移动端 HTML5 audio autoplay 失效问题12345678910问题原因：因为网页中自动播放视频或者音频会给用户带来麻烦护着流量消耗，所以安卓和IOS 都默认禁用了自动播放解决方法：通过用户 touchstart 触碰，触发播放并暂停（音频开始加载，后面用 JS 再操作就没问题了）。document.addEventListener('touchstart',function() &#123; document.getElementsByTagName('audio')[0].play(); document.getElementsByTagName('audio')[0].pause();&#125;); 移动端 HTML5 input date 不支持 placeholder 问题1&lt;input placeholder=\"Date\" class=\"textbox-n\" type=\"text\" onfocus=\"(this.type='date')\" id=\"date\"&gt; 移动端呼起键盘引起的问题12345671.当某输入框获取焦点时，弹起自定义时间插件，貌似很简单一个功能，但测试时问题来了，获取焦点时键盘也会跟着一起弹出来解决方法： 通过js解决 focus 的时候 让她 blur2.input填写时 键盘呼起，页面底部设置为fixed 的也会被顶起。解决方法： 1.呼起键盘的时候 将fixed 项目隐藏，键盘隐藏时在将fixed显示 2.监听页面滚动 将其隐藏显示 transform 属性会使 position：fixed 失效1解决办法： 把内容和定位的元素分开； rem 单位下做圆 宽高比较小的时候在移动端会变成椭圆形12原因：宽高大小有小数 解决方法：做取整处理 苹果手机在点击时候会自带一个灰亮背景1解决办法： -webkit-tap-highlight-color: transparent; afari 浏览器 input submit 在会出现颜色和样式改变的bug1解决办法： input 写上-webkit-appearance: none;","tags":[{"name":"移动端","slug":"移动端","permalink":"https://jiaopianjun.cc/tags/移动端/"}]},{"title":"JS处理时间戳显示为多少分钟前，多少天前的","date":"2018-06-11T09:10:57.000Z","path":"2018/06/11/JS处理时间戳显示为多少分钟前，多少天前的.html","text":"123456789101112131415161718/*** 时间戳显示为多少分钟前，多少天前的处理** eg.** console.log(dateDiff(1411111111111)); // 2014年09月19日** console.log(dateDiff(1481111111111)); // 9月前** console.log(dateDiff(1499911111111)); // 2月前** console.log(dateDiff(1503211111111)); // 3周前** console.log(dateDiff(1505283100802)); // 1分钟前*/var dateDiff = function (timestamp) &#123; // 补全为13位 var arrTimestamp = (timestamp + '').split(''); for (var start = 0; start &lt; 13; start++) &#123; if (!arrTimestamp[start]) &#123; arrTimestamp[start] = '0'; &#125; &#125; timestamp = arrTimestamp.join('') * 1;","tags":[{"name":"javascript","slug":"javascript","permalink":"https://jiaopianjun.cc/tags/javascript/"}]},{"title":"前端开发知识点","date":"2018-06-10T10:02:27.000Z","path":"2018/06/10/前端开发知识点.html","text":"HTML&amp;CSS 对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、HTML5、CSS3、Flexbox JavaScript： 数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 其他： 移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力 DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。 DOM操作 —— 如何添加、移除、移动、复制、创建和查找节点等。 事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。 XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。 严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。 盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型 块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们 浮动元素 —— 怎么使用它们、它们有什么问题以及怎么解决这些问题。 HTML与XHTML —— 二者有什么区别，你觉得应该使用哪一个并说出理由。 JSON —— 作用、用途、设计结构 HTMLDoctype作用？标准模式与兼容模式各有什么区别? &lt;!DOCTYPE&gt;声明位于位于HTML文档中的第一行，处于 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现 标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作 HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？ HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行） 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素 行内元素有：a b span img input select strong（强调的语气） 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p 常见的空元素： 页面导入样式时，使用link和@import有什么区别？ link属于XHTML标签，除了加载CSS外，还能用于定义RSS,定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS; 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题; 介绍一下你对浏览器内核的理解？ 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核 JS引擎则：解析和执行javascript来实现网页的动态效果 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 常见的浏览器内核有哪些？ Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML] Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）] html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和HTML5？ HTML5 现在已经不是 SGML的子集，主要是关于图像，位置，存储，多任务等功能的增加 新增功能 绘画 canvas; 用于媒介回放的 video 和 audio 元素; 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; sessionStorage 的数据在浏览器关闭后自动删除; 语意化更好的内容元素，比如 article、footer、header、nav、section; 表单控件，calendar、date、time、email、url、search 新的技术webworker, websocket, Geolocation 移除的元素： 纯表现的元素：basefont，big，center，font, s，strike，tt，u; 对可用性产生负面影响的元素：frame，frameset，noframes 支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式 当然也可以直接使用成熟的框架、比如html5shim 1234&lt;!--[if lt IE 9]&gt; &lt;script&gt; src=\"http://html5shim.googlecode.com/svn /trunk/html5.js\"&lt;/script&gt; &lt;![endif]--&gt; 如何区分HTML5： DOCTYPE声明\\新增的结构元素\\功能元素 简述一下你对HTML语义化的理解？ 用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解 HTML5的离线储存怎么使用，工作原理能不能解释一下？ 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示 如何使用： 页面头部像下面一样加入一个manifest的属性 在cache.manifest文件的编写离线存储的资源 在离线状态时，操作window.applicationCache进行需求实现 123456789CACHE MANIFEST#v0.11CACHE:js/app.jscss/style.cssNETWORK:resourse/logo.pngFALLBACK:/ /offline.html 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？ 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储 离线的情况下，浏览器就直接使用离线存储的资源 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存 存储大小： cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 iframe有那些缺点？ iframe会阻塞主页面的Onload事件 搜索引擎的检索程序无法解读这种页面，不利于SEO; iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript 动态给iframe添加src属性值，这样可以绕开以上两个问题 Label的作用是什么？是怎么用的？ label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上 1234&lt;label for=\"Name\"&gt;Number:&lt;/label&gt;&lt;input type=“text“name=\"Name\" id=\"Name\"/&gt;&lt;label&gt;Date:&lt;input type=\"text\" name=\"B\"/&gt;&lt;/label&gt; HTML5的form如何关闭自动完成功能？ 给不想要提示的 form 或某个 input 设置为 autocomplete=off。 如何实现浏览器内多个标签页之间的通信? (阿里) WebSocket、SharedWorker 也可以调用localstorge、cookies等本地存储方式 localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件,我们通过监听事件，控制它的值来进行页面信息通信； 注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常； webSocket如何兼容低浏览器？(阿里) Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR 页面可见性（Page Visibility API） 可以有哪些用途？ 通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等; 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放 如何在页面上实现一个圆形的可点击区域？ map+area或者svg border-radius 纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果 &lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt; 网页验证码是干嘛的，是为了解决什么安全问题 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试 title与h1的区别、b与strong的区别、i与em的区别？ title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响 strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：会重读，而是展示强调内容 i内容展示为斜体，em表示强调的文本； Physical Style Elements – 自然样式标签 b, i, u, s, pre Semantic Style Elements – 语义样式标签 strong, em, ins, del, code CSS 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？ 有两种， IE 盒子模型、W3C 盒子模型； 盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)； 区 别： IE的content部分把 border 和 padding计算了进去; CSS选择符有哪些？哪些属性可以继承？ id选择器（ # myid） 类选择器（.myclassname） 标签选择器（div, h1, p） 相邻选择器（h1 + p） 子选择器（ul &gt; li） 后代选择器（li a） 通配符选择器（ * ） 属性选择器（a[rel = “external”]） 伪类选择器（a:hover, li:nth-child） 可继承的样式： font-size font-family color, UL LI DL DD DT 不可继承的样式：border padding margin width height CSS优先级算法如何计算？ 优先级就近原则，同权重情况下样式定义最近者为准 载入样式以最后载入的定位为准 优先级为: 同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。 !important &gt; id &gt; class &gt; tag important 比 内联优先级高 CSS3新增伪类有那些？ 12345678910- p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。- p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。- p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。- p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。- p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。- :after 在元素之前添加内容,也可以用来做清除浮动。- :before 在元素之后添加内容- :enabled - :disabled 控制表单控件的禁用状态。- :checked 单选框或复选框被选中 如何居中div？ 水平居中：给div设置一个宽度，然后添加margin:0 auto属性 1234div&#123; width:200px; margin:0 auto; &#125; 让绝对定位的div居中 1234567891011div &#123; position: absolute; width: 300px; height: 300px; margin: auto; top: 0; left: 0; bottom: 0; right: 0; background-color: pink; /* 方便看效果 */&#125; 水平垂直居中一 确定容器的宽高 宽500 高 300 的层 设置层的外边距 12345678910div &#123; position: relative; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; margin: -150px 0 0 -250px; /* 外边距为自身宽高的一半 */ background-color: pink; /* 方便看效果 */ &#125; 水平垂直居中二 未知容器的宽高，利用 transform 属性 12345678910div &#123; position: absolute; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: pink; /* 方便看效果 */&#125; 水平垂直居中三 利用 flex 布局 实际使用时应考虑兼容性 1234567891011.container &#123; display: flex; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */&#125;.container div &#123; width: 100px; height: 100px; background-color: pink; /* 方便看效果 */&#125; display有哪些值？说明他们的作用。 block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。 none 缺省值。象行内元素类型一样显示。 inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示 inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。 list-item 象块类型元素一样显示，并添加样式列表标记。 table 此元素会作为块级表格来显示。 inherit 规定应该从父元素继承 display 属性的值 position的值relative和absolute定位原点是？ absolute 生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。 fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。 inherit 规定从父元素继承 position 属性的值 CSS3有哪些新特性？ 12345678910- 新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）- 圆角 （border-radius:8px）- 多列布局 （multi-column layout）- 阴影和反射 （Shadow\\Reflect）- 文字特效 （text-shadow、）- 文字渲染 （Text-decoration）- 线性渐变 （gradient）- 旋转 （transform）- 缩放,定位,倾斜,动画,多背景- 例如:transform:\\scale(0.85,0.90)\\ translate(0px,-30px)\\ skew(-9deg,0deg)\\Animation: 请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？ 一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间 较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现 采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。 它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目” 常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应 在布局上有了比以前更加灵活的空间 用纯CSS创建一个三角形的原理是什么？ 把上、左、右三条边隐藏掉（颜色设为 transparent） 1234567#demo &#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent;&#125; 一个满屏 品 字布局 如何设计? 简单的方式： 上面的div宽100%， 下面的两个div分别宽50%， 然后用float或者inline使其不换行即可 css多列等高如何实现？ 利用padding-bottom|margin-bottom正负值相抵； 设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度 当它里面的任 一列高度增加了，则父容器的高度被撑到里面最高那列的高度 其他比这列矮的列会用它们的padding-bottom补偿这部分高度差 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一 IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大 浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;} 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——display:inline;将其转化为行内属性。(这个符号只有ie6会识别) 渐进识别的方式，从总体中逐渐排除局部 首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别 123456.bb&#123; background-color:red;/*所有识别*/ background-color:#00deff\\9; /*IE6、7、8识别*/ +background-color:#a200ff;/*IE6、7识别*/ _background-color:#1e0bd1;/*IE6识别*/ &#125; IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性; Firefox下,只能使用getAttribute()获取自定义属性 解决方法:统一通过getAttribute()获取自定义属性。 IE下,even对象有x,y属性,但是没有pageX,pageY属性 Firefox下,event对象有pageX,pageY属性,但是没有x,y属性 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。 Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。 超链接访问过后hover样式就不出现了。被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {} li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？ 行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了 为什么要初始化CSS样式 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化 最简单的初始化方法： * {padding: 0; margin: 0;} （强烈不建议） absolute的containing block(容器块)计算方式跟正常流有什么不同？ 无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断： 1、若此元素为 inline 元素，则 containing block为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形； 2、否则,则由这个祖先元素的 padding box 构成。如果都找不到，则为 initial containing block。 补充： static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分） absolute: 向上找最近的定位为absolute/relative的元素 fixed: 它的containing block一律为根元素(html/body)，根元素也是initial containing block CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？ 对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与display:none;表现相同. 如果目标元素为table,visibility:collapse;将table隐藏,但是会占据页面布局空间. 仅在Firefox下起作用,IE会显示元素,Chrome会将元素隐藏,但是占据空间. position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？ 如果元素的display为none,那么元素不被渲染,position,float不起作用, 如果元素拥有position:absolute;或者position:fixed;属性那么元素将为绝对定位,float不起作用. 如果元素float属性不是none,元素会脱离文档流,根据float属性值来显示.有浮动,绝对定位,inline-block属性的元素,margin不会和垂直方向上的其他元素margin折叠 对BFC规范(块级格式化上下文：block formatting context)的理解？ 一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响 css定义的权重 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值 12345678910111213141516171819/*权重为1*/div&#123;&#125;/*权重为10*/.class1&#123;&#125;/*权重为100*/#id1&#123;&#125;/*权重为100+1=101*/#id1 div&#123;&#125;/*权重为10+1=11*/.class1 div&#123;&#125;/*权重为10+10+1=21*/.class1 .class2 div&#123;&#125; 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现 请解释一下为什么需要清除浮动？清除浮动的方式 清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示 父级div定义height 父级div 也一起浮动； 常规的使用一个class； 12345678910.clearfix:before, .clearfix:after &#123; content: \" \"; display: table;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; SASS编译的时候，浮动元素的父级div定义伪类:after 1234567&amp;:after,&amp;:before&#123; content: \" \"; visibility: hidden; display: block; height: 0; clear: both;&#125; 解析原理： display:block 使生成的元素以块级元素显示,占满剩余空间 height:0 避免生成内容破坏原有布局的高度。 visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互 通过 content:”.”生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:”.”,有些版本可能content 里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0 content:”” 仍然会产生额外的空隙 zoom：1 触发IE hasLayout 通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0 什么是外边距合并？ 外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距 合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。zoom:1的清除浮动原理? 清除浮动，触发hasLayout； Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug 譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等移动端的布局用过媒体查询吗？ 假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法 当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。 当媒体查询返回假， 标签上带有媒体查询的样式表 仍将被下载 （只不过不会被应用） 包含了一个媒体类型和至少一个使用 宽度、高度和颜色等媒体属性来限制样式表范围的表达式 CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围 1234567&lt;style&gt;@media (min-width: 700px) and (orientation: landscape)&#123; .sidebar &#123; display: none; &#125;&#125;&lt;/style&gt; 使用 CSS 预处理器吗？喜欢那个？ SASS (SASS、LESS没有本质区别，只因为团队前端都是用的SASS) CSS优化、提高性能的方法有哪些？ 关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）； 如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）； 提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性; 使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级） 浏览器是怎样解析CSS选择器的？ 样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素 只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则 margin和padding分别适合什么场景使用？ margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。 margin用于布局分开元素使元素与元素互不相干； padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段 ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成） 双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法 比如:first-line、:first-letter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。 想让插入的内容出现在其它内容前，使用::before，否者，使用::after；在代码顺序上，::after生成的内容也比::before生成的内容靠后。 如果按堆栈视角，::after生成的内容会在::before生成的内容之上 如何修改chrome记住密码后自动填充表单的黄色背景 ？ 12345input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill &#123; background-color: rgb(250, 255, 189); /* #FAFFBD; */ background-image: none; color: rgb(0, 0, 0);&#125; 设置元素浮动后，该元素的display值是多少？ 自动变成了 display:block 怎么让Chrome支持小于12px 的文字？ 用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观 使用12px及12px以上字体大小：为了兼容各大主流浏览器，建议设计美工图时候设置大于或等于12px的字体大小，如果是接单的这个时候就需要给客户讲解小于12px浏览器不兼容等事宜 继续使用小于12px字体大小样式设置：如果不考虑chrome可以不用考虑兼容，同时在设置小于12px对象设置-webkit-text-size-adjust:none，做到最大兼容考虑 使用12px以上字体：为了兼容、为了代码更简单 从新考虑权重下兼容性。 让页面里的字体变清晰，变细用CSS怎么做？ -webkit-font-smoothing: antialiased; font-style属性可以让它赋值为“oblique” oblique是什么意思？ 倾斜的字体样式 position:fixed;在android下无效怎么处理？ fixed的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的viewport，原来的网页还好好的在那，fixed的内容也没有变过位置， 所以说并不是iOS不支持fixed，只是fixed的元素不是相对手机屏幕固定的 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt; 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里） 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms display:inline-block 什么时候会显示间隙？(携程) 移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing 什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做） 如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开。 因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的 同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，提高了webserver的http请求的解析速度。 什么是CSS 预处理器 / 后处理器？ 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。 JavaScript 介绍js的基本数据类型 Undefined、Null、Boolean、Number、String、 ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 ) 介绍js有哪些内置对象？ Object 是 JavaScript 中所有对象的父对象 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error 说几条写JavaScript的基本规范？ 1.不要在同一行声明多个变量。 2.请使用 ===/!==来比较true/false或者数值 3.使用对象字面量替代new Array这种形式 4.不要使用全局函数。 5.Switch语句必须带有default分支 6.函数不应该有时候有返回值，有时候没有返回值。 7.For循环必须使用大括号 8.If语句必须使用大括号 9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。 JavaScript原型，原型链 ? 有什么特点？ 每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。 关系：instance.constructor.prototype = instance.proto 特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话， 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。 12345678910function Func()&#123;&#125;Func.prototype.name = \"Sean\";Func.prototype.getInfo = function() &#123; return this.name;&#125;var person = new Func();//现在可以参考var person = Object.create(oldObject);console.log(person.getInfo());//它拥有了Func的属性和方法//\"Sean\"console.log(Func.prototype);// Func &#123; name=\"Sean\", getInfo=function()&#125; JavaScript有几种类型的值？，你能画一下他们的内存图吗？ 栈：原始数据类型（Undefined，Null，Boolean，Number、String） 堆：引用数据类型（对象、数组和函数） 两种类型的区别是：存储位置不同； 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体 如何将字符串转化为数字，例如’12.3b’? parseFloat(‘12.3b’); 正则表达式，’12.3b’.match(/(\\d)+(.)?(\\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已 如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』? 1234567function commafy(num)&#123; return num &amp;&amp; num .toString() .replace(/(\\d)(?=(\\d&#123;3&#125;)+\\.)/g, function($1, $2)&#123; return $2 + ','; &#125;);&#125; 如何实现数组的随机排序？ 方法一： 1234567891011var arr = [1,2,3,4,5,6,7,8,9,10];function randSort1(arr)&#123; for(var i = 0,len = arr.length;i &lt; len; i++ )&#123; var rand = parseInt(Math.random()*len); var temp = arr[rand]; arr[rand] = arr[i]; arr[i] = temp; &#125; return arr;&#125;console.log(randSort1(arr)); 方法二： 1234567891011var arr = [1,2,3,4,5,6,7,8,9,10];function randSort2(arr)&#123; var mixedArray = []; while(arr.length &gt; 0)&#123; var randomIndex = parseInt(Math.random()*arr.length); mixedArray.push(arr[randomIndex]); arr.splice(randomIndex, 1); &#125; return mixedArray;&#125;console.log(randSort2(arr)); 方法三： 123456javascriptvar arr = [1,2,3,4,5,6,7,8,9,10];arr.sort(function()&#123; return Math.random() - 0.5;&#125;)console.log(arr); Javascript如何实现继承？ 构造继承 原型继承 实例继承 拷贝继承 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式 12345678910111213javascriptfunction Parent()&#123; this.name = 'wang';&#125;function Child()&#123; this.age = 28;&#125;Child.prototype = new Parent();//继承了Parent，通过原型var demo = new Child();alert(demo.age);alert(demo.name);//得到被继承的属性 javascript创建对象的几种方式？ javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用 1、对象字面量的方式 person={firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;}; 2、用function来模拟无参的构造函数 123456789function Person()&#123;&#125;//定义一个function，如果使用new\"实例化\",该function可以看作是一个Classperson.name=\"Mark\";var person=new Person();person.age=\"25\";person.work=function()&#123;alert(person.name+\" hello...\");&#125;person.work(); 3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性） 12345678910function Pet(name,age,hobby)&#123; this.name=name;//this作用域：当前对象 this.age=age; this.hobby=hobby; this.eat=function()&#123; alert(\"我叫\"+this.name+\",我喜欢\"+this.hobby+\",是个程序员\"); &#125;&#125;var maidou =new Pet(\"麦兜\",25,\"coding\");//实例化、创建对象maidou.eat();//调用eat方法 4、用工厂方式来创建（内置对象） 1234567var wcDog =new Object(); wcDog.name=\"旺财\"; wcDog.age=3; wcDog.work=function()&#123; alert(\"我是\"+wcDog.name+\",汪汪汪......\"); &#125; wcDog.work(); 5、用原型方式来创建 123456789function Dog()&#123; &#125; Dog.prototype.name=\"旺财\"; Dog.prototype.eat=function()&#123; alert(this.name+\"是个吃货\"); &#125; var wangcai =new Dog(); wangcai.eat(); 6、用混合方式来创建 123456789function Car(name,price)&#123; this.name=name; this.price=price;&#125; Car.prototype.sell=function()&#123; alert(\"我是\"+this.name+\"，我现在卖\"+this.price+\"万元\"); &#125;var camry =new Car(\"凯美瑞\",27);camry.sell(); Javascript作用链域? 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链 谈谈This对象的理解。 this总是指向函数的直接调用者（而非间接调用者）； 如果有new关键字，this指向new出来的那个对象； 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window eval是做什么的？ 它的功能是把对应的字符串解析成JS代码并运行； 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行） 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’); 什么是window对象? 什么是document对象? window对象是指浏览器打开的窗口。 document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性 null，undefined 的区别？ null 表示一个对象是“没有值”的值，也就是值为“空”； undefined 表示一个变量声明了没有初始化(赋值)； undefined不是一个有效的JSON，而null是； undefined的类型(typeof)是undefined； null的类型(typeof)是object； Javascript将未赋值的变量默认值设为undefined； Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的 typeof undefined undefined : 是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined； 例如变量被声明了，但没有赋值时，就等于undefined typeof null //“object” null : 是一个对象(空对象, 没有任何属性和方法)； 例如作为函数的参数，表示该函数的参数不是对象； 注意： 在验证null时，一定要使用 === ，因为 == 无法分别 null 和 undefined null == undefined // true null === undefined // false 写一个通用的事件侦听器函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// event(事件)工具集，来源：github.com/markyunmarkyun.Event = &#123; // 页面加载完成后 readyEvent : function(fn) &#123; if (fn==null) &#123; fn=document; &#125; var oldonload = window.onload; if (typeof window.onload != 'function') &#123; window.onload = fn; &#125; else &#123; window.onload = function() &#123; oldonload(); fn(); &#125;; &#125; &#125;, // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) &#123; if (element.addEventListener) &#123; //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent('on' + type, function() &#123; handler.call(element); &#125;); &#125; else &#123; element['on' + type] = handler; &#125; &#125;, // 移除事件 removeEvent : function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.datachEvent) &#123; element.detachEvent('on' + type, handler); &#125; else &#123; element['on' + type] = null; &#125; &#125;, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;, // 取消事件的默认行为 preventDefault : function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 获取事件目标 getTarget : function(event) &#123; return event.target || event.srcElement; &#125;, // 获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent : function(e) &#123; var ev = e || window.event; if (!ev) &#123; var c = this.getEvent.caller; while (c) &#123; ev = c.arguments[0]; if (ev &amp;&amp; Event == ev.constructor) &#123; break; &#125; c = c.caller; &#125; &#125; return ev; &#125;&#125;; [“1”, “2”, “3”].map(parseInt) 答案是多少？ parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数 12345function parseInt(str, radix) &#123; return str+'-'+radix;&#125;;var a=[\"1\", \"2\", \"3\"];a.map(parseInt); // [\"1-0\", \"2-1\", \"3-2\"] 不能大于radix 因为二进制里面，没有数字3,导致出现超范围的radix赋值和不合法的进制解析，才会返回NaN所以[“1”, “2”, “3”].map(parseInt) 答案也就是：[1, NaN, NaN] 事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件 ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;） 什么是闭包（closure），为什么要用它？ 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部 闭包的特性： 函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 1234567891011121314151617//li节点的onclick事件都能正确的弹出当前被点击的li索引 &lt;ul id=\"testUL\"&gt; &lt;li&gt; index = 0&lt;/li&gt; &lt;li&gt; index = 1&lt;/li&gt; &lt;li&gt; index = 2&lt;/li&gt; &lt;li&gt; index = 3&lt;/li&gt;&lt;/ul&gt;&lt;script type=\"text/javascript\"&gt; var nodes = document.getElementsByTagName(\"li\"); for(i = 0;i&lt;nodes.length;i+= 1)&#123; nodes[i].onclick = (function(i)&#123; return function() &#123; console.log(i); &#125; //不用闭包的话，值每次都是4 &#125;)(i); &#125;&lt;/script&gt; 执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在 使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源 因为say667()的内部函数的执行需要依赖say667()中的变量 这是对闭包作用的非常直白的描述 123456789101112function say667() &#123; // Local variable that ends up within closure var num = 666; var sayAlert = function() &#123; alert(num); &#125; num++; return sayAlert;&#125; var sayAlert = say667(); sayAlert()//执行结果应该弹出的667 javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行, 使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。 默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值; 全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用； 消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同; 提高编译器效率，增加运行速度；为未来新版本的Javascript标准化做铺垫。 如何判断一个对象是否属于某个类？123if(a instanceof Person)&#123; alert('yes'); &#125; new操作符具体干了什么呢? 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 属性和方法被加入到 this 引用的对象中。 新创建的对象由 this 所引用，并且最后隐式的返回 this 123var obj = &#123;&#125;;obj.__proto__ = Base.prototype;Base.call(obj); Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？ javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员 使用方法： object.hasOwnProperty(proName) 其中参数object是必选项。一个对象的实例。 proName是必选项。一个属性名称的字符串值。 如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。 JSON 的了解？ JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小 如：{“age”:”12”, “name”:”back”} JSON字符串转换为JSON对象: 1234567var obj =eval('('+ str +')');var obj = str.parseJSON();var obj = JSON.parse(str);JSON对象转换为JSON字符串：var last=obj.toJSONString();var last=JSON.stringify(obj); js延迟加载的方式有哪些？ defer和async、动态创建DOM方式（用得最多）、按需异步载入js Ajax 是什么? 如何创建一个Ajax？ ajax的全称：Asynchronous Javascript And XML。 异步传输+js+xml 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验 (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象 (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息 (3)设置响应HTTP请求状态变化的函数 (4)发送HTTP请求 (5)获取异步调用返回的数据 (6)使用JavaScript和DOM实现局部刷新 Ajax 解决浏览器缓存问题？ 1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“If-Modified-Since”,”0”)。 2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)。 3、在URL后面加上一个随机数： “fresh=” + Math.random();。 4、在URL后面加上时间搓：”nowtime=” + new Date().getTime();。 5、如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录 同步和异步的区别? 同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性. 同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容 如何解决跨域问题? jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面 模块化开发怎么做？ 不暴露私有成员 12345678910111213var module1 = (function()&#123; var _count = 0; var m1 = function()&#123; //... &#125;; var m2 = function()&#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;; &#125;)(); AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？ Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中 区别： 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible CMD 推崇依赖就近，AMD 推崇依赖前置。看代码： 1234567891011121314151617// CMDdefine(function(require, exports, module) &#123; var a = require('./a') a.doSomething() // 此处略去 100 行 var b = require('./b') // 依赖可以就近书写 b.doSomething() // ...&#125;)// AMD 默认推荐define(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() // ...&#125;) 异步加载JS的方式有哪些？ (1) defer，只支持IE (2) async： (3) 创建script，插入到DOM中，加载完毕后callBack documen.write和 innerHTML的区别 document.write只能重绘整个页面 innerHTML可以重绘页面的一部分 DOM操作——怎样添加、移除、移动、复制、创建和查找节点? （1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 （2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //在已有的子节点前插入一个新的子节点 （3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性 .call() 和 .apply() 的区别？ 例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4); 注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。 123456789101112function add(a,b)&#123; alert(a+b);&#125;function sub(a,b)&#123; alert(a-b);&#125;add.call(sub,3,1); jquery.extend 与 jquery.fn.extend的区别？ jquery.extend 为jquery类添加类方法，可以理解为添加静态方法 jquery.fn.extend:源码中jquery.fn = jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数使用： jquery.extend扩展，需要通过jquery类来调用，而jquery.fn.extend扩展，所有jquery实例都可以直接调用 Jquery与jQuery UI 有啥区别？ jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等 jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件 提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等 jquery 中如何将数组转化为json字符串，然后再转化回来？ jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展： 12345678910$.fn.stringifyArray = function(array) &#123; return JSON.stringify(array)&#125;$.fn.parseArray = function(array) &#123; return JSON.parse(array)&#125;然后调用：$(\"\").stringifyArray(array) 针对 jQuery 的优化方法？ 基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。 频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好 比如：var str=$(“a”).attr(“href”); for (var i = size; i &lt; arr.length; i++) {} for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快： for (var i = size, length = arr.length; i &lt; length; i++) {} 如何判断当前脚本运行在浏览器还是node环境中？（阿里） this === window ? ‘browser’ : ‘node’; 通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中 jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢? jquery stop(): 如：$(“#div”).stop().animate({width:”100px”},100); 那些操作会造成内存泄漏？ 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环) JQuery一个对象可以同时绑定多个事件，这是如何实现的？ 多个事件同一个函数：$(&quot;div&quot;).on(&quot;click mouseover&quot;, function(){}); 多个事件不同函数 1234$(\"div\").on(&#123; click: function()&#123;&#125;, mouseover: function()&#123;&#125;&#125;); 知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么? Chrome,Safari浏览器内核 检测浏览器版本版本有哪些方式？ 功能检测、userAgent特征检测 比如：navigator.userAgent 12//\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36\" What is a Polyfill? polyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们 例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象 所有这些都是 W3C 地理位置 API 定义的对象和函数。因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发 一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。 做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？ 比如： html5shiv、Geolocation、Placeholder 使用JS实现获取文件扩展名？ 123function getFileExtension(filename) &#123; return filename.slice((filename.lastIndexOf(\".\") - 1 &gt;&gt;&gt; 0) + 2);&#125; String.lastIndexOf() 方法返回指定值（本例中的’.’）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。对于’filename’和’.hiddenfile’，lastIndexOf的返回值分别为0和-1无符号右移操作符(»&gt;) 将-1转换为4294967295，将-2转换为4294967294，这个方法可以保证边缘情况时文件名不变 String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为”” ECMAScript6 相关 Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？ 两等号判等，会在比较时进行类型转换； 三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）； Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。 其他问题 页面重构怎么操作？ 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 深层次的网站重构应该考虑的方面 减少代码间的耦合 让代码保持弹性 严格按规范编写代码 设计可扩展的API 代替旧有的框架、语言(如VB) 增强用户体验 通常来说对于速度的优化也包含在重构中 压缩JS、CSS、image等前端资源(通常是由服务器来解决) 程序的性能优化(如数据读写) 采用CDN来加速资源加载 对于JS DOM的优化 HTTP服务器的文件缓存 列举IE与其他浏览器不一样的特性？ 事件不同之处： 触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性； 获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性； 阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法； 停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation() 什么叫优雅降级和渐进增强？ 优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验 是否了解公钥加密和私钥加密 一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证; HTTP网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密 WEB应用从服务器主动推送Data到客户端有那些方式？ html5提供的Websocket 不可见的iframe WebSocket通过Flash XHR长时间连接 XHR Multipart Streaming 标签的长时间连接(可跨域) 对Node的优点和缺点提出了自己的看法？ （优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。 （缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。 你有用过哪些前端性能优化的方法？ （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 （4） 当需要设置的样式很多时设置className而不是直接操作style。 （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 （7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳 （8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢 对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的 http状态码有那些？分别代表是什么意思？ 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护） 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好） 注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、 到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等 详细版： 1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理; 2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法; 3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求; 4、进行HTTP协议会话，客户端发送报头(请求报头); 5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器; 6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理; 7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304; 8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存; 9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie; 10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。 简洁版： 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成 你用的得心应手用的熟练地编辑器&amp;开发环境是什么样子？ Sublime Text 3 + 相关插件编写前端代码 Google chrome 、Mozilla Firefox浏览器 +firebug - 兼容测试和预览页面UI、动画效果和交互功能 Node.js+Gulp git 用于版本控制和Code Review 对前端工程师这个职位是怎么样理解的？它的前景会怎么样？ 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。 1、实现界面交互 2、提升用户体验 3、有了Node.js，前端可以实现服务端的一些事情 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好 参与项目，快速高质量完成实现效果图，精确到1px； 与团队成员，UI设计，产品经理的沟通 做好的页面结构，页面重构和用户体验 处理hack，兼容、写出优美的代码格式 针对服务器的优化、拥抱最新前端技术平时如何管理你的项目？ 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等； 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 页面进行标注（例如 页面 模块 开始和结束）； CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； JS 分文件夹存放 命名以该JS功能为准的英文翻译。 图片采用整合的 images.png png8 格式文件使用 - 尽量整合在一起使用方便将来的管理说说最近最流行的一些东西吧？常去哪些网站？ ES6\\WebAssembly\\Node\\MVVM\\Web Components\\React\\React Native\\Webpack 组件化移动端（Android IOS）怎么做好用户体验? 清晰的视觉纵线、 信息的分组、极致的减法、 利用选择代替输入、 标签及文字的排布方式、 依靠明文确认密码、 合理的键盘利用、","tags":[{"name":"css","slug":"css","permalink":"https://jiaopianjun.cc/tags/css/"},{"name":"javascript","slug":"javascript","permalink":"https://jiaopianjun.cc/tags/javascript/"},{"name":"html","slug":"html","permalink":"https://jiaopianjun.cc/tags/html/"}]},{"title":"javascript要点","date":"2018-06-10T02:02:27.000Z","path":"2018/06/10/JavaScript要点.html","text":"JavaScript的组成 JavaScript 由以下三部分组成： ECMAScript（核心）：JavaScript 语言基础 DOM（文档对象模型）：规定了访问HTML和XML的接口 BOM（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法 JS的基本数据类型和引用数据类型 基本数据类型：undefined、null、boolean、number、string、symbol 引用数据类型：object、array、function检测浏览器版本版本有哪些方式？ 根据 navigator.userAgent // UA.toLowerCase().indexOf(‘chrome’) 根据 window 对象的成员 // ‘ActiveXObject’ in window介绍JS有哪些内置对象？ 数据封装类对象：Object、Array、Boolean、Number、String 其他对象：Function、Arguments、Math、Date、RegExp、Error ES6新增对象：Symbol、Map、Set、Promises、Proxy、Reflect说几条写JavaScript的基本规范？ 代码缩进，建议使用“四个空格”缩进 代码段使用花括号{}包裹 语句结束使用分号; 变量和函数在使用前进行声明 以大写字母开头命名构造函数，全大写命名常量 规范定义JSON对象，补全双引号 用{}和[]声明对象和数组如何编写高性能的JavaScript？ 遵循严格模式：”use strict”; 将js脚本放在页面底部，加快渲染页面 将js脚本将脚本成组打包，减少请求 使用非阻塞方式下载js脚本 尽量使用局部变量来保存全局变量 尽量减少使用闭包 使用 window 对象属性方法时，省略 window 尽量减少对象成员嵌套 缓存 DOM 节点的访问 通过避免使用 eval() 和 Function() 构造器 给 setTimeout() 和 setInterval() 传递函数而不是字符串作为参数 尽量使用直接量创建对象和数组 最小化重绘(repaint)和回流(reflow) 描述浏览器的渲染过程，DOM树和渲染树的区别？ 浏览器的渲染过程： 解析HTML构建 DOM(DOM树)，并行请求 css/image/js CSS 文件下载完成，开始构建 CSSOM(CSS树) CSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树) 布局(Layout)：计算出每个节点在屏幕中的位置 显示(Painting)：通过显卡把页面画到屏幕上 DOM树 和 渲染树 的区别： DOM树与HTML标签一一对应，包括head和隐藏元素 渲染树不包括head和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的css属性 重绘和回流（重排）的区别和关系？ 重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘 回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流 注意：JS获取Layout属性值（如：offsetLeft、scrollTop、getComputedStyle等）也会引起回流。因为浏览器需要通过回流计算最新值 回流必将引起重绘，而重绘不一定会引起回流 如何最小化重绘(repaint)和回流(reflow)？ 需要要对元素进行复杂的操作时，可以先隐藏(display:”none”)，操作完成后再显示 需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入document 缓存Layout属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流 尽量避免用table布局（table元素一旦触发回流就会导致table里所有的其它元素回流） 避免使用css表达式(expression)，因为每次调用都会重新计算值（包括加载页面） 尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color 批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx script 的位置是否会影响首屏显示时间？ 在解析 HTML 生成 DOM 过程中，js 文件的下载是并行的，不需要 DOM 处理到 script 节点。因此，script的位置不影响首屏显示的开始时间。 浏览器解析 HTML 是自上而下的线性过程，script作为 HTML 的一部分同样遵循这个原则 因此，script 会延迟 DomContentLoad，只显示其上部分首屏内容，从而影响首屏显示的完成时间 解释JavaScript中的作用域与变量声明提升？ JavaScript作用域： 在Java、C等语言中，作用域为for语句、if语句或{}内的一块区域，称为作用域； 而在 JavaScript 中，作用域为function(){}内的区域，称为函数作用域。 JavaScript变量声明提升： 在JavaScript中，函数声明与变量声明经常被JavaScript引擎隐式地提升到当前作用域的顶部。 声明语句中的赋值部分并不会被提升，只有名称被提升 函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明 如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数 介绍JavaScript的原型，原型链？有什么特点？ 原型： JavaScript的所有对象中都包含了一个 [proto] 内部属性，这个属性所对应的就是该对象的原型 JavaScript的函数对象，除了原型 [proto] 之外，还预置了 prototype 属性 当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [proto]。 原型链： 当一个对象调用的属性/方法自身不存在时，就会去自己 [proto] 关联的前辈 prototype 对象上去找 如果没找到，就会去该 prototype 原型 [proto] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链” 原型特点： JavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变 JavaScript有几种类型的值？，你能画一下他们的内存图吗 原始数据类型（Undefined，Null，Boolean，Number、String）– 栈 引用数据类型（对象、数组和函数）– 堆 两种类型的区别是：存储位置不同： 原始数据类型是直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据； 引用数据类型存储在堆(heap)中的对象，占据空间大、大小不固定，如果存储在栈中，将会影响程序运行的性能； 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 JavaScript如何实现一个类，怎么实例化这个类？ 构造函数法（this + prototype） – 用 new 关键字 生成实例对象 缺点：用到了 this 和 prototype，编写复杂，可读性差 123456789function Mobile(name, price)&#123; this.name = name; this.price = price; &#125; Mobile.prototype.sell = function()&#123; alert(this.name + \"，售价 $\" + this.price); &#125; var iPhone7 = new Mobile(\"iPhone7\", 1000); iPhone7.sell(); Object.create 法 – 用 Object.create() 生成实例对象 缺点：不能实现私有属性和私有方法，实例对象之间也不能共享数据 1234567891011121314151617181920var Person = &#123; firstname: \"Mark\", lastname: \"Yun\", age: 25, introduce: function()&#123; alert('I am ' + Person.firstname + ' ' + Person.lastname); &#125;&#125;;var person = Object.create(Person);person.introduce();// Object.create 要求 IE9+，低版本浏览器可以自行部署：if (!Object.create) &#123; Object.create = function (o) &#123; function F() &#123;&#125; F.prototype = o; return new F(); &#125;; &#125; 极简主义法（消除 this 和 prototype） – 调用 createNew() 得到实例对象 优点：容易理解，结构清晰优雅，符合传统的”面向对象编程”的构造 12345678910111213141516171819var Cat = &#123; age: 3, // 共享数据 -- 定义在类对象内，createNew() 外 createNew: function () &#123; var cat = &#123;&#125;; // var cat = Animal.createNew(); // 继承 Animal 类 cat.name = \"小咪\"; var sound = \"喵喵喵\"; // 私有属性--定义在 createNew() 内，输出对象外 cat.makeSound = function () &#123; alert(sound); // 暴露私有属性 &#125;; cat.changeAge = function(num)&#123; Cat.age = num; // 修改共享数据 &#125;; return cat; // 输出对象 &#125;&#125;;var cat = Cat.createNew();cat.makeSound(); ES6 语法糖 class – 用 new 关键字 生成实例对象 1234567891011 class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125; &#125;var point = new Point(2, 3); Javascript如何实现继承？ 构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上 12345function Cat(name,color)&#123; Animal.apply(this, arguments); this.name = name; this.color = color;&#125; 实例继承：将子对象的 prototype 指向父对象的一个实例 12Cat.prototype = new Animal();Cat.prototype.constructor = Cat; 拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象 12345678function extend(Child, Parent) &#123; var p = Parent.prototype; var c = Child.prototype; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p; &#125; 原型继承：将子对象的 prototype 指向父对象的 prototype 1234567function extend(Child, Parent) &#123; var F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype;&#125; ES6 语法糖 extends：class ColorPoint extends Point {} 123456789class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 调用父类的toString() &#125;&#125; Javascript作用链域? 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节 如果当前作用域没有找到属性或方法，会向上层作用域查找，直至全局函数，这种形式就是作用域链 谈谈this对象的理解 this 总是指向函数的直接调用者 如果有 new 关键字，this 指向 new 出来的实例对象 在事件中，this指向触发这个事件的对象 IE下 attachEvent 中的this总是指向全局对象Window eval是做什么的？eval的功能是把对应的字符串解析成JS代码并运行 应该避免使用eval，不安全，非常耗性能（先解析成js语句，再执行） 由JSON字符串转换为JSON对象的时候可以用 eval(‘(‘+ str +’)’); 什么是 Window 对象? 什么是 Document 对象? Window 对象表示当前浏览器的窗口，是JavaScript的顶级对象。 我们创建的所有对象、函数、变量都是 Window 对象的成员。 Window 对象的方法和属性是在全局范围内有效的。 Document 对象是 HTML 文档的根节点与所有其他节点（元素节点，文本节点，属性节点, 注释节点） Document 对象使我们可以通过脚本对 HTML 页面中的所有元素进行访问 Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问 介绍 DOM 的发展 DOM：文档对象模型（Document Object Model），定义了访问HTML和XML文档的标准，与编程语言及平台无关 DOM0：提供了查询和操作Web文档的内容API。未形成标准，实现混乱。如：document.forms[‘login’] DOM1：W3C提出标准化的DOM，简化了对文档中任意部分的访问和操作。如：JavaScript中的Document对象 DOM2：原来DOM基础上扩充了鼠标事件等细分模块，增加了对CSS的支持。如：getComputedStyle(elem, pseudo) DOM3：增加了XPath模块和加载与保存（Load and Save）模块。如：XPathEvaluator 介绍DOM0，DOM2，DOM3事件处理方式区别 DOM0级事件处理方式： btn.onclick = func; btn.onclick = null; DOM2级事件处理方式： btn.addEventListener(&#39;click&#39;, func, false); btn.removeEventListener(&#39;click&#39;, func, false); btn.attachEvent(&quot;onclick&quot;, func); btn.detachEvent(&quot;onclick&quot;, func); DOM3级事件处理方式： eventUtil.addListener(input, &quot;textInput&quot;, func); eventUtil 是自定义对象，textInput 是DOM3级事件 事件的三个阶段 捕获、目标、冒泡 介绍事件“捕获”和“冒泡”执行顺序和事件的执行次数？ 按照W3C标准的事件：首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段 事件执行次数（DOM2-addEventListener）：元素上绑定事件的个数 注意1：前提是事件被确实触发 注意2：事件绑定几次就算几个事件，即使类型和功能完全一样也不会“覆盖” 事件执行顺序：判断的关键是否目标元素 非目标元素：根据W3C的标准执行：捕获-&gt;目标元素-&gt;冒泡（不依据事件绑定顺序） 目标元素：依据事件绑定顺序：先绑定的事件先执行（不依据捕获冒泡标准） 最终顺序：父元素捕获-&gt;目标元素事件1-&gt;目标元素事件2-&gt;子元素捕获-&gt;子元素冒泡-&gt;父元素冒泡 注意：子元素事件执行前提 事件确实“落”到子元素布局区域上，而不是简单的具有嵌套关系 在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？ 该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数） 如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获 如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡 事件的代理/委托 事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件 优点： 可以减少事件注册，节省大量内存占用 可以将事件应用于动态添加的子元素上 缺点：使用不当会造成事件在不应该触发时触发 示例： 123456ulEl.addEventListener('click', function(e)&#123; var target = event.target || event.srcElement; if(!!target &amp;&amp; target.nodeName.toUpperCase() === \"LI\")&#123; console.log(target.innerHTML); &#125;&#125;, false); IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ IE只事件冒泡，不支持事件捕获；火狐同时支持件冒泡和事件捕获 IE的事件处理和W3C的事件处理有哪些区别？ 绑定事件 W3C: targetEl.addEventListener(‘click’, handler, false); IE: targetEl.attachEvent(‘onclick’, handler); 删除事件 W3C: targetEl.removeEventListener(‘click’, handler, false); IE: targetEl.detachEvent(event, handler); 事件对象 W3C: var e = arguments.callee.caller.arguments[0] IE: window.event 事件目标 W3C: e.target IE: window.event.srcElement 阻止事件默认行为 W3C: e.preventDefault() IE: window.event.returnValue = false 阻止事件传播 W3C: e.stopPropagation() IE: window.event.cancelBubble = true W3C事件的 target 与 currentTarget 的区别？ target 只会出现在事件流的目标阶段 currentTarget 可能出现在事件流的任何阶段 当事件流处在目标阶段时，二者的指向相同 当事件流处于捕获或冒泡阶段时：currentTarget 指向当前事件活动的对象(一般为父级) 如何派发事件(dispatchEvent)？（如何进行事件广播？） W3C: 使用 dispatchEvent 方法 IE: 使用 fireEvent 方法 12345678910var fireEvent = function(element, event)&#123; if (document.createEventObject)&#123; var mockEvent = document.createEventObject(); return element.fireEvent('on' + event, mockEvent) &#125;else&#123; var mockEvent = document.createEvent('HTMLEvents'); mockEvent.initEvent(event, true, true); return !element.dispatchEvent(mockEvent); &#125;&#125; 什么是函数节流？介绍一下应用场景和原理？ 函数节流(throttle)是指阻止一个函数在很短时间间隔内连续调用。只有当上一次函数执行后达到规定的时间间隔，才能进行下一次调用。但要保证一个累计最小调用间隔（否则拖拽类的节流都将无连续效果） 函数节流用于 onresize, onscroll 等短时间内会多次触发的事件 函数节流的原理：使用定时器做时间节流。当触发一个事件时，先用 setTimout 让这个事件延迟一小段时间再执行。如果在这个时间间隔内又触发了事件，就 clearTimeout 原来的定时器，再 setTimeout 一个新的定时器重复以上流程。 函数节流简单实现： 12345678910function throttle(method, context) &#123; clearTimeout(methor.tId); method.tId = setTimeout(function()&#123; method.call(context); &#125;， 100); // 两次调用至少间隔 100ms&#125;// 调用window.onresize = function()&#123; throttle(myFunc, window);&#125; 区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？ 客户区坐标：鼠标指针在可视区中的水平坐标(clientX)和垂直坐标(clientY) 页面坐标：鼠标指针在页面布局中的水平坐标(pageX)和垂直坐标(pageY) 屏幕坐标：设备物理屏幕的水平坐标(screenX)和垂直坐标(screenY) 如何获得一个DOM元素的绝对位置？ elem.offsetLeft：返回元素相对于其定位父级左侧的距离 elem.offsetTop：返回元素相对于其定位父级顶部的距离 elem.getBoundingClientRect()：返回一个DOMRect对象，包含一组描述边框的只读属性，单位像素 分析 [‘1’, ‘2’, ‘3’].map(parseInt) 答案是多少？ 答案:[1, NaN, NaN] parseInt(string, radix) 第2个参数 radix 表示进制。省略 radix 或 radix = 0，则数字将以十进制解析 map 每次为 parseInt 传3个参数(elem, index, array)，其中 index 为数组索引 因此，map 遍历 [“1”, “2”, “3”]，相应 parseInt 接收参数如下 123parseInt('1', 0); // 1parseInt('2', 1); // NaNparseInt('3', 2); // NaN 所以，parseInt 参数 radix 不合法，导致返回值为 NaN new 操作符具体干了什么？ 创建实例对象，this 变量引用该对象，同时还继承了构造函数的原型 属性和方法被加入到 this 引用的对象中 新创建的对象由 this 所引用，并且最后隐式的返回 this 用原生JavaScript的实现过什么功能吗？ 封装选择器、调用第三方API、设置和获取样式 解释一下这段代码的意思吗？ 123[].forEach.call($$(\"*\"), function(el)&#123; el.style.outline = \"1px solid #\" + (~~(Math.random()*(1&lt;&lt;24))).toString(16);&#125;) 解释：获取页面所有的元素，遍历这些元素，为它们添加1像素随机颜色的轮廓(outline) $$(sel) // $$函数被许多现代浏览器命令行支持，等价于 document.querySelectorAll(sel) [].forEach.call(NodeLists) // 使用 call 函数将数组遍历函数 forEach 应到节点元素列表 el.style.outline = &quot;1px solid #333&quot; // 样式 outline 位于盒模型之外，不影响元素布局位置 (1&lt;&lt;24) // parseInt(“ffffff”, 16) == 16777215 == 2^24 - 1 // 1&lt;&lt;24 == 2^24 == 16777216 Math.random()*(1&lt;&lt;24) // 表示一个位于 0 到 16777216 之间的随机浮点数 ~~Math.random()*(1&lt;&lt;24) // ~~ 作用相当于 parseInt 取整 (~~(Math.random()*(1&lt;&lt;24))).toString(16) // 转换为一个十六进制- JavaScript实现异步编程的方法？ 回调函数 事件监听 发布/订阅 Promises对象 Async函数[ES7] web开发中会话跟踪的方法有哪些 cookie session url重写 隐藏input ip地址 介绍js的基本数据类型 Undefined、Null、Boolean、Number、String 介绍js有哪些内置对象？ Object 是 JavaScript 中所有对象的父对象 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error 说几条写JavaScript的基本规范？ 不要在同一行声明多个变量 请使用 ===/!==来比较true/false或者数值 使用对象字面量替代new Array这种形式 不要使用全局函数 Switch语句必须带有default分支 函数不应该有时候有返回值，有时候没有返回值 If语句必须使用大括号 for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污 JavaScript原型，原型链 ? 有什么特点？ 每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念 关系：instance.constructor.prototype = instance.__proto__ 特点： JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象 JavaScript有几种类型的值？，你能画一下他们的内存图吗？ 栈：原始数据类型（Undefined，Null，Boolean，Number、String） 堆：引用数据类型（对象、数组和函数） 两种类型的区别是：存储位置不同； 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其 在栈中的地址，取得地址后从堆中获得实体 Javascript如何实现继承？ 构造继承 原型继承 实例继承 拷贝继承 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式 12345678910111213function Parent()&#123; this.name = 'wang'; &#125; function Child()&#123; this.age = 28; &#125; Child.prototype = new Parent();//继承了Parent，通过原型 var demo = new Child(); alert(demo.age); alert(demo.name);//得到被继承的属性 &#125; javascript创建对象的几种方式？ javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用 对象字面量的方式 1person=&#123;firstname:\"Mark\",lastname:\"Yun\",age:25,eyecolor:\"black\"&#125;; 用function来模拟无参的构造函数 12345678 function Person()&#123;&#125; var person=new Person();//定义一个function，如果使用new\"实例化\",该function可以看作是一个Class person.name=\"Mark\"; person.age=\"25\"; person.work=function()&#123; alert(person.name+\" hello...\"); &#125;person.work(); 用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性） 12345678910function Pet(name,age,hobby)&#123; this.name=name;//this作用域：当前对象 this.age=age; this.hobby=hobby; this.eat=function()&#123; alert(\"我叫\"+this.name+\",我喜欢\"+this.hobby+\",是个程序员\"); &#125; &#125; var maidou =new Pet(\"麦兜\",25,\"coding\");//实例化、创建对象 maidou.eat();//调用eat方法 用工厂方式来创建（内置对象） 1234567var wcDog =new Object(); wcDog.name=\"旺财\"; wcDog.age=3; wcDog.work=function()&#123; alert(\"我是\"+wcDog.name+\",汪汪汪......\"); &#125; wcDog.work(); 用原型方式来创建 123456789function Dog()&#123; &#125; Dog.prototype.name=\"旺财\"; Dog.prototype.eat=function()&#123; alert(this.name+\"是个吃货\"); &#125; var wangcai =new Dog(); wangcai.eat(); 用混合方式来创建 123456789function Car(name,price)&#123; this.name=name; this.price=price; &#125; Car.prototype.sell=function()&#123; alert(\"我是\"+this.name+\"，我现在卖\"+this.price+\"万元\"); &#125; var camry =new Car(\"凯美瑞\",27); camry.sell(); Javascript作用链域? 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找 直至全局函数，这种组织形式就是作用域链 谈谈This对象的理解 this总是指向函数的直接调用者（而非间接调用者） 如果有new关键字，this指向new出来的那个对象 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window eval是做什么的？ 它的功能是把对应的字符串解析成JS代码并运行 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行） 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’) null，undefined 的区别？ undefined 表示不存在这个值。 undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined 例如变量被声明了，但没有赋值时，就等于undefined null 表示一个对象被定义了，值为“空值” null : 是一个对象(空对象, 没有任何属性和方法) 例如作为函数的参数，表示该函数的参数不是对象； 在验证null时，一定要使用 === ，因为 == 无法分别 null 和 undefined 写一个通用的事件侦听器函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// event(事件)工具集，来源：github.com/markyun markyun.Event = &#123; // 页面加载完成后 readyEvent : function(fn) &#123; if (fn==null) &#123; fn=document; &#125; var oldonload = window.onload; if (typeof window.onload != 'function') &#123; window.onload = fn; &#125; else &#123; window.onload = function() &#123; oldonload(); fn(); &#125;; &#125; &#125;, // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) &#123; if (element.addEventListener) &#123; //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent('on' + type, function() &#123; handler.call(element); &#125;); &#125; else &#123; element['on' + type] = handler; &#125; &#125;, // 移除事件 removeEvent : function(element, type, handler) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.datachEvent) &#123; element.detachEvent('on' + type, handler); &#125; else &#123; element['on' + type] = null; &#125; &#125;, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;, // 取消事件的默认行为 preventDefault : function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 获取事件目标 getTarget : function(event) &#123; return event.target || event.srcElement; &#125;, // 获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent : function(e) &#123; var ev = e || window.event; if (!ev) &#123; var c = this.getEvent.caller; while (c) &#123; ev = c.arguments[0]; if (ev &amp;&amp; Event == ev.constructor) &#123; break; &#125; c = c.caller; &#125; &#125; return ev; &#125; &#125;; [“1”, “2”, “3”].map(parseInt) 答案是多少？ [1, NaN, NaN] 因为 parseInt 需要两个参数 (val, radix)，其中 radix 表示解析时用的基数。 map 传了 3 个 (element, index, array)，对应的 radix 不合法导致解析失败。 事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件 ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;） 什么是闭包（closure），为什么要用它？ 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域 闭包的特性： 函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 如何判断一个对象是否属于某个类？ 1234// 使用instanceof （待完善） if(a instanceof Person)&#123; alert('yes'); &#125; new操作符具体干了什么呢? 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型 属性和方法被加入到 this 引用的对象中 新创建的对象由 this 所引用，并且最后隐式的返回 this 123var obj = &#123;&#125;;obj.__proto__ = Base.prototype;Base.call(obj); js延迟加载的方式有哪些？ defer和async、动态创建DOM方式（用得最多）、按需异步载入js Ajax 是什么? 如何创建一个Ajax？ ajax的全称：Asynchronous Javascript And XML 异步传输+js+xml 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验 创建XMLHttpRequest对象,也就是创建一个异步调用对象 建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息 设置响应HTTP请求状态变化的函数 发送HTTP请求 获取异步调用返回的数据 用JavaScript和DOM实现局部刷新 同步和异步的区别? 同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容 异步加载JS的方式有哪些？ defer，只支持IE async： 创建script，插入到DOM中，加载完毕后callBack documen.write和 innerHTML的区别 document.write只能重绘整个页面 innerHTML可以重绘页面的一部分 DOM操作——怎样添加、移除、移动、复制、创建和查找节点? （1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 （2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //在已有的子节点前插入一个新的子节点 （3）查找 getElementsByTagName() //通过标签名称 getElementsByName() // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性 那些操作会造成内存泄漏？ 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 渐进增强和优雅降级 渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容 Javascript垃圾回收方法 标记清除（mark and sweep） 这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境” 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 引用计数(reference counting) 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间 js继承方式及其优缺点 原型链继承的缺点 一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。 借用构造函数（类式继承） 借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承 组合式继承 组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。 defer和async defer并行加载js文件，会按照页面上script标签的顺序执行async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行 用过哪些设计模式？ 工厂模式： 主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复 工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例-12345678910function createObject(name,age,profession)&#123;//集中实例化的函数var obj = new Object(); obj.name = name; obj.age = age; obj.profession = profession; obj.move = function () &#123; return this.name + ' at ' + this.age + ' engaged in ' + this.profession; &#125;; return obj;&#125;var test1 = createObject('trigkit4',22,'programmer');//第一个实例var test2 = createObject('mike',25,'engineer');//第二个实例 构造函数模式 使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于 构造函数方法没有显示的创建对象 (new Object()); 直接将属性和方法赋值给 this 对象; 没有 renturn 语句 说说你对闭包的理解 使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念 闭包有三个特性： 1.函数嵌套函数 2.函数内部可以引用外部的参数和变量 3.参数和变量不会被垃圾回收机制回收 请解释一下 JavaScript 的同源策略 概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议 指一段脚本只能读取来自同一来源的窗口和文档的属性 为什么要有同源限制？ 我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 缺点 现在网站的JS都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节 实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制 123456789101112Object.prototype.clone = function()&#123; var o = this.constructor === Array ? [] : &#123;&#125;; for(var e in this)&#123; o[e] = typeof this[e] === \"object\" ? this[e].clone() : this[e]; &#125; return o; &#125; 说说严格模式的限制 严格模式主要有以下限制： 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀0表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 如何删除一个cookie 将时间设为当前时间往前一点 123var date = new Date();date.setDate(date.getDate() - 1);//真正的删除 setDate()方法用于设置一个月的某一天 expires的设置 1document.cookie = 'user='+ encodeURIComponent('name') + ';expires = ' + new Date(0) 编写一个方法 求一个字符串的字节长度 假设：一个英文字符占用一个字节，一个中文字符占用两个字节 1234567891011121314151617function GetBytes(str)&#123; var len = str.length; var bytes = len; for(var i=0; i&lt;len; i++)&#123; if (str.charCodeAt(i) &gt; 255) bytes++; &#125; return bytes; &#125;alert(GetBytes(\"你好,as\")); 请解释什么是事件代理 事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能 attribute和property的区别是什么？ attribute是dom元素在文档中作为html标签拥有的属性； property就是dom元素在js中作为对象拥有的属性。 对于html的标准属性来说，attribute和property是同步的，是会自动更新的 但是对于自定义的属性来说，他们是不同步的 页面编码和被请求的资源编码如果不一致如何处理？ 后端响应头设置 charset 前端页面&lt;meta&gt;设置 charset 把&lt;script&gt;放在&lt;/body&gt;之前和之后有什么区别？浏览器会如何解析它们？ 按照HTML标准，在&lt;/body&gt;结束后出现&lt;script&gt;或任何元素的开始标签，都是解析错误 虽然不符合HTML标准，但浏览器会自动容错，使实际效果与写在&lt;/body&gt;之前没有区别 浏览器的容错机制会忽略之前的&lt;/body&gt;，视作&lt;script&gt;仍在 body 体内。省略&lt;/body&gt;和&lt;/html&gt;闭合标签符合HTML标准，服务器可以利用这一标准尽可能少输出内容 延迟加载JS的方式有哪些？ 设置&lt;script&gt;属性 defer=”defer” （脚本将在页面完成解析时执行） 动态创建 script DOM：document.createElement(‘script’); XmlHttpRequest 脚本注入 延迟加载工具 LazyLoad 异步加载JS的方式有哪些？ 设置&lt;script&gt;属性 async=”async” （一旦脚本可用，则会异步执行） 动态创建 script DOM：document.createElement(‘script’); XmlHttpRequest 脚本注入 异步加载库 LABjs 模块加载器 Sea.js JavaScript 中，调用函数有哪几种方式？ 方法调用模式 Foo.foo(arg1, arg2); 函数调用模式 foo(arg1, arg2); 构造器调用模式 (new Foo())(arg1, arg2); call/applay调用模式 Foo.foo.call(that, arg1, arg2); bind调用模式 Foo.foo.bind(that)(arg1, arg2)(); 简单实现 Function.bind 函数？ 12345678910111213if (!Function.prototype.bind) &#123; Function.prototype.bind = function(that) &#123; var func = this, args = arguments; return function() &#123; return func.apply(that, Array.prototype.slice.call(args, 1)); &#125; &#125;&#125;// 只支持 bind 阶段的默认参数：func.bind(that, arg1, arg2)();// 不支持以下调用阶段传入的参数：func.bind(that)(arg1, arg2); 列举一下JavaScript数组和对象有哪些原生方法？ 数组： arr.concat(arr1, arr2, arrn); arr.join(“,”); arr.sort(func); arr.pop(); arr.push(e1, e2, en); arr.shift(); unshift(e1, e2, en); arr.reverse(); arr.slice(start, end); arr.splice(index, count, e1, e2, en); arr.indexOf(el); arr.includes(el); // ES6 对象： object.hasOwnProperty(prop); object.propertyIsEnumerable(prop); object.valueOf(); object.toString(); object.toLocaleString(); Class.prototype.isPropertyOf(object); Array.splice() 与 Array.splice() 的区别？ slice – “读取”数组指定的元素，不会对原数组进行修改 语法：arr.slice(start, end) start 指定选取开始位置（含） end 指定选取结束位置（不含） splice “操作”数组指定的元素，会修改原数组，返回被删除的元素 语法：arr.splice(index, count, [insert Elements]) index 是操作的起始位置 count = 0 插入元素，count &gt; 0 删除元素 [insert Elements] 向数组新插入的元素 JavaScript 对象生命周期的理解？ 当创建一个对象时，JavaScript 会自动为该对象分配适当的内存 垃圾回收器定期扫描对象，并计算引用了该对象的其他对象的数量 如果被引用数量为 0，或惟一引用是循环的，那么该对象的内存即可回收 哪些操作会造成内存泄漏？ JavaScript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收 未使用 var 声明的全局变量 闭包函数(Closures) 循环引用(两个对象相互引用) 控制台日志(console.log) 移除存在绑定事件的DOM元素(IE)","tags":[{"name":"javascript","slug":"javascript","permalink":"https://jiaopianjun.cc/tags/javascript/"},{"name":"面试","slug":"面试","permalink":"https://jiaopianjun.cc/tags/面试/"}]},{"title":"HTML知识点","date":"2018-06-09T01:02:27.000Z","path":"2018/06/09/HTML.html","text":"语义化 HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构 css命名的语义化是指：为html标签添加有意义的class 为什么需要语义化： 去掉样式后页面呈现清晰的结构 盲人使用读屏器更好地阅读 搜索引擎更好地理解页面，有利于收录 便团队项目的可持续运作及维护 简述一下你对HTML语义化的理解？ 用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解 Doctype作用？标准模式与兼容模式各有什么区别? &lt;!DOCTYPE&gt;声明位于位于HTML文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现 标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作 HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？ HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行） 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 行内元素有：a b span img input select strong（强调的语气） 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p 常见的空元素:&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; 页面导入样式时，使用link和@import有什么区别？ link属于XHTML标签，除了加载CSS外，还能用于定义RSS,定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载 import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题 介绍一下你对浏览器内核的理解？ 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核 JS引擎则：解析和执行javascript来实现网页的动态效果 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎 常见的浏览器内核有哪些？ Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML] Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari,Chrome等。 [ Chrome的Blink（WebKit的分支）] html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加 绘画 canvas 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失 sessionStorage 的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如 article、footer、header、nav、section 表单控件，calendar、date、time、email、url、search 新的技术webworker, websocket, Geolocation 移除的元素： 纯表现的元素：basefont，big，center，font, s，strike，tt，u 对可用性产生负面影响的元素：frame，frameset，noframes 支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签 可以利用这一特性让这些浏览器支持HTML5新标签 浏览器支持新标签后，还需要添加标签默认的样式 当然也可以直接使用成熟的框架、比如html5shim 123&lt;!--[if lt IE 9]&gt;&lt;script&gt; src=\"http://html5shim.googlecode.com/svn/trunk/html5.js\"&lt;/script&gt;&lt;![endif]--&gt; 如何区分HTML5： DOCTYPE声明\\新增的结构元素\\功能元素 HTML5的离线储存怎么使用，工作原理能不能解释一下？ 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示 如何使用： 页面头部像下面一样加入一个manifest的属性； 在cache.manifest文件的编写离线存储的资源 在离线状态时，操作window.applicationCache进行需求实现123456789CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？ 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器就直接使用离线存储的资源。 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密） cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存 存储大小： cookie数据大小不能超过4k sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage 数据在当前浏览器窗口关闭后自动删除 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 iframe有那些缺点？ iframe会阻塞主页面的Onload事件 搜索引擎的检索程序无法解读这种页面，不利于SEO iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题 Label的作用是什么？是怎么用的？ label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件 HTML5的form如何关闭自动完成功能？ 给不想要提示的 form 或某个 input 设置为 autocomplete=off。 如何实现浏览器内多个标签页之间的通信? (阿里) WebSocket、SharedWorker 也可以调用localstorge、cookies等本地存储方式 webSocket如何兼容低浏览器？(阿里) Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR 页面可见性（Page Visibility API） 可以有哪些用途？ 通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等; 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放 如何在页面上实现一个圆形的可点击区域？ map+area或者svg border-radius 纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果 1&lt;div style=\"height:1px;overflow:hidden;background:red\"&gt;&lt;/div&gt; 网页验证码是干嘛的，是为了解决什么安全问题 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试 title与h1的区别、b与strong的区别、i与em的区别？ title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响 strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：会重读，而是展示强调内容 i内容展示为斜体，em表示强调的文本 页面导入样式时，使用 link 和 @import 有什么区别？ link 属于HTML标签，除了加载CSS外，还能用于定 RSS等；@import 只能用于加载CSS 页面加载的时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载 @import 只在 IE5 以上才能被识别，而 link 是HTML标签，无兼容问题 介绍一下你对浏览器内核的理解？ 浏览器内核主要分为两部分：渲染引擎(layout engineer 或 Rendering Engine) 和 JS引擎 渲染引擎负责取得网页的内容进行布局计和样式渲染，然后会输出至显示器或打印机 JS引擎则负责解析和执行JS脚本来实现网页的动态效果和用户交互 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎 常见的浏览器内核有哪些？ Blink内核：新版 Chrome、新版 Opera Webkit内核：Safari、原Chrome Gecko内核：FireFox、Netscape6及以上版本 Trident内核（又称MSHTML内核）：IE、国产浏览器 Presto内核：原Opera7及以上 HTML5有哪些新特性？ 新增选择器 document.querySelector、document.querySelectorAll 拖拽释放(Drag and drop) API 媒体播放的 video 和 audio 本地存储 localStorage 和 sessionStorage 离线应用 manifest 桌面通知 Notifications 语意化标签 article、footer、header、nav、section 增强表单控件 calendar、date、time、email、url、search 地理位置 Geolocation 多任务 webworker 全双工通信协议 websocket 历史管理 history 跨域资源共享(CORS) Access-Control-Allow-Origin 页面可见性改变事件 visibilitychange 跨窗口通信 PostMessage Form Data 对象 绘画 canvas HTML5移除了那些元素？ 纯表现的元素：basefont、big、center、font、s、strike、tt、u 对可用性产生负面影响的元素：frame、frameset、noframes 如何处理HTML5新标签的浏览器兼容问题？ 通过 document.createElement 创建新标签 使用垫片 html5shiv.js 如何区分 HTML 和 HTML5？ DOCTYPE声明、新增的结构元素、功能元素 HTML5的离线储存工作原理能不能解释一下，怎么使用？ HTML5的离线储存原理： 用户在线时，保存更新用户机器上的缓存文件；当用户离线时，可以正常访离线储存问站点或应用内容 HTML5的离线储存使用： 在文档的 html 标签设置 manifest 属性，如 manifest=”/offline.appcache” 在项目中新建 manifest 文件，manifest 文件的命名建议：xxx.appcache 在 web 服务器配置正确的 MIME-type，即 text/cache-manifest 浏览器是怎么对HTML5的离线储存资源进行管理和加载的？ 在线的情况下，浏览器发现 html 标签有 manifest 属性，它会请求 manifest 文件 如果是第一次访问app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储 如果已经访问过app且资源已经离线存储了，浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作。如果文件改变了，那么就会重新下载文件中的资源并进行离线存储 离线的情况下，浏览器就直接使用离线存储的资源。 iframe 有那些优点和缺点？ 优点： 用来加载速度较慢的内容（如广告） 可以使脚本可以并行下载 可以实现跨子域通信 缺点： iframe 会阻塞主页面的 onload 事件 无法被一些搜索引擎索识别 会产生很多页面，不容易管理 label 的作用是什么？怎么使用的？ label标签来定义表单控件的关系： 当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上 使用方法1： &lt;label for=&quot;mobile&quot;&gt;Number:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;mobile&quot;/&gt; 使用方法2： &lt;label&gt;Date:&lt;input type=&quot;text&quot;/&gt;&lt;/label&gt; 如何实现浏览器内多个标签页之间的通信？ iframe + contentWindow postMessage SharedWorker(Web Worker API) storage 事件(localStorge API) WebSocket webSocket 如何兼容低浏览器？ Adobe Flash Socket ActiveX HTMLFile (IE) 基于 multipart 编码发送 XHR 基于长轮询的 XHR 页面可见性（Page Visibility API） 可以有哪些用途？ 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放 当用户浏览其他页面，暂停网站首页幻灯自动播放 完成登陆后，无刷新自动同步其他页面的登录状态 title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？ title 表示是整个页面标题，h1 则表示层次明确的标题，对页面信息的抓取有很大的影响 strong 标明重点内容，有语气加强的含义，使用阅读设备阅读网络时，strong 会重读，而 b 是展示强调内容 i 内容展示为斜体，em 表示强调的文本 自然样式标签：b, i, u, s, pre 语义样式标签：strong, em, ins, del, code 应该准确使用语义样式标签, 但不能滥用。如果不能确定时，首选使用自然样式标签","tags":[{"name":"面试","slug":"面试","permalink":"https://jiaopianjun.cc/tags/面试/"},{"name":"html","slug":"html","permalink":"https://jiaopianjun.cc/tags/html/"}]},{"title":"Http基础知识","date":"2018-06-07T10:22:27.000Z","path":"2018/06/07/HTTP.html","text":"http状态码有那些？分别代表是什么意思？ 12345678910111213141516171819简单版 [ 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 ] 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好） 注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句， 而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、 到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等； 详细版： 浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理; 调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法; 通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求; 进行HTTP协议会话，客户端发送报头(请求报头); 进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器; 进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理; 处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304; 浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存; 文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie; 页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。 简洁版： 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成。 说说TCP传输的三次握手四次挥手策略 为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK 发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包 断开一个TCP连接则需要“四次握手”： 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号） 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手 TCP和UDP的区别 TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来 UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境 HTTP和HTTPS HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS 默认HTTP的端口号为80，HTTPS的端口号为443 为什么HTTPS安全 因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性 关于Http 2.0 你知道多少？ HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。 HTTP/2提供更多的加密支持 HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。 它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽 GET和POST的区别，何时使用POST？ GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符 POST：一般用于修改服务器上的资源，对所发送的信息没有限制。 GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 说说网络分层里七层模型是哪七层 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS） 传输层（TCP和UDP） 网络层（IP） 物理和数据链路层（以太网） 每一层的作用如下： 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）数据链路层：将比特组装成帧和点到点的传递（帧Frame） 网络层：负责数据包从源到宿的传递和网际互连（包PackeT） 传输层：提供端到端的可靠报文传递和错误恢复（段Segment） 会话层：建立、管理和终止会话（会话协议数据单元SPDU） 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU） 应用层：允许访问OSI环境的手段（应用协议数据单元APDU） 讲讲304缓存的原理 服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存 304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件 客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体 HTTP/2 与 HTTP/1.x 的关键区别 二进制协议代替文本协议，更加简洁高效 针对每个域只使用一个多路复用的连接 压缩头部信息减小开销 允许服务器主动推送应答到客户端的缓存中 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ 01.浏览器查找域名对应的IP地址(DNS 查询：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS 缓存-&gt;根域名服务器) 02.浏览器向 Web 服务器发送一个 HTTP 请求（TCP三次握手） 03.服务器 301 重定向（从 http://example.com 重定向到 http://www.example.com） 04.浏览器跟踪重定向地址，请求另一个带 www 的网址 05.服务器处理请求（通过路由读取资源） 06.服务器返回一个 HTTP 响应（报头中把 Content-type 设置为 ‘text/html’） 07.浏览器进 DOM 树构建 08.浏览器发送请求获取嵌在 HTML 中的资源（如图片、音频、视频、CSS、JS等） 09.浏览器显示完成页面 10.浏览器发送异步请求","tags":[{"name":"面试","slug":"面试","permalink":"https://jiaopianjun.cc/tags/面试/"},{"name":"http","slug":"http","permalink":"https://jiaopianjun.cc/tags/http/"}]},{"title":"有一个已经排序的数组，比方[1,4,6,9,11,15,18],给你一个新的数，插入到数组中，写一个function","date":"2018-06-06T07:03:53.000Z","path":"2018/06/06/有一个已经排序的数组，比方-1-4-6-9-11-15-18-给你一个新的数，插入到数组中，写一个function.html","text":"123456789101112var arr = [1,4,6,9,11,15,18], key = 10function t(arr,key)&#123; for(var i in arr)&#123; if(arr[i] &gt; key)&#123; return arr.splice(i,0,key) &#125;else&#123; return arr.push(key) &#125; &#125; return arr&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"https://jiaopianjun.cc/tags/javascript/"}]},{"title":"排序","date":"2018-06-06T07:02:40.000Z","path":"2018/06/06/排序.html","text":"123456789101112131415161718var a = [1,12,312,132,132,13,21,3]1. 冒泡function mp(arr)&#123; for(var i = 0; i &lt; arr.length - 1; i++)&#123; for(var j = 0; j &lt; arr.length -i; j++)&#123; if(a[j] &lt; a[j-1])&#123; var temp = a[j]; a[j] = a[j-1]; a[j-1] = temp &#125; &#125; &#125; return arr&#125;2. 二分 123456789101112131415161718function ef(arr)&#123; for(var i = 1;i &lt; arr.length -1; i++)&#123; var k = arr[i], low = 0, high = i - 1; while(low &lt;= high)&#123; var m = parseInt((low + high) / 2); if(arr[m] &lt; k)&#123; low = m + 1 &#125;else&#123; high = m -1 &#125; &#125; for(var j = i-1; j &gt;= low; j--)&#123; arr[j+1] = arr[j] &#125; arr[low] = k &#125; return arr&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"https://jiaopianjun.cc/tags/javascript/"}]},{"title":"Css要点","date":"2018-06-05T10:02:27.000Z","path":"2018/06/05/CSS.html","text":"display: none 与 visibility: hidden 的区别123456789相同：它们都能让元素不可见区别： display:none 会让元素完全从渲染树中消失，渲染的时候不占据任何空间； visibility:hidden 不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见 display:none 是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示 visibility:hidden 是继承属性，子孙节点消失由于继承了 hidden,通过设置 visibility: visible可以让子孙节点显式 修改常规流中元素的 display 通常会造成文档重排。修改visibility属性只会造成本元素的重绘 读屏器不会读取 display:none元素内容,会读取 visibility:hidden 元素内容 css hack原理及常用hack12345- 原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。- 常见的hack有 - 属性hack - 选择器hack - IE条件注释 link 与 @import 的区别123456- link 是HTML方式, @import 是CSS方式- link 最大限度支持并行下载, @import过多嵌套导致串行下载,出现FOUC- link 可以通过 rel=\"alternate stylesheet\" 指定候选样式- 浏览器对 link 支持早于 @import ,可以使用 @import 对老浏览器隐藏样式- @import必须在样式规则之前,可以在css文件中引用其他文件- 总体来说：link优于@import CSS有哪些继承属性123456789101112131415- 关于文字排版的属性如： - font - word-break - letter-spacing - text-align - text-rendering - word-spacing - white-space - text-indent - text-transform - text-shadow - line-height - color - visibility - cursor display,float,position的关系12345- 如果 display 为none，那么position和float都不起作用，这种情况下元素不产生框- 否则，如果position值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整- 否则，如果float不是none，框是浮动的，display根据下表进行调整- 否则，如果元素是根元素，display根据下表进行调整- 其他情况下display的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整 display 外边距折叠(collapsing margins)12345- 毗邻的两个或多个 margin 会合并成一个margin，叫做外边距折叠。规则如下： - 两个或多个毗邻的普通流中的块元素垂直方向上的margin会折叠 - 浮动元素或inline-block元素或绝对定位元素的margin不会和垂直方向上的其他元素的margin折叠 - 创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠 - 元素自身的margin-bottom和margin-top相邻时也会折 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？123- 有两种， IE 盒子模型、W3C 盒子模型；- 盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；- 区 别： IE的content部分把 border 和 padding计算了进去; CSS选择符有哪些？哪些属性可以继承？1234567891011- id选择器（ # myid）- 类选择器（.myclassname）- 标签选择器（div, h1, p）- 相邻选择器（h1 + p）- 子选择器（ul &gt; li）- 后代选择器（li a）- 通配符选择器（ * ）- 属性选择器（a[rel = \"external\"]）- 伪类选择器（a:hover, li:nth-child）- 可继承的样式： `font-size font-family color, UL LI DL DD DT`- 不可继承的样式：`border padding margin width height ` CSS优先级算法如何计算？123- 优先级就近原则，同权重情况下样式定义最近者为准- 载入样式以最后载入的定位为准- 优先级为: `!important &gt; id &gt; class &gt; tag` important 比 内联优先级高 CSS3新增伪类有那些？12345678910p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。:after 在元素之前添加内容,也可以用来做清除浮动。:before 在元素之后添加内容:enabled :disabled 控制表单控件的禁用状态。:checked 单选框或复选框被选中 如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？123456789101112131415161718192021222324252627282930313233343536- 给`div`设置一个宽度，然后添加`margin:0 auto`属性 div&#123; width:200px; margin:0 auto; &#125;- 居中一个浮动元素 //确定容器的宽高 宽500 高 300 的层 设置层的外边距 .div &#123; width:500px ; height:300px; //高度可以不设 margin: -150px 0 0 -250px; position:relative; //相对定位 background-color:pink; //方便看效果 left:50%; top:50%; &#125; - 让绝对定位的div居中 .div&#123; position: absolute; width: 1200px; background: none; margin: 0 auto; top: 0; left: 0; bottom: 0; right: 0; &#125;- 利用 transfrom:translate(-50%,-50%) .div&#123; width:200px; height:200px; position:absolute; left:50%; top:50%; transfrom:translate(-50%,-50%) &#125; display有哪些值？说明他们的作用123456- block 象块类型元素一样显示。- none 缺省值。象行内元素类型一样显示。- inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。- list-item 象块类型元素一样显示，并添加样式列表标记。- table 此元素会作为块级表格来显示- inherit 规定应该从父元素继承 display 属性的值 position的值relative和absolute定位原点是？12345678910- absolute - 生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。- fixed （老IE不支持） - 生成绝对定位的元素，相对于浏览器窗口进行定位。- relative - 生成相对定位的元素，相对于其正常位置进行定位。- static - 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right - z-index 声明）。- inherit - 规定从父元素继承 position 属性的值 CSS3有哪些新特性？12345678910- 新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）- 圆角 （border-radius:8px）- 多列布局 （multi-column layout）- 阴影和反射 （Shadow\\Reflect）- 文字特效 （text-shadow、）- 文字渲染 （Text-decoration）- 线性渐变 （gradient）- 旋转 （transform）- 增加了旋转,缩放,定位,倾斜,动画，多背景- `transform:\\scale(0.85,0.90)\\ translate(0px,-30px)\\ skew(-9deg,0deg)\\Animation:` 用纯CSS创建一个三角形的原理是什么？12345678// 把上、左、右三条边隐藏掉（颜色设为 transparent）#demo &#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent;&#125; 一个满屏 品 字布局 如何设计?1234- 简单的方式： - 上面的div宽100%， - 下面的两个div分别宽50%， - 然后用float或者inline使其不换行即可 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？12345678910111213- png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.- 浏览器默认的margin和padding不同。解决方案是加一个全局的*&#123;margin:0;padding:0;&#125;来统一- IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;- Firefox下,只能使用getAttribute()获取自定义属性。 - 解决方法:统一通过getAttribute()获取自定义属性 - IE下,even对象有x,y属性,但是没有pageX,pageY属性- Firefox下,event对象有pageX,pageY属性,但是没有x,y属性 li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？1- 行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了 为什么要初始化CSS样式1- 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异 对BFC规范(块级格式化上下文：block formatting context)的理解？12- 一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型- 不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响 css定义的权重123456789101112131415161718192021// 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下/// 例子是演示各种定义的权重值：/*权重为1*/div&#123;&#125;/*权重为10*/.class1&#123;&#125;/*权重为100*/#id1&#123;&#125;/*权重为100+1=101*/#id1 div&#123;&#125;/*权重为10+1=11*/.class1 div&#123;&#125;/*权重为10+10+1=21*/.class1 .class2 div&#123;&#125;// 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现 display:inline-block 什么时候会显示间隙？(携程)1- 移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing 谈谈浮动和清除浮动1- 浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？12345* 盒子模型构成：内容(content)、内填充(padding)、 边框(border)、外边距(margin)* IE8及其以下版本浏览器，未声明 DOCTYPE，内容宽高会包含内填充和边框，称为怪异盒模型(IE盒模型)* 标准(W3C)盒模型：元素宽度 = width + padding + border + margin* 怪异(IE)盒模型：元素宽度 = width + margin* 标准浏览器通过设置 css3 的 box-sizing: border-box 属性，触发“怪异模式”解析计算宽高 box-sizing 常用的属性有哪些？分别有什么作用？123* box-sizing: content-box; // 默认的标准(W3C)盒模型元素效果* box-sizing: border-box; // 触发怪异(IE)盒模型元素的效果* box-sizing: inherit; // 继承父元素 box-sizing 属性的值 CSS选择器有哪些？123456789* id选择器 #id* 类选择器 .class* 标签选择器 div, h1, p* 相邻选择器 h1 + p* 子选择器 ul &gt; li* 后代选择器 li a* 通配符选择器 ** 属性选择器 a[rel='external']* 伪类选择器 a:hover, li:nth-child CSS哪些属性可以继承？哪些属性不可以继承？12* 可以继承的样式：font-size、font-family、color、list-style、cursor* 不可继承的样式：width、height、border、padding、margin、background CSS如何计算选择器优先？1234* 相同权重，定义最近者为准：行内样式 &gt; 内部样式 &gt; 外部样式* 含外部载入样式时，后载入样式覆盖其前面的载入的样式和内部样式* 选择器优先级: 行内样式[1000] &gt; id[100] &gt; class[10] &gt; Tag[1]* 在同一组属性设置中，!important 优先级最高，高于行内样式 CSS3新增伪类有哪些？12345678910111213141516171819202122232425262728- :root 选择文档的根元素，等同于 html 元素- :empty 选择没有子元素的元素- :target 选取当前活动的目标元素- :not(selector) 选择除 selector 元素意外的元素- :enabled 选择可用的表单元素- :disabled 选择禁用的表单元素- :checked 选择被选中的表单元素- :after 在元素内部最前添加内容- :before 在元素内部最后添加内容- :nth-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n- :nth-last-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n，从后向前数- :nth-child(odd)- :nth-child(even)- :nth-child(3n+1)- :first-child- :last-child- :only-child- :nth-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第n- :nth-last-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第n，从后向前数- :nth-of-type(odd)- :nth-of-type(even)- :nth-of-type(3n+1)- :first-of-type- :last-of-type- :only-of-type- ::selection 选择被用户选取的元素部分- :first-line 选择元素中的第一行- :first-letter 选择元素中的第一个字符 请列举几种隐藏元素的方法12345678* visibility: hidden; 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在* opacity: 0; CSS3属性，设置0可以使一个元素完全透明* position: absolute; 设置一个很大的 left 负值定位，使元素定位在可见区域之外* display: none; 元素会变得不可见，并且不会再占用文档的空间。* transform: scale(0); 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留* &lt;div hidden=\"hidden\"&gt; HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态* height: 0; 将元素高度设为 0 ，并消除边框* filter: blur(0); CSS3属性，将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中 rgba() 和 opacity 的透明效果有什么不同？12* opacity 作用于元素以及元素内的所有内容（包括文字）的透明度* rgba() 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果 css 属性 content 有什么作用？1- content 属性专门应用在 before/after 伪元素上，用于插入额外内容或样式 CSS3有哪些新特性？123456789101112131415161718192021- 新增选择器 p:nth-child(n)&#123;color: rgba(255, 0, 0, 0.75)&#125;- 弹性盒模型 display: flex;- 多列布局 column-count: 5;- 媒体查询 @media (max-width: 480px) &#123;.box: &#123;column-count: 1;&#125;&#125;- 个性化字体 @font-face&#123;font-family: BorderWeb; src:url(BORDERW0.eot);&#125;- 颜色透明度 color: rgba(255, 0, 0, 0.75);- 圆角 border-radius: 5px;- 渐变 background:linear-gradient(red, green, blue);- 阴影 box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3);- 倒影 box-reflect: below 2px;- 文字装饰 text-stroke-color: red;- 文字溢出 text-overflow:ellipsis;- 背景效果 background-size: 100px 100px;- 边框效果 border-image:url(bt_blue.png) 0 10;- 转换 - 旋转 transform: rotate(20deg); - 倾斜 transform: skew(150deg, -10deg); - 位移 transform: translate(20px, 20px); - 缩放 transform: scale(.5);- 平滑过渡 transition: all .3s ease-in .1s;- 动画 @keyframes anim-1 &#123;50% &#123;border-radius: 50%;&#125;&#125; animation: anim-1 1s; 请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景？1- Flexbox 用于不同尺寸屏幕中创建可自动扩展和收缩布局 经常遇到的浏览器的JS兼容性有哪些？解决方法是什么？12345* 当前样式：getComputedStyle(el, null) VS el.currentStyle* 事件对象：e VS window.event* 鼠标坐标：e.pageX, e.pageY VS window.event.x, window.event.y* 按键码：e.which VS event.keyCode* 文本节点：el.textContent VS el.innerText li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？12* li排列受到中间空白(回车/空格)等的影响，因为空白也属于字符，会被应用样式占据空间，产生间隔* 解决办法：在ul设置设置font-size=0,在li上设置需要的文字大小 什么是外边距重叠？ 重叠的结果是什么？12345678* 外边距重叠就是 margin-collapse* 相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距* 折叠结果遵循下列计算规则： - 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值 - 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值 - 两个外边距一正一负时，折叠结果是两者的相加的和 请写出多种等高布局123* 在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假像* 模仿表格布局等高列效果：兼容性不好，在ie6-7无法正常运行* css3 flexbox 布局： .container&#123;display: flex; align-items: stretch;&#125; css垂直居中的方法有哪些？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354* 如果是单行文本, line-height 设置成和 height 值 .vertical &#123; height: 100px; line-height: 100px; &#125; * 已知高度的块级子元素，采用绝对定位和负边距 .container &#123; position: relative; &#125; .vertical &#123; height: 300px; /*子元素高度*/ position: absolute; top:50%; /*父元素高度50%*/ margin-top: -150px; /*自身高度一半*/ &#125; * 未知高度的块级父子元素居中，模拟表格布局* 缺点：IE67不兼容，父级 overflow：hidden 失效 .container &#123; display: table; &#125; .content &#123; display: table-cell; vertical-align: middle; &#125; * 新增 inline-block 兄弟元素，设置 vertical-align - 缺点：需要增加额外标签，IE67不兼容 .container &#123; height: 100%;/*定义父级高度，作为参考*/ &#125; .extra .vertical&#123; display: inline-block; /*行内块显示*/ vertical-align: middle; /*垂直居中*/ &#125; .extra &#123; height: 100%; /*设置新增元素高度为100%*/ &#125;* 绝对定位配合 CSS3 位移 .vertical &#123; position: absolute; top:50%; /*父元素高度50%*/ transform:translateY(-50%, -50%); &#125;* CSS3弹性盒模型 .container &#123; display:flex; justify-content: center; /*子元素水平居中*/ align-items: center; /*子元素垂直居中*/ &#125; 圣杯布局的实现原理123456789101112131415161718192021222324252627* 要求：三列布局；中间主体内容前置，且宽度自适应；两边内容定宽 * 好处：重要的内容放在文档流前面可以优先渲染 * 原理：利用相对定位、浮动、负边距布局，而不添加额外标签 css .container &#123; padding-left: 150px; padding-right: 190px; &#125; .main &#123; float: left; width: 100%; &#125; .left &#123; float: left; width: 190px; margin-left: -100%; position: relative; left: -150px; &#125; .right &#123; float: left; width: 190px; margin-left: -190px; position: relative; right: -190px; &#125; 什么是双飞翼布局？实现原理？123456789101112131415161718192021222324252627282930- 双飞翼布局：对圣杯布局（使用相对定位，对以后布局有局限性）的改进，消除相对定位布局- 原理：主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位，消除相对定位。css .container &#123; /*padding-left:150px;*/ /*padding-right:190px;*/ &#125; .main-wrap &#123; width: 100%; float: left; &#125; .main &#123; margin-left: 150px; margin-right: 190px; &#125; .left &#123; float: left; width: 150px; margin-left: -100%; /*position: relative;*/ /*left:-150px;*/ &#125; .right &#123; float: left; width: 190px; margin-left: -190px; /*position:relative;*/ /*right:-190px;*/ &#125; 在CSS样式中常使用 px、em 在表现上有什么区别？12* px 相对于显示器屏幕分辨率，无法用浏览器字体放大功能* em 值并不是固定的，会继承父级的字体大小： em = 像素值 / 父级font-size 为什么要初始化CSS样式？123* 不同浏览器对有些标签样式的默认值解析不同* 不初始化CSS会造成各现浏览器之间的页面显示差异* 可以使用 reset.css 或 Normalize.css 做 CSS 初始化 解释下什么是浮动和它的工作原理？12345* 非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。* 工作原理： - 浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象） - 浮动元素碰到包含它的边框或者其他浮动元素的边框停留 浮动元素引起的问题？12* 父元素的高度无法被撑开，影响与父元素同级的元素* 与浮动元素同级的非浮动元素会跟随其后 列举几种清除浮动的方式？12345* 添加额外标签，例如 `&lt;div style=\"clear:both\"&gt;&lt;/div&gt;`* 使用 br 标签和其自身的 clear 属性，例如 `&lt;br clear=\"all\" /&gt;`* 父元素设置 overflow：hidden; 在IE6中还需要触发 hasLayout，例如zoom：1;* 父元素也设置浮动* 使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout 清除浮动最佳实践（after伪元素闭合浮动）：123456789.clearfix:after&#123; content: \"\\200B\"; display: table; height: 0; clear: both;&#125;.clearfix&#123; *zoom: 1;&#125; 什么是 FOUC(Flash of Unstyled Content)？ 如何来避免 FOUC？12345* 当使用 @import 导入 CSS 时，会导致某些页面在 IE 出现奇怪的现象：没有样式的页面内容显示瞬间闪烁，这种现象称为“文档样式短暂失效”，简称为FOUC * 产生原因：当样式表晚于结构性html加载时，加载到此样式表时，页面将停止之前的渲染。 * 等待此样式表被下载和解析后，再重新渲染页面，期间导致短暂的花屏现象。 * 解决方法：使用 link 标签将样式表放在文档 head 介绍使用过的 CSS 预处理器？1234* CSS 预处理器基本思想：为 CSS 增加了一些编程的特性（变量、逻辑判断、函数等）* 开发者使用这种语言进行进行 Web 页面样式设计，再编译成正常的 CSS 文件使用* 使用 CSS 预处理器，可以使 CSS 更加简洁、适应性更强、可读性更佳，无需考虑兼容性* 最常用的 CSS 预处理器语言包括：Sass（SCSS）和 LESS CSS优化、提高性能的方法有哪些？12345678910* 多个css合并，尽量减少HTTP请求* 将css文件放在页面最上面* 移除空的css规则* 避免使用CSS表达式* 选择器优化嵌套，尽量避免层级过深* 充分利用css继承属性，减少代码量* 抽象提取公共样式，减少代码量* 属性值为0时，不加单位* 属性值为小于1的小数时，省略小数点前面的0* css雪碧图 浏览器是怎样解析CSS选择器的？1- 浏览器解析 CSS 选择器的方式是从右到左 在网页中的应该使用奇数还是偶数的字体？1234- 在网页中的应该使用“偶数”字体： * 偶数字号相对更容易和 web 设计的其他部分构成比例关系 * 使用奇数号字体时文本段落无法对齐 * 宋体的中文网页排布中使用最多的就是 12 和 14 margin和padding分别适合什么场景使用？12* 需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin* 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding 抽离样式模块怎么写，说出思路？123- CSS可以拆分成2部分：公共CSS 和 业务CSS： - 网站的配色，字体，交互提取出为公共CSS。这部分CSS命名不应涉及具体的业务 - 对于业务CSS，需要有统一的命名，使用公用的前缀。可以参考面向对象的CSS 元素竖向的百分比设定是相对于容器的高度吗？ 元素竖向的百分比设定是相对于容器的宽度，而不是高度12 全屏滚动的原理是什么？ 用到了CSS的那些属性？12* 原理类似图片轮播原理，超出隐藏部分，滚动时显示* 可能用到的CSS属性：overflow:hidden; transform:translate(100%, 100%); display:none; 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？12345678910111213141516171819202122* 响应式设计就是网站能够兼容多个终端，而不是为每个终端做一个特定的版本* 基本原理是利用CSS3媒体查询，为不同尺寸的设备适配不同样式* 对于低版本的IE，可采用JS获取屏幕宽度，然后通过resize方法来实现兼容：javascript $(window).resize(function () &#123; screenRespond(); &#125;); screenRespond(); function screenRespond()&#123; var screenWidth = $(window).width(); if(screenWidth &lt;= 1800)&#123; $(\"body\").attr(\"class\", \"w1800\"); &#125; if(screenWidth &lt;= 1400)&#123; $(\"body\").attr(\"class\", \"w1400\"); &#125; if(screenWidth &gt; 1800)&#123; $(\"body\").attr(\"class\", \"\"); &#125; &#125; 什么是视差滚动效果，如何给每页做不同的动画？1234567* 视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，具有非常出色的视觉体验 * 一般把网页解剖为：背景层、内容层和悬浮层。当滚动鼠标滚轮时，各图层以不同速度移动，形成视差的 * 实现原理 - 以 “页面滚动条” 作为 “视差动画进度条” - 以 “滚轮刻度” 当作 “动画帧度” 去播放动画的 - 监听 mousewheel 事件，事件被触发即播放动画，实现“翻页”效果 a标签上四个伪类的执行顺序是怎么样的？123link &gt; visited &gt; hover &gt; activeL-V-H-A love hate 用喜欢和讨厌两个词来方便记忆 伪元素和伪类的区别和作用？12345678910- 伪元素 -- 在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。- 它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如： p::before &#123;content:\"第一章：\";&#125; p::after &#123;content:\"Hot!\";&#125; p::first-line &#123;background:red;&#125; p::first-letter &#123;font-size:30px;&#125;- 伪类 -- 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如： a:hover &#123;color: #FF00FF&#125; p:first-child &#123;color: red&#125; ::before 和 :after 中双冒号和单冒号有什么区别？12345* 在 CSS 中伪类一直用 : 表示，如 :hover, :active 等* 伪元素在CSS1中已存在，当时语法是用 : 表示，如 :before 和 :after* 后来在CSS3中修订，伪元素用 :: 表示，如 ::before 和 ::after，以此区分伪元素和伪类* 由于低版本IE对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素* 综上所述：::before 是 CSS3 中写伪元素的新语法； :after 是 CSS1 中存在的、兼容IE的老语法 如何修改Chrome记住密码后自动填充表单的黄色背景？123- 产生原因：由于Chrome默认会给自动填充的input表单加上 input:-webkit-autofill 私有属性造成的- 解决方案1：在form标签上直接关闭了表单的自动填充：autocomplete=\"off\"- 解决方案2：input:-webkit-autofill &#123; background-color: transparent; &#125; input [type=search] 搜索框右侧小图标如何美化？12345678input[type=\"search\"]::-webkit-search-cancel-button&#123; -webkit-appearance: none; height: 15px; width: 15px; border-radius: 8px; background:url(\"images/searchicon.png\") no-repeat 0 0; background-size: 15px 15px;&#125; 网站图片文件，如何点击下载？而非点击预览？&lt;a href=&quot;logo.jpg&quot; download&gt;下载&lt;/a&gt;&lt;a href=&quot;logo.jpg&quot; download=&quot;网站LOGO&quot; &gt;下载&lt;/a&gt; iOS safari 如何阻止“橡皮筋效果”？1234567$(document).ready(function()&#123; var stopScrolling = function(event) &#123; event.preventDefault(); &#125; document.addEventListener('touchstart', stopScrolling, false); document.addEventListener('touchmove', stopScrolling, false);&#125;); 你对 line-height 是如何理解的？12345* line-height 指一行字的高度，包含了字间距，实际上是下一行基线到上一行基线距离* 如果一个标签没有定义 height 属性，那么其最终表现的高度是由 line-height 决定的* 一个容器没有设置高度，那么撑开容器高度的是 line-height 而不是容器内的文字内容* 把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中* line-height 和 height 都能撑开一个高度，height 会触发 haslayout，而 line-height 不会 line-height 三种赋值方式有何区别？（带单位、纯数字、百分比）123* 带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高* 纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px* 百分比：将计算后的值传递给后代 设置元素浮动后，该元素的 display 值会如何变化？1- 设置元素浮动后，该元素的 display 值自动变成 block 怎么让Chrome支持小于12px 的文字？12345.shrink&#123; -webkit-transform:scale(0.8); -o-transform:scale(1); display:inline-block;&#125; 让页面里的字体变清晰，变细用CSS怎么做？（IOS手机浏览器字体齿轮设置）1-webkit-font-smoothing: antialiased; font-style 属性 oblique 是什么意思？1- font-style: oblique; 使没有 italic 属性的文字实现倾斜 如果需要手动写动画，你认为最小时间间隔是多久？1- 16.7ms 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔: 1s / 60 * 1000 ＝ 16.7ms display:inline-block 什么时候会显示间隙？12345* 相邻的 inline-block 元素之间有换行或空格分隔的情况下会产生间距* 非 inline-block 水平元素设置为 inline-block 也会有水平间距* 可以借助 vertical-align:top; 消除垂直间隙* 可以在父级加 font-size：0; 在子元素里设置需要的字体大小，消除垂直间隙* 把 li 标签写到同一行可以消除垂直间隙，但代码可读性差 overflow: scroll 时不能平滑滚动的问题怎么处理？1- 监听滚轮事件，然后滚动到一定距离时用 jquery 的 animate 实现平滑效果。 一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度12345678- 方案1： .sub &#123; height: calc(100%-100px); &#125;` - 方案2： .container &#123; position:relative; &#125; .sub &#123; position: absolute; top: 100px; bottom: 0; &#125; - 方案3： .container &#123; display:flex; flex-direction:column; &#125; .sub &#123; flex:1; &#125;`2018-09-26 10:13:31 星期三","tags":[{"name":"css","slug":"css","permalink":"https://jiaopianjun.cc/tags/css/"},{"name":"面试","slug":"面试","permalink":"https://jiaopianjun.cc/tags/面试/"}]},{"title":"display:flex","date":"2018-06-04T04:53:19.000Z","path":"2018/06/04/display-flex.html","text":"flex:弹性盒子 父元素设置为 ： display:flex;如果是内联元素可以设置为：display: inline-fiex 属性： flex-direction ： 设置主轴的方向 参数 有 row(设置主轴水平方向起点在左边),row-reverse(设置主轴水平方向，起点在右边),column(设置主轴垂直方向起点在上边),,column-reverse(设置主轴垂直方向起点在下边) flex-warp： 定义换行情况 参数：nowrap （没有任何操作），wrap(换行，第一行在上面)，wrap-reserse（换行，第一行在上面，换行的在上面） flex-flow 参数：nowrap, flex-direction,flex-wrap justify-content ： 定义项目在主轴上的对齐方式 参数：flex-start（默认，左对齐），flex-end(右对齐)，center(居中)，space-between(两端对齐，中间等距离间隔)，space-around（每个项目之间等宽间隔) align-item ： 定义交叉轴上的对齐方式 参数： flex-start(起点对齐)，flex-end(终点对齐)，center（中点对齐），baseline（基于第一个的第一排文字对齐），stretch(默认，如果项目未设置高度或者设置的auto,将占满整个容器高度) align-content：定义多跟轴线的对齐方式 参数：flex-start(与交叉轴的起点对齐)，flex-end（与交叉轴的终点对齐），center（与交叉轴的中点对齐），space-between(与交叉轴的两端对齐，轴线之间的间隔平均分布)，space-around（每根轴线两端间隔相等，即相邻的会比不相邻的大一倍），stretch（默认值，轴线占满整个交叉轴） order: 定义项目的排列顺序 参数：数值越小，排列越靠前，默认为0，可以是负值。 flex-graw:定义项目的放大比例 参数：默认值为0，即如果空间有剩余，也不放大。可以是小数，按比例占据剩余空间。 flex-shrink：定义项目的缩小比例 参数：默认值都为1，即如果空间不足将等比例缩小。 如果有一个项目的值为0，其他项目为1，当空间不足时，该项目不缩小。 负值对该属性无效，容器不应该设置flex-wrap。 flex-basis属性：定义在分配多余空间之前，项目占据的主轴空间。 参数： 默认值为auto，浏览器根据此属性检查主轴是否有多余空间。 flex属性是flex-grow，flex-shrink和flex-basis的简写默认值为0 1 auto，第一个属性必须，后两个属性可选。","tags":[{"name":"css","slug":"css","permalink":"https://jiaopianjun.cc/tags/css/"}]},{"title":"前端面试题","date":"2018-06-04T04:51:44.000Z","path":"2018/06/04/面试题.html","text":"this 的三种常用方法12345678910111213141.函数调用 指向全局对象 例如： function a()&#123; this.x = 1 &#125; a()或者 var x = 10; function a()&#123; this.x = 0 &#125; a() x = 0 这时候 this 指向 window 1234567891011121314151617181920212223242526272829302.对象方法调用 function t()&#123; console.log(this.x) &#125; var p = &#123;&#125; p.x = 10 p.m = t p.m() // 10 3.作为构造函数调用 function a()&#123; this.x = 10 ; console.log(this.x) &#125; var b = new a() b.x //10 var x = 20 function a()&#123; this.x = 10 ; console.log(this.x) &#125; var b = new a() b.x //10 x 20 这时候this 指向当前的函数4. 页面使用 onclick=\"a(this)\" typeof 和 instanceof 的区别12341. typeof：判断函数基本类型 例如 number object string boolean function undefined 等2. instanceof：用于判断一个变量是否属于某个对象的实例 判断数组和正则 无法准确判断 函数3. 相同点：都是用来判断一个变量是否为空，或者是什么类型的4. typeof：对于 array null 都返回object this 和 $(this)的区别121. this 为当前对象 this 可以 直接 this.style 修改样式2. $(this) 为jq封装的当前对象 可以用jq 封装的方法来使用 同步和异步的区别12345671. 同步 阻塞的 只能等服务器响应完成之后 渲染页面或者执行下一步操作2. 异步 非阻塞的 如果服务器没有响应 则先干当前的事情 等响应之后在渲染需要渲染的地方3. 如何异步加载 1. html5: defer async 或者延迟加载 defer：等页面加载完成之后才会执行 async： 脚本可用则执行 2. 动态生成script 标签插入页面 有可能还会阻塞 3. ajax eval 4. iframe 什么是跨域12345678910111213141516171819202122232425262728293031323334 由于浏览器的同源规则，url 的协议 域名 端口 IP 子域名 有一与当前页面不同的则为跨域 解决方法 1.通过 porxy 代理 由服务器来进行转发 2. 通过 CORS 由后端添加 请求头 3.通过JSONP jsonp 无法发送 post 请求ajax的优缺点和原理 $.ajax(&#123; url:'', type:'', data:&#123;&#125;, dataType:'', josnp:'jsoncallback', success:function()&#123; &#125; &#125;) 原理：相当于在客户端和服务端加了一个抽象层，使用户请求和服务器响应异步化，并不是所有的请求都提交给服务器。像一些数据验证是交与ajax引擎来完成的，只有确认需要向服务器读取新数据的时候ajax才会向服务器请求创建过程：首先创建一个异步调用对象 创建一个http请求包含请求方法，url，验证信息 并设置响应http请求状态变化的函数 发送http 请求 获取异步调用返回的数据 使用js 和 dom 实现局部刷新优点：无刷新更新数据 异步与服务器通信 前端和后端负载均衡缺点：浏览器后退无法回到前一页的页面状态， 对搜索引擎支持较弱 不能很好的支持移动端 安全问题 破坏程序的异常处理机制 document.load 和document.ready的区别load是在页面所有元素都加载完后才会执行 包括图片 dom树等 === onload ready dom文档数加载后执行 websocket的用法和原理以及协议基于 tcp/ip协议 tcp 面向连接 提供可靠的服务，udp 无连接 提供高效率服务 服务器可用主动向客户端发送信息 客户端也可以主动向服务端发送信息，双方是对等的 let var的区别let 只有在块级作用域里才会生效 定义的不能在定义以及不能赋值这个选项 var 则不会 git命令git -v git branch git init git clone git config touch ss mkdir ss ls git log git push git commit git remote cd.. 用过其他框架svg 和canvas的区别svg 输出的图形都有独立的dom 是一个矢量图形 放大缩小不会失贞 canvas 输出的是一整块 是一个画布 放大 缩小会失贞 闭包的用法12345678910111. **使函数外部能够调用函数内部变量的方法**2.一个函数的返回值 是另外一个函数，返回的哪个函数如果调用其父函数内部的其他变量，如果返回的函数在外部调用就产生了闭包3.根据作用域链规则，底层作用域没有声明变量 会向上一级寻找，找到就返回 没有找到就一直找，直到window 则返回 undefined4.变量作用域 全局 和 局部 函数内部 可以 访问函数外部 反之则不行 所以就需要闭包 5.闭包滥用 会造成内存泄漏 会改变付函数内部变量的值 数组的排序12345678910111213js 原生可用 sort 进行排序二维数组排序 sort排序 arr.sort(function(a,b)&#123; if(a[1] &lt; b[1])&#123; return -1; &#125;else if(a[1] &gt; b[1])&#123; return 1 &#125;else&#123; return 0 &#125; &#125;) 其他可使用冒泡 如何看待模块化减少系统耦合度， 让开发者便于维护，同时让部分逻辑相同的地方可以共用 amd 和 cmd amd 提前执行 cmd 依赖前置 常见的网络攻击以及如何防范1.xss 攻击 跨站脚本攻击 在web页面插入恶意代码 然后被执行 解决方法： 不允许脚本执行，过滤转义脚本标识符 使用过滤组件js-xss 添加过滤规则等 2.反射型XSS 通过 连接后缀来执行添加 3.CSRF 跨站点伪造请求 利用伪造的请求 来达到目的 解决方法：采用POST 对请求进行认证 4.脚本刷接口 解决方法： 加验证码 长连接和短链接的区别1.长连接 表示新建一个tcp 连接 发送数据，数据发送完之后不会立即断开 而是保持连接，如果没有数据发送 则需要双方检测 如果需要则保持 不需要则断开。应用于点对点通讯 2.短链接 建立tcp 连接后发送数据 数据发送完成则断开 如何判断一个变量的类型或者是否为string1. typeof(obj) === &apos;string&apos; 2.obj.constructor 如何去除字符串空格1.正则 2.trim 垃圾回收机制以及内存管理1.回收机制 负责管理代码执行过程中使用的内存 定期找出不在使用的变量，然后释放其内存，这个过程不是实时的，是按照固定时间间隔的周期性来执行的 2.内存管理 周期性的运行 回收不可访问的对象 判断一个字符串中出现最多的字符var x = &quot;asdgsdgasdg1231weweg123asdg23&quot;; var y = {} for(var i =0; i&lt;x.length;i++){ if(!y[x.charAt(i)]){ y[x.charAt(i)] = 1 }else{ y[x.charAt(i)]++ } } var max = 0, maxname = &apos;&apos;; for(var i in y){ if(y[i] &gt; max){ max = y[i] maxname = i } } 去除数组相同元素var x = [1,12,3,1,3,2,6,1] var obj = {} var temp = [] for(var i = 0; i&lt; x.length;i++){ if(!obj[x[i]]){ obj[x[i]] = 1 temp.push(x[i]) } } for(var i = 0;i&lt;x.length;i++){ if(temp.indexOf(x[i]) &lt; 0){ temp.push(x[i]) } } 如何提高页面性能减少http 请求， 减少dom 元素数量 把css 放到代码上端 避免css 表达式 优化图片 合并请求 压缩图片 脚本放到html 底部 页面seo注意哪些title 和 desc keyword 的设置正确 图片加alt 从浏览器地址栏输入URL 到页面显示页面的具体步骤去DNS 进行域名解析 拿到IP根据IP访问服务器，服务器根据请求返回数据，浏览器接收数据开始渲染 http 状态码1xx 发送时候 2xx 请求成功 3xx 重定向 4xx 客户端错误 5xx 服务端错误 css 盒子模型标准 content + border margin padding ie conteng border padding + margin 移动端1像素问题border-image viewport rem 解决 css transform:scaleY()","tags":[{"name":"css","slug":"css","permalink":"https://jiaopianjun.cc/tags/css/"},{"name":"javascript","slug":"javascript","permalink":"https://jiaopianjun.cc/tags/javascript/"},{"name":"html","slug":"html","permalink":"https://jiaopianjun.cc/tags/html/"}]},{"title":"Jquery基础知识","date":"2018-06-03T03:02:27.000Z","path":"2018/06/03/jQuery.html","text":"你觉得jQuery或zepto源码有哪些写的好的地方 jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链 12345678910111213(function( window, undefined ) &#123; //用一个函数域包起来，就是所谓的沙箱 //在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局 //把当前沙箱需要的外部变量通过函数参数引入进来 //只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数 window.jQuery = window.$ = jQuery; &#125;)( window ); jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法 有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度 jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率 jQuery 的实现原理？ (function(window, undefined) {})(window); jQuery 利用 JS 函数作用域的特性，采用立即调用表达式包裹了自身，解决命名空间和变量污染问题 window.jQuery = window.$ = jQuery; 在闭包当中将 jQuery 和 $ 绑定到 window 上，从而将 jQuery 和 $ 暴露为全局变量 jQuery.fn 的 init 方法返回的 this 指的是什么对象？ 为什么要返回 this？ jQuery.fn 的 init 方法 返回的 this 就是 jQuery 对象 用户使用 jQuery() 或 $() 即可初始化 jQuery 对象，不需要动态的去调用 init 方法 jQuery.extend 与 jQuery.fn.extend 的区别？ $.fn.extend() 和 $.extend() 是 jQuery 为扩展插件提拱了两个方法 $.extend(object); // 为jQuery添加“静态方法”（工具方法） 123456$.extend(&#123; min: function(a, b) &#123; return a &lt; b ? a : b; &#125;, max: function(a, b) &#123; return a &gt; b ? a : b; &#125;&#125;);$.min(2,3); // 2$.max(4,5); // 5 $.extend([true,] targetObject, object1[, object2]); // 对targt对象进行扩展1234var settings = &#123;validate:false, limit:5&#125;;var options = &#123;validate:true, name:\"bar\"&#125;;$.extend(settings, options); // 注意：不支持第一个参数传 false// settings == &#123;validate:true, limit:5, name:\"bar\"&#125; $.fn.extend(json); // 为jQuery添加“成员函数”（实例方法） 12345678910$.fn.extend(&#123; alertValue: function() &#123; $(this).click(function()&#123; alert($(this).val()); &#125;); &#125;&#125;);$(\"#email\").alertValue(); jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？ 浅拷贝（只复制一份原始对象的引用）var newObject = $.extend({}, oldObject); 深拷贝（对原始对象属性所引用的对象进行进行递归拷贝）var newObject = $.extend(true, {}, oldObject); jQuery 的队列是如何实现的？队列可以用在哪些地方？ jQuery 核心中有一组队列控制方法，由 queue()/dequeue()/clearQueue() 三个方法组成。 主要应用于 animate()，ajax，其他要按时间顺序执行的事件中 12345678910111213141516171819202122var func1 = function()&#123;alert('事件1');&#125;var func2 = function()&#123;alert('事件2');&#125;var func3 = function()&#123;alert('事件3');&#125;var func4 = function()&#123;alert('事件4');&#125;// 入栈队列事件$('#box').queue(\"queue1\", func1); // push func1 to queue1$('#box').queue(\"queue1\", func2); // push func2 to queue1// 替换队列事件$('#box').queue(\"queue1\", []); // delete queue1 with empty array$('#box').queue(\"queue1\", [func3, func4]); // replace queue1// 获取队列事件（返回一个函数数组）$('#box').queue(\"queue1\"); // [func3(), func4()]// 出栈队列事件并执行$('#box').dequeue(\"queue1\"); // return func3 and do func3$('#box').dequeue(\"queue1\"); // return func4 and do func4// 清空整个队列$('#box').clearQueue(\"queue1\"); // delete queue1 with clearQueue jQuery 中的 bind(), live(), delegate(), on()的区别？ bind 直接绑定在目标元素上 live 通过冒泡传播事件，默认document上，支持动态数据 delegate 更精确的小范围使用事件代理，性能优于 live on 是最新的1.9版本整合了之前的三种方式的新事件绑定机制 是否知道自定义事件？ jQuery 里的 fire 函数是什么意思，什么时候用？ 事件即“发布/订阅”模式，自定义事件即“消息发布”，事件的监听即“订阅订阅” JS 原生支持自定义事件，示例： 1234document.createEvent(type); // 创建事件event.initEvent(eventType, canBubble, prevent); // 初始化事件target.addEventListener('dataavailable', handler, false); // 监听事件target.dispatchEvent(e); // 触发事件 jQuery 里的 fire 函数用于调用 jQuery 自定义事件列表中的事件 jQuery 通过哪个方法和 Sizzle 选择器结合的？ Sizzle 选择器采取 Right To Left 的匹配模式，先搜寻所有匹配标签，再判断它的父节点 jQuery 通过 $(selecter).find(selecter); 和 Sizzle 选择器结合 jQuery 中如何将数组转化为 JSON 字符串，然后再转化回来？ 12345678910111213// 通过原生 JSON.stringify/JSON.parse 扩展 jQuery 实现 $.array2json = function(array) &#123; return JSON.stringify(array); &#125; $.json2array = function(array) &#123; // $.parseJSON(array); // 3.0 开始，已过时 return JSON.parse(array); &#125; // 调用 var json = $.array2json(['a', 'b', 'c']); var array = $.json2array(json); jQuery 一个对象可以同时绑定多个事件，这是如何实现的？ 1234567$(\"#btn\").on(\"mouseover mouseout\", func);$(\"#btn\").on(&#123; mouseover: func1, mouseout: func2, click: func3&#125;); 针对 jQuery 的优化方法？ 缓存频繁操作DOM对象 尽量使用id选择器代替class选择器 总是从#id选择器来继承 尽量使用链式操作 使用时间委托 on 绑定事件 采用jQuery的内部函数data()来存储数据 使用最新版本的 jQuery jQuery 的 slideUp 动画，当鼠标快速连续触发, 动画会滞后反复执行，该如何处理呢? 在触发元素上的事件设置为延迟处理：使用 JS 原生 setTimeout 方法 在触发元素的事件时预先停止所有的动画，再执行相应的动画事件：$(‘.tab’).stop().slideUp(); jQuery UI 如何自定义组件？ 通过向 $.widget() 传递组件名称和一个原型对象来完成 $.widget(&quot;ns.widgetName&quot;, [baseWidget], widgetPrototype); jQuery 与 jQuery UI、jQuery Mobile 区别？ jQuery 是 JS 库，兼容各种PC浏览器，主要用作更方便地处理 DOM、事件、动画、AJAX jQuery UI 是建立在 jQuery 库上的一组用户界面交互、特效、小部件及主题 jQuery Mobile 以 jQuery 为基础，用于创建“移动Web应用”的框架 jQuery 和 Zepto 的区别？ 各自的使用场景？ jQuery 主要目标是PC的网页中，兼容全部主流浏览器。在移动设备方面，单独推出 jQuery Mobile Zepto 从一开始就定位移动设备，相对更轻量级。它的 API 基本兼容 jQuery，但对PC浏览器兼容不理想","tags":[{"name":"javascript","slug":"javascript","permalink":"https://jiaopianjun.cc/tags/javascript/"},{"name":"面试","slug":"面试","permalink":"https://jiaopianjun.cc/tags/面试/"},{"name":"jquery","slug":"jquery","permalink":"https://jiaopianjun.cc/tags/jquery/"}]},{"title":"ES6知识点","date":"2018-06-01T00:02:27.000Z","path":"2018/06/01/ES6.html","text":"ES6的了解 新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=&gt;outputs。）、for-of（用来遍历数据—例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。。还有就是引入module模块的概念说说你对Promise的理解 依照 Promise/A+ 的定义，Promise 有四种状态： pending: 初始状态, 非 fulfilled 或 rejected. fulfilled: 成功的操作. rejected: 失败的操作. settled: Promise已被fulfilled或rejected，且不是pending 另外， fulfilled 与 rejected 一起合称 settled Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算 Promise 的构造函数 构造一个 Promise，最基本的用法如下： 123456789101112var promise = new Promise(function(resolve, reject) &#123; if (...) &#123; // succeed resolve(result); &#125; else &#123; // fails reject(Error(errMessage)); &#125; &#125;); Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为thenable）。它的使用方法如下： 1promise.then(onFulfilled, onRejected) 接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在rejected的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject 什么是 Promise ？ Promise 就是一个对象，用来表示并传递异步操作的最终结果 Promise 最主要的交互方式：将回调函数传入 then 方法来获得最终结果或出错原因 Promise 代码书写上的表现：以“链式调用”代替回调函数层层嵌套（回调地狱） 谈一谈你了解ECMAScript6的新特性？ 块级作用区域 let a = 1; 可定义常量 const PI = 3.141592654; 变量解构赋值 var [a, b, c] = [1, 2, 3]; 字符串的扩展(模板字符串) var sum =${a + b}; 数组的扩展(转换数组类型) Array.from($(&#39;li&#39;)); 函数的扩展(扩展运算符) [1, 2].push(...[3, 4, 5]); 对象的扩展(同值相等算法) Object.is(NaN, NaN); 新增数据类型(Symbol) let uid = Symbol(&#39;uid&#39;); 新增数据结构(Map) let set = new Set([1, 2, 2, 3]); for…of循环 for(let val of arr){}; Promise对象 var promise = new Promise(func); Generator函数 function* foo(x){yield x; return x*x;} 引入Class(类) class Foo {} 引入模块体系 export default func; 引入async函数[ES7] 1234async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value) &#125; Object.is() 与原来的比较操作符 ===、== 的区别？ == 相等运算符，比较时会自动进行数据类型转换 === 严格相等运算符，比较时不进行隐式类型转换 Object.is 同值相等算法，在 === 基础上对 0 和 NaN 特别处理 12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true 什么是 Babel ？ Babel 是一个 JS 编译器，自带一组 ES6 语法转化器，用于转化 JS 代码。这些转化器让开发者提前使用最新的 JS语法(ES6/ES7)，而不用等浏览器全部兼容。 Babel 默认只转换新的 JS 句法(syntax)，而不转换新的API。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://jiaopianjun.cc/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://jiaopianjun.cc/tags/es6/"},{"name":"面试","slug":"面试","permalink":"https://jiaopianjun.cc/tags/面试/"}]},{"title":"添加  hexo-admin 发布文章","date":"2018-05-15T01:52:29.000Z","path":"2018/05/15/添加-hexo-admin-发布文章.html","text":"测试一下是不是可以发布了。","tags":[{"name":"tt","slug":"tt","permalink":"https://jiaopianjun.cc/tags/tt/"}]},{"title":"最近","date":"2018-05-14T07:09:57.000Z","path":"2018/05/14/最近-1.html","text":"博客迁移到 故事胶片了最近一直在搞小程序 基本快好了。 微信搜索 【赞一赞】 就能找到了","tags":[{"name":"随笔","slug":"随笔","permalink":"https://jiaopianjun.cc/tags/随笔/"}]},{"title":"近期","date":"2018-03-16T01:48:52.000Z","path":"2018/03/16/近期.html","text":"这两天一直在下雨呀， 待续。。。。。","tags":[{"name":"其他","slug":"其他","permalink":"https://jiaopianjun.cc/tags/其他/"},{"name":"随笔","slug":"随笔","permalink":"https://jiaopianjun.cc/tags/随笔/"}]},{"title":"放假了，过年了","date":"2018-02-09T08:14:58.000Z","path":"2018/02/09/放假了，过年了.html","text":"明天最后一天年会了，回家过年了。。 开心","tags":[{"name":"过年","slug":"过年","permalink":"https://jiaopianjun.cc/tags/过年/"},{"name":"放假","slug":"放假","permalink":"https://jiaopianjun.cc/tags/放假/"}]},{"title":"再见2017","date":"2017-12-31T01:52:49.000Z","path":"2017/12/31/再见2017.html","text":"每次都说时间就像手中的沙，不知不觉间就悄悄的流走了。你没有一点点感觉，想抓也抓不住，任它溜走。留下的只是回忆还有一段段记忆。 今天是2017的最后一天，明天就是2018了。 脑海中回忆去年的这个时候，如同昨日，历历在目，感觉一切好像刚过去，可是不知不觉已经一年了。 一年过的很快，快的让我们一直以为时间过的很慢，时间很长。总会以还早呢，时间还多呢，今天才几号 几号 ，还早呢，还有明天呢 等来搪塞，给自己一个懒惰的借口。 一年的事历历在目，就连同小时候发生的事情也好像在昨天一样，可是昨天就是昨天再也回不去了。 好多好多的回忆，好多好多有趣的事儿 都只能留在过去，我们只能通过脑海里的记忆去回想，或者通过种种方式来留存。 这一年去过了一些地方，玩过一些游戏，吵过了一些架，有过一些有趣的事，这些都将成为我2017的回忆。 2018也会像今年一样，有开心，不开心，有趣的事儿发生。每一次都将是一次美好的经历。 明年的这个时候再见吧。 2017.12.31 10：10","tags":[{"name":"2018","slug":"2018","permalink":"https://jiaopianjun.cc/tags/2018/"},{"name":"2017","slug":"2017","permalink":"https://jiaopianjun.cc/tags/2017/"},{"name":"一年又一年","slug":"一年又一年","permalink":"https://jiaopianjun.cc/tags/一年又一年/"}]},{"title":"2017的最后一个月了","date":"2017-12-01T03:43:27.000Z","path":"2017/12/01/新的一月.html","text":"2017 就要过去了，转眼间来到了最后一个月，时间总是过的很快，不知不觉在从手中溜走。 一年又一年，一天又一天，每天重复的过着，重复着相同的事情。 你是否想过改变，是时候改变。 过的轻松一点，过的充实一点。 加油！！！","tags":[{"name":"随记","slug":"随记","permalink":"https://jiaopianjun.cc/tags/随记/"},{"name":"12月","slug":"12月","permalink":"https://jiaopianjun.cc/tags/12月/"}]},{"title":"最近","date":"2017-11-09T01:37:08.000Z","path":"2017/11/09/最近.html","text":"最近一直忙着新项目，用新的东西，忙着忙着，连博客基本的新建都忘记了。惭愧 ，惭愧 啊 最近一段时间的天气不错， 就这样","tags":[{"name":"其他","slug":"其他","permalink":"https://jiaopianjun.cc/tags/其他/"},{"name":"随笔","slug":"随笔","permalink":"https://jiaopianjun.cc/tags/随笔/"}]},{"title":"Sass笔记","date":"2017-09-29T09:17:30.000Z","path":"2017/09/29/Sass笔记.html","text":"","tags":[{"name":"css","slug":"css","permalink":"https://jiaopianjun.cc/tags/css/"},{"name":"sass","slug":"sass","permalink":"https://jiaopianjun.cc/tags/sass/"}]},{"title":"JavaScript 学习笔记整理","date":"2017-09-29T09:05:24.000Z","path":"2017/09/29/javascript.html","text":"1.字符集1.1 区分大小写 JavaScript 是区分大小写的 1.2 空格 换行符和格式控制符 2.注释// 要注释的前面加这个 3.直接量程序中直接使用的数据值 4.标识符和保留字就是JavaScript中一些变量名等 5.数据类型5.1 number 数字型 5.2 string 字符型 5.3 boolean 布尔型 true or false 以上为原始类型 无法在分类 5.4 undefined 未定义或者不存在 5.5 null 空 以上为特殊类型 5.6 object 对象 可以是各种类型的集合 6.typeof运算符6.1 原生使用 object.prototype.toString.call() 检查数据的类型 6.2 直接使用 typeof test 来判断类型 7.数值7.1 正0 和 负0 是等价的 7.2 Infinity javascript 在算术运算时发生溢出，下溢 或被零整除的时候不会报错 infinity大于一切数值除了 NAN -infinity 小于一切数值 除了 NAN 7.3 NaN 不等于任何值包括它本身 7.4 JavaScript 不区分整数值和浮点数值，所有数字均采用浮点数值标识 8.字符串&apos;123132&apos; 9.转义反斜杠（\\） 10.null 和 undefinednull默认是一个特殊的对象，undefined 则是未定义 11.布尔值false 和 true 12.变量声明var a; 13.声明提前（变量提升）JavaScript 的工作方式先解析代码，获取所有被声明的对象，然后逐行运行，造成的后果就是所有变量的声明语句都会被提升到代码的头部，这就是声明提前 注意：变量提升只对var 命令声明的变量有效，如果一个变量的声明不是var则无效 变量作用域：全局作用域，局部作用域。 注意：在函数体中局部变量的优先级高于同名的全局变量。也就是说在一个函数内部声明一个局部变量或者函数中带有的变量和全局变量同名，那么局部变量会覆盖全局变量。 在函数中默认用var 声明的是局部变量，没有var 的则是全局变量声明。 14.语句14.1 表达式语句 14.2 声明语句 var a=1,b=2； 14.3 条件语句 if switch 14.4 循环语句 for do while while for in 14.5 return语句 15.对象 JavaScript中的一种基本类型15.1 键名 对象的所有键名都市字符串 又称为属性（prototype），它的键值可以是任何数据类型，如果一个属性的值为函数，通常把这个属性称之为方法。 15.2 创建对象 对象直接量 var a = {}; 关键字new var a = new Object(); Object.creat() var a = Object.creat(); 15.3 对象直接量 对象直接量 是由若干名/值对组成的映射表。键名和键值之间用冒号分隔。如果对象内部包含多个键值对，则每个键值对之间用逗号分隔。整个映射表用花括号括起来。 注意：对象直接量的最后一个属性可由可无，但是在ie中如果多了一个逗号，会报错， 15.4 构造函数 通过new创建对象 new运算符创建并初始化一个对象，关键字new后跟随一个函数调用，那这个函数称作构造函数。 例子：var a = {} var a = new Object(); var a = Object.creat(null) 这三个是等价的 15.5 对象常见的用法 创建（create） 设置（set） 查找（query） 删除（delete） 检测（test） 枚举（enumerate） 15.6 读取属性 例子： var a = {name:&quot;1&quot;}; a.name = 1 15.7 查找属性 例子： var a = {name:&quot;1&quot;}; Object.keys(a) 15.7 删除属性 例子： var a = {name:&quot;1&quot;}; delete a.name delete只能删除自身属性 16.构造函数解释：就是用来生成对象的函数，一个构造函数可以生成多个对象，这些对象都有相同的结构 特点：函数体内使用了 this 关键字 ，代表了所要生成的对象实例 生成对象时，必须用 new命令 注意：构造函数名的第一个字母必须大写,每一个构造函数都有一个prototype属性 例子：function Cx(){ this.name = &apos;cx&apos; } var log = new Cx(); log // Cx{name:cx} or function Cx(name){ this.name = name; } var log = new Cx(&apos;cx&apos;); log // Cx{name:cx} this 总是返回一个对象，返回属性或者方法当前所在的对象 例子：this.prototype var A = { name:&quot;cx&quot;, test:function(){ return this.name } }; var B = { name:&quot;xc&quot;; } B.test = A.test; B.test() // cx 注意：如果一个函数在全局环境中运行，那么他的this 指向window也就是最顶层对象 17.改变this的指向方法：call apply bind 例子：call(obj1,arr1); 第一个参数为要指向的对象，也就是要指定的上下文 后面的为传入的参数 如果参数为空，null，undefined 则默认传入全局对象 apply(obj1,[arr1,arr2]); 同上，只是参数换成了数组 bind(0bj1) 将函数体内dethis绑定到某个对象上返回一个新的函数 18.原型解释：JavaScript中每一个对象（除null）都会和另一个对象相关联，也就是继承另一个对象。那么另一个对象就称之原型，每个对象都从原型继承属性 所有通过对象直接量创建的对象都具有一个原型对象，我们都可以通过Object.prototype获得对原型对象的引用。 通过关键字new 或者构造函数创建的对象的原型就是构造函数的prototype属性。比如 通过new Object（）创建的对象继承自Object.prototype, 通过new Array()创建的对象的原型就是Array.prototype。 Object.parototype 不会继承任何属性，它没有原型 所有内置构造函数都具有一个继承自Object.prototype的原型 19.原型链解释：对象的属性和方法可能定义在本身，也可能定义在它的原型对象。由于原型对象本身也对象又是原型，所以形成了一条链式关系，就又可能 a 的原型对象是b b的原型对象是c 原型链的作用：如果查找一个对象的属性，JavaScript是先查找这个对象本身，如果没有则查找它的原型对象，如果没有则查找原型对象的原型 如果一直没有直到最顶层的object.prototype还是没有则返回undefined 20.继承JavaScript对象具有自身属性，也又一些属性是从原型对象继承而来，当查询一个不存在的对象的时候 不会报错而是返回undefined 如果对象自身和它的原型都定义了一个同名的属性，那么优先读取自身的属性，这个叫做覆盖。 21.constructorprototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。 22.object.prototype.isPrototypeOf()用来判断一个对象是否是另一个对象的原型 23.数组数组是值的有序集合，每个值叫做一个元素，而且每个元素在数组中都有一个位置也就是下标从0开始也称之为索引，整个数组用[]表示 创建数组 var a = [1,2,2] or var a = new Array(1,2,2); 求数组的长度 a.length 添加/删除 a.push()往数组最后一个添加 shift() 删除数组中的元素 具体数组的操作看前面笔记 24.函数函数就是一段可以反复调用的代码块。 函数使用关键字function来定义，还包括一个称为形参（parameter）的标识符列表，这些参数在函数体内像局部变量一样工作 函数调用会为形参提供实参的值，函数使用它们实参的值来计算返回值，称为该函数调用表达式的值 除了实参之外，每次调用还会拥有另一个值， 本次调用的上下文 也就是this关键字的值 如果函数挂载在一个对象上，作为对象的一个属性，就称之为 对象的方法 js中的函数可以嵌套在其他函数中定义，这样它们就可以访问它们当时所处作用域中的任何变量，这个就叫做闭包，闭包的作用 读取函数内部变量，让这些变量常驻内存 函数的定义有三种方法 function命令：function name(){} 函数表达式：var a = function(){} function构造函数 var a = new Function(){} = var a = function(){} 注意：如果函数多次声明，那么后声明的会覆盖前面声明的。 函数可以调用自身，这就是递归 24.1 嵌套函数 在JS中函数内可以嵌套其他函数 24.2 函数调用 构成函数主题的JavaScript代码在定义时并不会执行，只有调用该函数，它们才会执行。有4中方法调用JS函数 1.作为函数、 f() 2.作为方法 o.f = function(){} o.f(); 3.作为构造函数 var a = new Object(); var a = new Object; 4.通过它们的call() 和 apply() 方法间接调用 24.3 传参 如果传入的参数名字相同，则取最后出现的那个的值 例子： function go(x,x){ console.log(x) } go(1,2) // 2 24.4 函数作用域 指变量存在的范围，js中有两种作用域，一种全局作用域，变量在整个程序中一直存在，所以地方都可以读取。一种函数作用域，变量只有在函数内部存在，只有函数内部可以访问。 如果在函数内部定义一个变量和全局变量名相同，那么函数内部的变量将覆盖全局变量 24.5 函数属性、方法和构造函数 name属性 function a(){} a.name // a length属性 function f(x,y){} f.length //2 24.6 严格模式 &apos;use strict&apos; 25.表达式和运算符25.1 JS 原始表达式包含 常量 直接量 变量 或者关键字 直接量就是直接在程序中出现的常数值 如 1.2 &quot;hello&quot; 保留关键字 this true false this 等 变量 i num 25.2 对象和数组的初始化表达式 实际上是一个新创建的对象和数组，也可以称之为 对象直接量 和 数组直接量 例子 var a = {}, var b = []; 25.3 函数定义表达式 函数定义表达式（函数直接量）定义一个Javascript 函数 。表达式的值就是这个新定义的函数。 例子：var f = function(){} 25.4 属性访问表达式 var f = {name:&quot;1&quot;,age:&quot;22&quot;} f.name // 1 or var t = [1,2,12,3] t[3] //3 26.DOM 文档对象模型，表示和操作HTML和XML文档内容的基础firstChild lastChild 返回该节点子节点的第一个和最后一个 如果没有返回null parentNode 当前节点的父节点 没有返回null childNodes 当前节点的子节点列表 nextSibling previousSibling 当前节点的前一个 和 下一个。 具有相同父节点的两个节点称之为兄弟节点 textContent 返回该节点的文本内容 nodeType 返回当前节点类型 nodeValue 返回text节点或者comment节点的内容 ，其他类型一律返回null nodeName 元素标签名，大写显示 children 类型childNodes 返回一个NodeList对象，但是children列表只包含Element对象 注意 ： text 和commont 没有children 属性 firstElementChild lastElementChild 类型firstChild 和 lastChild 但是只代表子Element nextElementChild previousElementSibling 类似nextSibling 和 previousSibling 但是只代表兄弟 Element childElementCount 返回子元素的数量 offsetParent 返回当前HTML元素最靠近 并且css 的position 不等于static的父元素 innerHTML 返回 读取元素内部的html outerHTML 返回所有内容 包括读取元素的本身 insertAdjacentHTML() 将任意HTML标记字符插入到指定的元素相邻的位置 createElement 创建节点 createTextNode（） 创建一个text节点，参数为所要生成的文本节点的内容 createAttribute() 用来复制已存在的节点 appendChild 和 insertBefore 用来插入节点 removeChild 删除一个节点 replaceChild 删除一个节点并用新的替换一个节点 elementFromPoint() 判断元素在某点 scrollTop 滚动方法 scrollBy 用于将网页移动指定距离 可以向右 和向下滚动 像素 scrolllntoView 保证元素在视口可见 文档属性 clientWidth clientHeight 返回元素节点可见区域的宽度 和 高度 clientLeft clientTop 返回元素节点左边框的宽度 和 网页元素顶部边框的宽度 内联元素 则为0 scrollWidth scrollHeight 返回网页元素的高度和总宽度。 scrollLeft scrollTop 返回网页元素的水平滚动条向右侧滚动的像素数量 和 元素的垂直滚动条向下滚动的像素数量 offsetWidth offsetHeight 返回元素的水平宽度和垂直高度 offsetLeft offsetTop 返回当前元素相对于左上角offsetParent节点的垂直偏移 和 返回水平位移 document.cookie 操作浏览器的cookie domain 返回当前文档的域名 lastModified 包含文档修改时间的字符串 location 与window对象的location属性引用同一个location对象 document.referrer 返回当前文档的访问来源 如果当前是从浏览器键入或者无法获取来源则返回空 title 当前文档标题 doctype document对象一般有两个子节点，第一个子节点是document.doctype 它是一个对象包含当前文档类型信息。 html5 用 &lt;!DOCTYPE html&gt; documentElement 返回当前文档的根节点 它是文档的第二个节点 第一个是上面的 defaultView 在浏览器中返回document 对象所在的window对象 否则返回null activeElement 返回当前文档中获得焦点的元素 characterSet 返回渲染当前文档的字符集 如 utf-8 readyState 返回当前文档的状态 有三种 ： loading 加载html部分还在解析 interactive 加载外部资源 complete 加载完成 compatMode 返回浏览器处理文档的模式 类型 BackCompat 向后兼容模式 CSS1Compat 严格模式 document.write docuemnt.writeIn window.getSelection() 方法返回一个 selection 对象 查询选取的文本 contenteditable 设置div 可编辑 execCommand 插入元素 或者改变样式 27.DOM属性 和 css27.1 属性 HTML 元素由一个标签和一组称为属性的名/值对 组成 HTML 属性作为 Element的属性 获取和设置非标准HTML属性 getAttribute() //获取属性 setAttribute() //设置属性 hasAttribute() //检测属性是否存在 removeAttribute() //删除 数据集（dataset） 例子：&lt;div id=&quot;test&quot; data-tip=&quot;title&quot;&gt;&lt;/div&gt; var a = document.getElementById(&apos;test&apos;); a.dataset.tip // title attr节点属性（attributes） 用法：document.body.attributes[0] body元素的第一个属性 属性节点对象由name和value属性，对应该属性的属性名和属性值 等同于 nodeName属性和 nodeValue 属性 例子： &lt;div id=&quot;top&quot;&gt;&lt;/div&gt; var t = docuemnt.getElementById(&apos;top&apos;); t.attributes[0].name //id t.attributes[0].nodeName // id t.attributes[0].value // top t.attributes[0].nodeValue // top 27.2 元素的内容 用法： &lt;div id=&quot;t&quot;&gt;a&lt;/div&gt; var a = docuemnt.getElementById(&apos;t&apos;); a.innerHTML //a a.innerHTML = &apos;b&apos; //b 27.3 css 例子： &lt;div id=&quot;t&quot;&gt;a&lt;/div&gt; var a = docuemnt.getElementById(&apos;t&apos;); a.style.color = red a.style.fontSize = &apos;14px&apos; // 需要带单位 a.style.cssText= &quot;font-size:14px&quot; a.style.setProperty(&apos;color&apos;,&apos;blue&apos;) //设置css属性 a.style.getPropertyValue(&apos;color&apos;) //读取css属性 a.style.removeProperty(&apos;color&apos;) //删除css属性 window.getComputedStyle(t,null) 获取引用的样式或者伪元素样式 第一个参数是要获取其计算样式的元素，第二个参数也是必需的，通常是null或空字符串 例子：&lt;style&gt; #tc{ height:30px;} #tc:before{content:&apos;t&apos;;color:green}; &lt;/style&gt; &lt;div id=&quot;tc&quot; style=&quot;background:yellow&quot;&gt;&lt;/div&gt; var t = document.getElementById(&apos;tc&apos;); window.getComputedStyle(t,null).height //30px window.getComputedStyle(t,&apos;:before&apos;).content // t window.getComputedStyle(t,null).getPropertyValue(&apos;line-height&apos;); 脚本化css 通过改变或者添加HTML的class属性值，也是改变内联style属性的一个方法。 例子： t.className = &apos;attention&apos;; //设置class属性 t.className += &apos;attention2&apos;; //添加class属性 t.className = &apos;&apos;; //删除全部class t.className = t.className.replace(&apos;attention2&apos;,&apos;&apos;); //删除名为attention2的class 在HTML5中，每个元素都定义了classList属性，该属性值是DOMTokenList对象：一个只读的类数组对象，它包含元素的单独类名，而且是实时的。它有四个方法： element.classList.add() //添加 element.classList.remove() //删除 element.classList.contains() //是否包含 element.classList.toggle() //如果不存在类名就添加，否则删除 查询、插入和删除样式表 document.styleSheets[]数组的元素是CSSStyleSheet对象。CSSStyleSheet对象有一个CSSRules[]属性，指向一个类数组对象，它包含样式表的所有规则： document.styleSheets[0].cssRules[0] 27.4 css事件 transitionEnd 监听 transition 结束 animationstart 监听 动画开始 触发 animationend 动画结束触发 animationiteration 开始新一轮动画循环时触发 如果循环次数为1 则不触发 例子： element.addEventListener(&quot;animationstart&quot;, listener, false); element.addEventListener(&quot;animationend&quot;, listener, false); element.addEventListener(&quot;animationiteration&quot;, listener, false); 注意：要加上 webkit 等前缀 通过AnimationPlayState（animation-play-state） 控制动画的状态。 例子：element.style.webkitAnimationPlayState = &quot;paused&quot;; element.style.webkitAnimationPlayState = &quot;running&quot;; 28.Event 事件28.1 相关术语 什么是事件 就是浏览器通知应用程序发生了什么事情 事件类型 用来说明发生什么类型事件的字符串 比如 mouseover 事件目标 发生的事件与之相关的对象，当江事件式，必须同时指明类型和目标 事件处理处理程序 处理或响应事件的函数 事件对象 与特定事件相关且包含该事件详细信息的对象 事件传播 浏览器决定哪个对象触发其事件处理程序的过程。 当文档元素上发生某个类型的事件时，它们会在文档树上 传播 或 冒泡 事件捕获 事件传播的另一种方式，在容器元素上注册的特定处理程序有机会在事件传播到真实目标之前捕获它。著作权归作者所有。 28.2 Event事件 注册事件处理程序 有两种基本方式 1.给事件目标对象或文档元素设置属性 2.通过 addEventListener(type,listener[,useCapture]) type 事件名称（事件类型），字符串，大小写不敏感 listerner 监听函数。事件调用时，调用它 useCapture 布尔值，在监听函数是否在捕获阶段触发，默认false(监听函数只在冒泡阶段触发) 注意：使用监听函数的时候 事件去掉on 事件分为三种阶段 捕获阶段 目标阶段 冒泡阶段 事件委托（事件委托）使用后 后面在插入的新节点还是可以监听到的 基于事件在冒泡阶段会向上传播到父节点上，我们可以将子节点的监听放到父节点上，由父节点的监听函数统一处理多个子元素事件。这种方法叫做事件的代理 事件取消 用属性注册的事件处理程序的返回值能用于取消事件的浏览器默认操作 function cancelHandler(event){ var event = event || window.event; if(event.preventDefault) {event.preventDefault();} //标准 if(event.returnValue) { event.returnValue = false;} // IE return false; //用于处理使用对象属性注册的处理程序 } 取消事件传播 e.stopPropagation //ie e.cancelBubble = true 文档事件 beforeunload //当你要从当前浏览页面跳走的时候出现你是否要离开的弹框 window.addEventListener(&apos;beforeunload&apos;,function(e){ var message = &apos;你确认要离开吗！&apos;; e.returnValue = message; return message }); unload //当窗口要关闭或者document事件要卸载的时候触发，排在window body frameset对象上面 触发顺序排在beforeunload 和pagehide后面 只有在页面没有被浏览缓存的时候触发 load //直到文档和所有图片都被加载完触发 缓存的页面不会触发 error //在页面加载失败的时候触发 pageshow // 在页面加载时触发 pagehide // 通过 前进后退按钮的时候触发 DOMContentLoaded事件：当文档加载解析完毕且所有延迟（deferred）脚本（图片未加载完毕）都执行完毕时会触发，此时图片和异步（async）脚本可能依旧在加载，但是文档已经为操作准备就绪了。也就是说，这个事件，发生在load事件之前。 document.addEventListener(&apos;DOMContentLoaded&apos;,handler,false); readystatechange事件：document.readyState属性会随着文档加载过程而变，而每次状态改变，Document对象上的readystatechange事件都会触发。 document.onreadystatechange = function() { if(document.readyState == &apos;complete&apos;){ } } scroll事件、resize事件 scroll事件在文档或文档元素滚动时触发，主要出现在用户拖动滚动条。 resize事件在改变浏览器窗口大小时触发，发生在window、body、frameset对象上面。 hashchange事件、popstate事件 hashchange事件在URL的hash部分（即#号后面的部分，包括#号）发生变化时触发。如果老式浏览器不支持该属性，可以通过定期检查location.hash属性，模拟该事件。 popstate事件在浏览器的history对象的当前记录发生显式切换时触发。注意，调用history.pushState()或history.replaceState()，并不会触发popstate事件。该事件只在用户在history记录之间显式切换时触发，比如鼠标点击“后退/前进”按钮，或者在脚本中调用 cut事件、copy事件、paste事件 这三个事件属于文本操作触发的事件。 cut事件：在将选中的内容从文档中移除，加入剪贴板后触发。 copy事件：在选中的内容加入剪贴板后触发。 paste事件：在剪贴板内容被粘贴到文档后触发。 这三个事件都有一个clipboardData只读属性。该属性存放剪贴的数据，是一个DataTransfer对象 焦点事件 焦点事件发生在Element节点和document对象上。 focus事件：Element节点获得焦点后触发，该事件不会冒泡。 blur事件：Element节点失去焦点后触发，该事件不会冒泡。 focusin事件：Element节点将要获得焦点时触发，发生在focus事件之前。该事件会冒泡。Firefox不支持该事件。 focusout事件：Element节点将要失去焦点时触发，发生在blur事件之前。该事件会冒泡。Firefox不支持该事件。 这四个事件的事件对象，带有target属性（返回事件的目标节点）和relatedTarget属性（返回一个Element节点）。对于focusin事件，relatedTarget属性表示失去焦点的节点；对于focusout事件，表示将要接受焦点的节点；对于focus和blur事件，该属性返回null。 由于focus和blur事件不会冒泡，只能在捕获阶段触发，所以addEventListener方法的第三个参数需要设为true。 鼠标事件 click contextmenu dbclick mousedown mouseup mousemove mouseover mouseenter mouseout mouseleave MouseEvent 对象的属性 button buttons clientX clientY mousementX mouseentY screenX screenY pageX pageY relatedTarget 鼠标滚轮事件 mousewheel 键盘事件 keydown keyup keypress textinput 输入文本触发 altKey属性：alt键 ctrlKey属性：key键 metaKey属性：Meta键（Mac键盘是一个四瓣的小花，Windows键盘是Windows键） shiftKey属性：Shift键 表单事件 input propertychange change select reset //表单重置的时候触发 submit //提交的时候触发 触控事件 TouchEvent Touch TouchList touchstart //接触触摸屏开始触发 touchend //不在触摸触发 changedTouches // 返回一个TouchList对象 包含所有不在触摸的触摸点 touchmove //移动触摸 触发 touchcancel //触摸点取消触发 touchenter //触摸点击触发 touchleave //触摸离开触发 进度事件 进度事件用来描述一个事件进展的过程。比如XMLHttpRequest对象发出的HTTP请求的过程、&lt;img&gt;、&lt;audio&gt;、&lt;video&gt;、&lt;style&gt;、&lt;link&gt;加载外部资源的过程。下载和上传都会发生进度事件。 进度事件有以下几种： abort事件：当进度事件被中止时触发。如果发生错误，导致进程中止，不会触发该事件。 error事件：由于错误导致资源无法加载时触发。 load事件：进度成功结束时触发。 loadstart事件：进度开始时触发。 loadend事件：进度停止时触发，发生顺序排在error事件\\abort事件\\load事件后面。 progress事件：当操作处于进度之中，由传输的数据块不断触发。 timeout事件：进度超过限时触发。 拖放事件 拖放（Drag-and-Drop，DnD）是在“拖放源（drag source）”和“拖放目标（drop target）”之间传输数据的用户界面。 &lt;div draggable=&quot;true&quot;&gt; 此区域可拖拉 &lt;/div&gt; 29. window对象29.1 计时器 setTimeOut() 和 setlterval() 29.2 浏览器定位和导航 location 29.3 解析URL // 当前网址为 http://user:passwd@www.example.com:4097/path/a.html?x=111#part1location.href // &quot;http://user:passwd@www.example.com:4097/path/a.html?x=111#part1&quot; location.protocol // &quot;http:&quot; location.host // &quot;www.example.com:4097&quot; location.hostname // &quot;www.example.com&quot; location.port // &quot;4097&quot; location.pathname // &quot;/path/a.html&quot; location.search // &quot;?x=111&quot; location.hash // &quot;#part1&quot; location.user // &quot;user&quot; location.password // &quot;passed&quot; 29.4 Location对象的方法： location.assign()：使窗口载入并显示指定的URL中的文档。 location.replace()：和assign()方法类似，但它在载入新文档之前会从浏览历史中把当前文档删除。这样“后退”按钮就不会把浏览器带回到原始文档。 location.reload()：重新载入当前文档，可传入一个布尔值为参数，默认false。如果为true，则优先从服务器重新加载；否则优先从本地缓存中重新加载。 当然，我们还有更直接跳转到新页面的方法： location = &apos;http://baidu.com&apos;; //或者 location.href = &apos;http://baidu.com&apos;; 29.5 浏览历史 History.back() // 移动到上一个访问的页面，等同于浏览器的后退键 History.forward() // 移动到下一个访问页面，等同于浏览器的前进键 Histroy.go() //接受一个整数作为参数，移动到该整数指定的页面，比如go(1)相当于forward()，go(-1)相当于back(),go(0)相当于刷新页面 History.pushState() 会改变referrer的值，而在你调用方法后创建的 XMLHttpRequest 对象会在 HTTP 请求头中使用这个值。referrer的值则是创建 XMLHttpRequest 对象时所处的窗口的URL state：一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填null。 title：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。 url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。 history.replaceState()：会修改当前历史记录条目而并非创建新的 history.state 返回当前页面的state对象 29.6 浏览器和屏幕信息 navigator.appName 浏览器的全程 navigator.userAgent 返回标识浏览器的厂商和版本信息 navigator.platform 返回用户操作系统的信息 navigator.onLine 当前浏览器是否连接到网络 navigator.geolocation 包含用户的地理位置 navigator.cookieEnable 浏览器是否能存储cookie 30.Ajax30.1 HTTP 超文本传输协议 HTTP 请求由4个部分组成 1.HTTP请求方法或动作 2.正在请求的URL 3.一个可选的请求头集合，其中可能包括身份验证信息 4.一个可选的请求主题 服务器返回的HTTP响应包含三部分 一个数字和文字组合成的状态码，用来显示请求的成功和失败 一个响应头集合 响应主体 HTTP状态码 200, OK，访问正常 301, Moved Permanently，永久移动 302, Move temporarily，暂时移动 304, Not Modified，未修改 307, Temporary Redirect，暂时重定向 401, Unauthorized，未授权 403, Forbidden，禁止访问 404, Not Found，未发现指定网址 500, Internal Server Error，服务器发生错误 HTTP进度事件 除了使用readystatechange事件来探测HTTP请求的完成外，在XHR2中，还定义了多个有用的事件。 abort事件：当进度事件被中止时触发。如果发生错误，导致进程中止，不会触发该事件。 error事件：由于错误导致资源无法加载时触发。 load事件：进度成功结束时触发。 loadstart事件：进度开始时触发。 loadend事件：进度停止时触发，发生顺序排在error事件\\abort事件\\load事件后面。 progress事件：当操作处于进度之中，由传输的数据块不断触发。 timeout事件：进度超过限时触发。 HTTP请求无法完成有3种情况： 请求超时，会触发timeout事件 请求终止，会触发abort事件 请求发生错误，会触发error事件 同源策略（严格） 协议相同 域名相同 端口相同 不严格的同源策略 使用Document对象的domain属性 来自home.example.com的文档里的脚本要合法的读取developer.example.com载入的文档的属性（默认情况下是不允许的，会受到同源策略的限制 document.domain = &apos;example.com&apos;; 跨域资源共享 Access-Control-Allow-Origin:*，//允许所有域名的脚本访问该资源。 Access-Control-Allow-Origin:http://www.example.com //允许特定的域名访问。 跨文档消息 允许一个文档的脚本跨域传递文本消息到另一个文档里的脚本 跨站脚本 XSS 安全术语，攻击者跨域向目标web站点注入HTML标签或者脚本 防止XSS攻击的方式时，在使用任何不可信的数据来动态的创建文档内容之前，从中移除HTML标签 31.正则表达式search()：按照给定的正则表达式进行搜索，返回一个整数，表示第一个与之匹配的字符串的起始位置，如果找不到匹配的子串，将返回-1。 match()：返回一个数组，成员是所有匹配的子字符串。 replace()：按照给定的正则表达式进行替换，返回替换后的字符串。 split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。 RegExp对象 RegExp()构造函数带有两个字符串参数，第二个参数是可选的，它指定正则表达式的修饰符（可传入修饰符g、i、m或者它们的组合）；第一个参数包含正则表达式的主体部分，也就是正则表达式直接量中两条斜线之间的文本","tags":[{"name":"javascript","slug":"javascript","permalink":"https://jiaopianjun.cc/tags/javascript/"},{"name":"笔记","slug":"笔记","permalink":"https://jiaopianjun.cc/tags/笔记/"},{"name":"更新","slug":"更新","permalink":"https://jiaopianjun.cc/tags/更新/"}]},{"title":"Vue学习笔记","date":"2017-09-27T09:18:15.000Z","path":"2017/09/27/Vue学习笔记.html","text":"了解各种命令，以及状态的改变","tags":[{"name":"vue","slug":"vue","permalink":"https://jiaopianjun.cc/tags/vue/"}]},{"title":"JS Array","date":"2017-09-22T09:26:00.000Z","path":"2017/09/22/JS-Array.html","text":"1.concat() 连接两个或更多的数组var a = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;],b = [&apos;5&apos;,&apos;6&apos;,&apos;7&apos;] a.concat(b); [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;] 2.join() 把数组所有的元素放入一个字符串。元素通过指定的分隔符进行分隔 var c = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;],d=[&apos;e&apos;,&apos;f&apos;,&apos;g&apos;] c.join(d) &quot;ae,f,gbe,f,gc&quot; 3.pop() 删除数组的最后一个元素并返回删除的那个元素var c = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;],d=[&apos;e&apos;,&apos;f&apos;,&apos;g&apos;] c.pop() 返回 c c数组变成 [&apos;a&apos;,&apos;b&apos;] 4.push() 向数组的末尾追加一个或更多的元素，并返回新的长度var del = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;] del.push(&apos;a&apos;) 返回 7 del 变成 [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;a&quot;] 5.unshift() 向数组开头追加一个或更多的元素，并返回新元素的长度var del = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;] del.unshift(&apos;sd&apos;) 返回 7 del 变成 [&quot;sd&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;] 6.reverse() 将现有数据倒叙返回。var del = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;] del.reverse() del 变成 [&quot;6&quot;, &quot;5&quot;, &quot;4&quot;, &quot;3&quot;, &quot;2&quot;, &quot;1&quot;] 7.shift() 删除数组开头的第一个元素 并返回这个元素var del = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;] del.shift() 返回 1 del 变成 [&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;] 8.slice(start,end) 从某个已有的数组返回选定的元素 原数组不变var del = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;] del.slice(2,3) 返回 [&quot;3&quot;, &quot;4&quot;] 9.sort() 对数据进行排序，可以是降序 升序 等。默认是按照ascii码进行排序 如果是数字 则按照第一位数字的大小排序 如 1 21 4 35 则是 1 21 35 4 这样 或者自定义 升序降序 var del = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;] del.sort(function(a,b){ return a-b or b-a 前 从大到小 后 相反 }) 10.splice() 删除元素并可以向数组添加新元素。是直接对数组进行修改，不同于slicevar test = [&apos;111&apos;,&apos;222&apos;,&apos;333&apos;,&apos;444&apos;,&apos;555&apos;,&apos;666&apos;] test.splice(2,4) 返回 [&quot;333&quot;, &quot;444&quot;, &quot;555&quot;, &quot;666&quot;] test 变成 [&quot;111&quot;, &quot;222&quot;] 或者这样 删除指定元素 并用指定 替换 test.splice(2,3,&apos;dsd&apos;); 返回[&quot;333&quot;, &quot;444&quot;, &quot;555&quot;] test 变成 [&apos;111&apos;,&apos;222&apos;,&apos;dsd&apos;,&apos;666&apos;] 或者这样 直接在第三个元素之前插入 test.splice(2,0,&apos;dsd&apos;); 返回 空 test 变成[&apos;111&apos;,&apos;222&apos;,&apos;333&apos;,&apos;dsd&apos;,&apos;444&apos;,&apos;555&apos;,&apos;666&apos;]","tags":[{"name":"javascript","slug":"javascript","permalink":"https://jiaopianjun.cc/tags/javascript/"},{"name":"笔记","slug":"笔记","permalink":"https://jiaopianjun.cc/tags/笔记/"},{"name":"Array","slug":"Array","permalink":"https://jiaopianjun.cc/tags/Array/"}]},{"title":"css 笔记整理","date":"2017-09-22T09:16:08.000Z","path":"2017/09/22/CSS整理.html","text":"# ~选择器：查找某一个元素后面的所有兄弟元素例如 .test~.name{background:red} +选择器：查找某一个元素后面紧邻的兄弟元素例如 .test+.name{background:red} 用 font-size ：0 来清除边距不要忘记给子元素设置字号 用overflow清除浮动.clearfix{ overflow：hidden } .clearfix清除浮动.clearfix{ display:block clear:both; content:&apos;&apos;; } 用border 来绘制三角形 .border{ width:50px; height:50px; border:40px solie; border-left-color:red; border-right-color:yellow; border-top-color:blue; border-bottom-color:green; } .border{ width:0; height:0; border-width:40px; border-color:transparent transparent yellow trasparent; } 梯形 .border{ width:20px; height:0; border-width:40px; border-color:transparent transparent yellow trasparent; } 利用padding实现等比例缩放的盒子最外层容器{ display:flex; display:-webkit-box; display:flex-box; -ms-flex-wrap:wrap; flex-wrap:warp; } 最外层容器 &gt; 子元素{ flex-basis:25%; } 最外层容器 &gt; 子元素 &gt; 父元素{ width:100%; padding-top:75%; position:relative; } 最外层容器 &gt; 子元素 &gt; 父元素 &gt; 子元素{ width:100%; height:100%; position:absolute; top:0; left:0; } 利用pointer-events禁用事件 光标变成default 阻止 hover和hover 以及 JavaScript 点击事件的触发pointer-events:none; 利用 max-width 防止图片撑破容器img{ max-width：100%； display：inline-block; } 利用伪类在打印时候显示a标签的链接.a[href]:after{ content:&quot;(&quot; attr(href) &quot;)&quot; } 未知高度容器的多种垂直居中方法第一种 flex + margin:auto 父元素{ display：flex; } 子元素{ margin：auto； } 第二种 元素占位方案 利用display：inline-block 和伪元素 父元素{ text-align:center; font-size:0; } 父元素::before , 子元素{ display:inline-block; vertical-align:middle } 父元素::before{ content:&apos;&apos;; height:100%; } 第三种 absolute + transform 父元素{ position：relative； text-align:center } 子元素{ position:absolute; left:50%; top:50%; transfrom:translate(-50%,-50%); } 第四种 table-cell 缺点 需要在子元素上额外套一层div 父元素{ display:table; } 父元素 &gt; 二层元素{ display:table-cell; vertical-align:middle; text-align:center } 父元素 &gt; 二层元素 &gt; 子元素{ display:inline-block; } 第四种 flex flex盒模型是最佳事项方案 有两种方案 第一种方案 父元素{ display:flex; align-items:center; justify-content:center; } 第二种方案 父元素{ display：flex; margin:0; } 父元素 &gt; 子元素{ margin:auto; } 用counter 来模拟/装饰 有序清单 父元素{ counter-reset:decimal; list-style-type:none; } 父元素 &gt; 子元素{ counter-increment：decimal; content:counters(decimal,&quot;.&quot;) &quot; &quot;; } 用table-layout 来控制table td/th 的宽度 table{ table-layout：fixed; 用caret-color 自定义输入框 光标颜色 textarea,input,[contenteditable]{ creat-color:red; } 用user-select 禁止选中文本 文本{ user-select：none; } 伪类和伪元素的区别伪类是用： 来表示，伪元素是用：：来表示 常见的伪类有： :hover :active :focus :visited :link :lang :first-child :last-child :not :nth-child 伪元素 就是不存在DOM文档树中的虚拟元素，它们和HTML元素一样，但是你又无法使用javascript去获取 常见伪元素 ::before ::after ::first-letter ::first-line 用 ：valid 和 ：invalid 来做表单验证 html5 提供了类似required Email tel 等表单属性 ：required 指定具有required属性的表单元素 ：valid 指定一个通过匹配正确的所要求的表单元素 ：invalid 指定一个不匹配指定要求的表单元素 &lt;input type=&quot;text&quot; required /&gt; input:vaild{ 如果输入文字则变成绿色 border:1px solid green; box-shadow:inset 10px 0 0 green; } input:invaild{ 如果没有输入则是红色 border:1px solid red; box-shadow:inset 10px 0 0 red; } 用：target来实现折叠面板 用：not来排除其他选择器 ：not([readonly]):not([.disabled]):not([text]) 等 用：nth-child 来实现各行变色 ：nth-child(2n+1){background:red;} : nth-child(2n){backgorund:blue;} 用 ::selection 来美化选中文本 p::selection{ background:red; color:green; } 用 ::placeholder 美化输入框占位符样式 ::placeholder{ color:Red; } 用 ::first-letter 来实现段落首字下沉 p::first-letter{ font-size:30px; color:Red; padding:20px; } 用 ::first-line 来标记段落的第一行 p::first-line{ color:red; }","tags":[{"name":"css","slug":"css","permalink":"https://jiaopianjun.cc/tags/css/"},{"name":"笔记","slug":"笔记","permalink":"https://jiaopianjun.cc/tags/笔记/"}]},{"title":"使用 HyperApp，打造一个安全稳定超高速的科学上网环境","date":"2017-08-07T06:30:43.000Z","path":"2017/08/07/科学上网.html","text":"这是原作者 @waylybaye 一开始发布在少数派上的文章搬运过来，文章所有权归 原作者 @waylybaye 所有 这篇文章将会介绍如何获取由 Google 提供的一年 $300 美金的试用金，然后使用 HyperApp 搭建一个低延迟超高速的科学上网环境。网络延迟基本在50ms左右，并且可以流畅观看 Youtube 4K 视频。本文不需要读者有较深的技术背景，全部过程都可视化、自动化完成。 下文用 GCP 代表 Google Cloud Platform，指 Google 的整个云平台。GCE 是指 Google Cloud Engine，是 GCP 产品线里的一个主机产品。现状啊 ！！ 本文前提条件 1.有一个 Google 账号，没有的话可以注册一个. 2.注册 GCP 免费试用需要用信用卡进行身份验证（只做验证，不会收费），所以你必须有一个 Visa/MasterCard 的信用卡才行。如果你是一位学生还没有信用卡，可以查看文末的学生优惠计划。 GCP 注册以及创建服务器1.要访问 Google 首先需要你能科学上网，但是这篇文章又是介绍如何科学上网的，好像有点🐔生蛋蛋生🐔的矛盾… 其实你可以去App Store搜索 V屁恩，找一个免费的下载后，通过签到等方式暂时领取一天或者几个小时的免费低速试用来完成下面的教程。 2.注册 GCP 免费试用 c7e73bf5e3e3d793f68b3453f019e71b.png GCP Free Tier 3.登录Google账号后使用这个链接来注册 https://cloud.google.com/free/ ，在打开的页面中点击Try it Free. 4.接受条款，并点击同意并继续 5.在页面中填入你的信息： 6.账号类型：个人 7.名称和地址：填写你的地址、电话等 8.付款方式：添加一个信用卡。这个信用卡将会用来验证身份，防止GCP被滥用。 9.点击 开始免费使用 完成注册 10.在后面的页面中，如果你能看到页面顶部有一个“礼物 🎁 ” 的小图标，说明已经获取了试用金。 新建主机 8ef350c70dbe91ba11ca92663191019f.png 创建服务器 在左侧菜单中导航到 计算引擎 → VM 实例 1.点击加号按钮，创建一个 VM 实例。 2.名称：随意填入一个易记得名字 3.地区：建议选择asia-east1-* 三个中的任意一个，这个机房是在台湾，国内的延迟只有 50~70ms，简直快到飞起。 机器类型：选择 “小型” (1.7G 内存) 就可以了。默认选中的 3.75G 的内存其实用不完。 启动磁盘：默认的Debian 8就可以，推荐 Ubuntu 16.04 LTS。另外为了防止将来磁盘不够用，你可以点击右下角的更改，大小里使用 20G 或者 30G。 防火墙：选中 “允许HTTP流量” 和 ”允许HTTPS流量“ 点击创建，稍等几分钟就会创建完毕，现在打开 HyperApp 开始配置这台服务器吧。 HyperApp HyperApp 是一个部署自动化以及服务器监控管理的App，致力于让普通用户也可以使用云服务 本段介绍如何使用 HyperApp 管理刚刚创建的服务器，开启 BBR 加速，安装科学上网应用。 [ ](http://upload-images.jianshu.io/upload_images/1251988-3fc1e1ee251ec9d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 添加服务器 自动配置服务器 1.在服务器页面点击右下角的加号，然后选择第二个自动配置 2.点击开始，应用会自动生成一对密钥，但这个过程在某些手机上会耗时较长，请耐心等到 十几秒~几分钟 左右。 3.等到出现“一切就绪”时，点击复制将代码复制到剪贴板里，如果你用电脑操作的话可以点击发送将代码通过任意一种方式发送到电脑上 在Web SSH里面运行命令 1.在 GCE 计算引擎 → VM 实例 页面，选择刚刚创建的实例的 SSH ▽ 在浏览器窗口中打开 打开一个基于 Web 的 SSH 终端。 2.在浏览器的SSH中粘贴并运行刚刚复制的代码。等到二维码出现时，使用 HyperApp 扫描该二维码便会自动添加该服务器。添加后 HyperApp 会检测刚刚添加的服务器的基本运行状况。 永久添加公钥1.注意：你可以暂时跳过本小段，进行后续的操作，如果 HyperApp 出现了认证错误的提示，可以回到这段进行操作。 2.刚刚的自动配置的功能在几乎所有主机上都可以用，但是 GCE 是个例外，它会清空用户自行添加的公钥，所以几分钟后可能就会出现密钥认证失败的错误。你可以通过以下步骤永久性的设置密钥。 3.打开 更多 → SSH Keys → 点击唯一的一个 Key → 复制公钥。 4.在GCP 中打开计算引擎→元数据 → SSH 密钥 点击修改后，复制并添加刚刚的公钥。 5.添加后页面会出现一行新记录，主要有两列： 用户名 和 密钥。这个用户名应该是 HyperApp，然后打开 HyperApp → 服务器 → 点击服务器下面的螺丝按钮 → 修改 用户名 为刚刚显示的用户名，保存后就可以了。 6.开发者注：抱歉，最新的版本(2.5.90) 中第2步有个bug，用户名没有设置对，复制公钥后，需要手动改下最后一串[空格] 后面36个字符的 xx-xx-xx-xx 改成 用户名@iPhone 的格式，用户名可以随便写，然后将修改后的公钥添加后按照第三步中的做就行了。不改也可以用，只要确保服务器的用户名和第三步时显示的用户名一致即可 开启 BBR 加速，跑满带宽 这一步并不影响科学上网，但是会极大的提高上网质量。BBR是 Google 开发的TCP拥塞控制技术，并且已经合并到较新的Linux内核中。它的主要作用是可以让你跑满服务器的带宽。 比如说没有开启的情况下你观看 Youtube 720P的视频都可能会卡，但是开启了BBR后 1080P 的视频完全无卡顿，就连 4K 视频也可以流畅观看（有些网络特别卡的除外）。 要开启 BBR 需要升级 Linux 内核，不过不用急，在 HyperApp 中开启非常简单： BBR 1.在服务器卡片中点击右上角的 Terminal 图标（就是那个长的像个表情 [ &gt;_ ] 的按钮），进入 SSH 终端。 2.选择最下面的一行工具栏的第一个图标，然后点击 “teddyun/BBR” 一键脚本的链接，点击后会让你确认是否下载并执行外部脚本。 3.点击确认后会自动下载并执行，执行过程中需要点击键盘上回车键确认继续。如果想中断执行，那么点击 ctrl 后按 c 终止执行。 4.稍等几分钟，等待系统内核升级到最新版后会自动重启。 5.注：这是系统层面的升级，执行完毕后不必对其它应用做任何配置。客户端也不需要做任何配置。 部署科学上网应用 创建、配置应用 1.在 商店 页面 网络 分组下选择任意一个应用，这里我们选择占用资源最少的 ****-libev，（下文用SS代替）点击该应用。在弹出的对话框中选择刚刚添加的服务器，点击创建应用 2.在出现的配置页面中输入简单的一些配置： 3.Port: 端口，可以填入 80 或者 443（因为用其它端口需要设置防火墙） 4.Password：随便填入一个密码 5.Encrypt：选择一种加密方式，推荐针对移动访问优化的 chacha20 6.OBFS: 使用 OBFS 可以将 SS 流量伪装成正常的网页访问从而达到欺骗效果，可以防止被墙或者运营商干扰。另外还有人利用此功能实现“免流”效果：运营商会对一些域名免收流量费，于是可以将所有SS流量伪装成对某个域名的访问从而达到免流效果，具体此处不表。可以暂时忽略这个选项。 7.保存后在应用卡片中点击选中的服务器，然后选择安装就可以了。 安装 应用创建、配置、安装的动画 如果你使用其它端口，请参考文末的 设置GCE防火墙 如何开启防火墙。 客户端设置 嗯，服务端这就安装好了，不过在手机及Mac/PC上想要使用还需要有个客户端。 iOS iOS 上有很多 SS 的客户端可供选择，收费的有 小火箭、土豆丝、Xxxxx、Xxxxx 等。免费的可以使用 Wingy。基本上所有的应用配置方法都是一样的，只要添加服务器，填入你的服务器IP、端口、密码和加密方式即可，这里不再详述。 Mac/Windows Mac 和 Windows 上都有免费的 SS 客户端可以使用，配置方法也是只要输入你的IP、端口、密码和加密方式即可。 其它玩法 现在你有了一台 1.75G 内存的服务器了，只用来做SS好像有点浪费（SS只占用几M内存），其实使用 HyperApp 还有很多其它玩法，商店里面有很多其它应用，都可以自动安装配置。 比如你可以自己搭建一个博客、网站、论坛，个人网盘，聊天服务，并且可以自动配置HTTPS。如果你玩游戏可以创建一个 Minecraft 服务器。或者部署一个接收微信消息转发到Telegram的机器人。更多信息可以参阅👇 的 HyperApp 文档和教程。 HyperApp 支持 官方文档和教程 Telegram 群 Twitter @HyperApp 作者微博 @waylybaye 如果你遇到了各种各样的技术问题，比如无法安装、无法连接等，可以在群里召唤机器人或者开发者进行解答。或者在App里面点击 发送反馈邮件获取帮助，这两种是最快的获取帮助的方式。 自建和购买商业服务对比有什么优势？ 最主要的优势是隐私和安全，如果你看下上面SS的日志，你就知道服务商可以知道你的所有浏览历史的，如果你访问了不支持HTTPS的网站，那么请求内容也可能被监控（比如密码信息）。 另外是质量和成本，很多商家是使用和上面同样的机器但是卖给几百个人，你应该能明白了。成本方面没有免费试用的话1个人用可能会有点贵，但如果和朋友家人一起用就超值了，比如使用$2.5/月的 Vultr，每月500G 流量够很多人用的。 学生优惠计划 腾讯云：学生优惠套餐 ￥10/月，需抢购 阿里云：云翼计划 ￥9.9/月 不过好像不能创建海外的主机所以无法搭建科学上网环境。 设置 GCE 防火墙 在GCP后台点击 网络 → 防火墙规则 点击 创建防火墙规则 名称：随便输入一个名称 目标：选择 网络中的所有示例 来源过滤：0.0.0.0/0 协议和端口：指定的协议和端口 下面输入tcp;udp:端口号","tags":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiaopianjun.cc/tags/技术分享/"},{"name":"Hyperapp","slug":"Hyperapp","permalink":"https://jiaopianjun.cc/tags/Hyperapp/"},{"name":"科学上网","slug":"科学上网","permalink":"https://jiaopianjun.cc/tags/科学上网/"},{"name":"日常挖坑","slug":"日常挖坑","permalink":"https://jiaopianjun.cc/tags/日常挖坑/"}]},{"title":"增加文章列表截断","date":"2017-07-25T12:03:15.000Z","path":"2017/07/25/增加文章列表截断.html","text":"增加首页列表截断，避免文章过长影响阅读","tags":[{"name":"日常优化","slug":"日常优化","permalink":"https://jiaopianjun.cc/tags/日常优化/"},{"name":"打卡下班","slug":"打卡下班","permalink":"https://jiaopianjun.cc/tags/打卡下班/"}]},{"title":"更新日常","date":"2017-07-14T10:22:13.000Z","path":"2017/07/14/更新日常.html","text":"修改tag 标签样式 修改tag标签开关样式","tags":[{"name":"更新日常","slug":"更新日常","permalink":"https://jiaopianjun.cc/tags/更新日常/"}]}]