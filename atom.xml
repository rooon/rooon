<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>故事胶片</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiaopianjun.cc/"/>
  <updated>2019-06-19T05:08:40.202Z</updated>
  <id>https://jiaopianjun.cc/</id>
  
  <author>
    <name>Lieme</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重学JavaScript之基本概念(中) =&gt; 操作符</title>
    <link href="https://jiaopianjun.cc/2019/06/18/%E9%87%8D%E5%AD%A6JavaScript%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-%E4%B8%AD-%E6%93%8D%E4%BD%9C%E7%AC%A6.html"/>
    <id>https://jiaopianjun.cc/2019/06/18/重学JavaScript之基本概念-中-操作符.html</id>
    <published>2019-06-18T05:03:00.000Z</published>
    <updated>2019-06-19T05:08:40.202Z</updated>
    
    <content type="html"><![CDATA[<h5 id="注意：-本文章为-《重学js之JavaScript高级程序设计》系列第三章第二部分【操作符】。"><a href="#注意：-本文章为-《重学js之JavaScript高级程序设计》系列第三章第二部分【操作符】。" class="headerlink" title="注意： 本文章为 《重学js之JavaScript高级程序设计》系列第三章第二部分【操作符】。"></a>注意： 本文章为 《重学js之JavaScript高级程序设计》系列第三章第二部分【操作符】。</h5><h5 id="关于《重学js之JavaScript高级程序设计》是重新回顾js基础的学习。"><a href="#关于《重学js之JavaScript高级程序设计》是重新回顾js基础的学习。" class="headerlink" title="关于《重学js之JavaScript高级程序设计》是重新回顾js基础的学习。"></a>关于《重学js之JavaScript高级程序设计》是重新回顾js基础的学习。</h5><p><img src="https://user-gold-cdn.xitu.io/2019/6/18/16b695f1f56afc15?w=1280&amp;h=720&amp;f=jpeg&amp;s=136054" alt></p><h2 id="1-操作符"><a href="#1-操作符" class="headerlink" title="1. 操作符"></a>1. 操作符</h2><blockquote><p>用于描述一组可以操作数据值的概念叫做操作符。包括 算术操作符（加号和减号）、位操作符、关系操作符和相等操作符。ES的操作符和其他不同的在于它能够适用于很多值，如：字符串、数字值、布尔值、甚至对象。在应用于对象的时候，需要调用对象的 valueOf()  和 toString()方法。</p></blockquote><h3 id="1-1-一元操作符"><a href="#1-1-一元操作符" class="headerlink" title="1.1 一元操作符"></a>1.1 一元操作符</h3><blockquote><p>只能操作一个值的操作符叫做一元操作符。</p></blockquote><h4 id="1-1-1-递增和递减操作符"><a href="#1-1-1-递增和递减操作符" class="headerlink" title="1.1.1 递增和递减操作符"></a>1.1.1 递增和递减操作符</h4><blockquote><p>分为两种类型：前置和后置型，前置位于要操作的变量之前。后置则在要操作的变量之后。如下：</p></blockquote><pre><code>var age = 29++age // 30等于age = age + 1--age // 28等于age = age - 1</code></pre><p><strong>注意：执行前置递增或递减的时候，变量的值都是在语句被求值以前改变的。</strong></p><pre><code>var age = 29var a = --age + 2age // 28a // 30// 由于前置递增和递减与执行语句的优先级相等，所以整个语句会被从左到右求值。var num1 = 2var num2 = 20var num3 = --num1 + num2 // 21var num4 = num1 + ++num3 // 23</code></pre><p>后置型递增和递减操作语法不变，只不过由前面放到了后面，而且最重要的是：<strong>后置型递增和递减的操作都是在变量执行之后在操作的</strong>。如下：</p><pre><code>var num = 3var age = 4num-- + age-- // 7num // 2age // 4</code></pre><p><strong>总结：</strong></p><p>以上4个操作符对任何值都适用，不限于数字还可以用于字符串、布尔值、浮点数值和对象，规则如下：<br>    1、应用于数字字符的字符串时候，先将其转换为数字值，<br>    在执行加减 1 的操作，字符串变量变成数值变量。</p><pre><code>2、应用于不包含有效数字的字符串时，将其变量的值设置位NaN，字符串变量变成数值变量3、用于布尔值false的时候，将其转换为0，在执行加减1的操作，布尔值变成数值4、用于布尔值true的时候，将其转换为1，在执行加减1的操作，布尔值变成数值5、用于浮点数，执行加减1的操作6、用于对象，先调用对象的valueOf()方法，如果返回的结果是NaN在调用toString()方法，对象的变量变成数值变量。</code></pre><p><strong>上面的说明如下：</strong></p><pre><code>var s1 = &apos;2&apos;var s2 = &apos;z&apos;var s3 = falsevar s4 = 1.1var s5 = {    valueOf: function(){        return -1    }}s1++ // 3s2++ // NaNs3++ // 1s4-- // 0.10000000000009s5-- // -2</code></pre><h4 id="1-1-2-一元加和减操作符"><a href="#1-1-2-一元加和减操作符" class="headerlink" title="1.1.2 一元加和减操作符"></a>1.1.2 一元加和减操作符</h4><blockquote><p>一元加操作符放在变量之前是没有任何变化的，而一元减操作符放在变量之前则变量是个负数</p></blockquote><pre><code>var num = 25num = +num // 25num = -num // -25</code></pre><p>注意：还是遵循之前的规则，对于字符串的变量使用加减操作符 则变成 NaN 其他的则相应变成指定规则的数值。</p><p>一元加减操作符主要用于基本的算术运算，也可以用于转换数据类型。</p><h3 id="1-2-位操作符"><a href="#1-2-位操作符" class="headerlink" title="1.2 位操作符"></a>1.2 位操作符</h3><blockquote><p>位操作符是用于内存中表示数值的位来操作数值。ES中所有的值都是按照64位格式存储，但位操作符并直接操作64位值，而是先将64位的值转换成32位整数，然后执行操作，最后在将结果转换位64位。</p></blockquote><blockquote><p>对于有符号的整数，32位中的前31位用于表示整数的值，第32位表示数值的符号，0表示整数，1表示负数。这个表示符号的位叫做符号位。符号位的值决定了其他位数值的格式。其中，正数以纯二进制格式存储，31位中的每一位都表示2的幂，第一位表示 2的0次方以此类推。没有用到的用0填充忽略不计。也就是2进制表示法。</p></blockquote><p>负数同样可以以二进制存储，但是使用的格式是二进制补码，计算一个数值的二进制补码步骤如下：</p><pre><code>1、求这个数值绝对值的二进制码2、求二进制反码3、得到的二进制反码 +1如下：求 -18的二进制码0000 0000 0000 0000 0000 0001 0010求反码 0 1 互换1111 1111 1111 1111 1111 1110 1101然后 加 1 1111 1111 1111 1111 1111 1110 1110</code></pre><p>在ES中，ES会尽力向我们隐藏所有这些信息，也就是说，在二进制字符串形式输出一个负数时，我们看到的只是这个负数绝对值的二进制码之前加了一个负号，如下：</p><pre><code>var num = -18num.toString(2) // &apos;-10010&apos;</code></pre><p><strong>注意</strong>：默认情况下，ES中所有的整数都是有符号整数，当然也存在无符号整数，对于无符号整数来说，第32位不再表示符号，因为无符号整数只能是正数，而且无符号整数的值可以更大，因为多出来的一位不再表示符号，可以用来表示数值。</p><blockquote><p>在ES中当对应数值应用位操作符时，后台会发生如下转换过程:64位的数值被转换成32位数值，然后执行位操作，最后再将32位数值转换回64位数值。这样表面上看起来好像是在操作 32 位数值，另外有个问题，这样的操作导致在特殊值 如 NaN 和 Infinity值应用位操作的时候，这两个值会被当成0来处理。</p></blockquote><p><strong>注意</strong>：如果对非数值进行位操作符，那么会先使用 Number() 函数将该值转换为一个数值，在应用位操作，得到的结果是一个数值。</p><ol><li>按位非（NOT）</li></ol><blockquote><p>按位非操作符由一个波浪线(~)表示，执行按位非的结果就是返回数值的反码并减一，如下：</p></blockquote><pre><code>var num = 25    // 二进制 0001 1001var num1 = ~num // 二进制 1110 0110// -26</code></pre><ol start="2"><li>按位与</li></ol><blockquote><p>按位与操作符由一个和字符号(&amp;)表示，它有两个操作符数。从本质上来讲，按位与操作就是将两个数值的每一位对齐，根据以下规则，对相同位置上的两个数执行AND操作：</p></blockquote><p><strong>结果：全1才为1，有0返回0</strong></p><table><thead><tr><th>第一个数值的位</th><th>第二个数值的位</th><th>结果</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td></tr></tbody></table><ol start="3"><li>按位或(OR)</li></ol><blockquote><p>按位或由一个竖线符号（|）表示，同样也有两个操作数，操作结果遵循下表。</p></blockquote><table><thead><tr><th>第一个数值的位</th><th>第二个数值的位</th><th>结果</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>0</td><td>0</td></tr></tbody></table><p><strong>结果：有1返回1，全0返回0</strong></p><ol start="4"><li>按位异或(XOR)</li></ol><blockquote><p>按位异或操作符由一个插入符号 (^)表示，也是两个操作数，结果遵循下表：</p></blockquote><table><thead><tr><th>第一个数值的位</th><th>第二个数值的位</th><th>结果</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>0</td><td>0</td></tr></tbody></table><p><strong>结果：两个数只有1个为1的时候才返回1，同时为1或同时为0 则返回0</strong></p><ol start="5"><li>左移</li></ol><blockquote><p>左移操作符由两个小于号（&lt;&lt;）表示，这个操作符会将数值的所有位向左移动指定的位数。如下：</p></blockquote><pre><code>// 将数值2向左移动5位，结果就是64位var oldnum = 2  // 二进制 10 var newnum = oldnum &lt;&lt; 5  // 二进制 1000000 ， 十进制 64注意： 在向左移位后，原数值的右侧多出了 5 个空位，左移操作会以0来填充这些空位，以便得到的结果是一个完整的32位的二进制数。</code></pre><ol start="6"><li>有符号的右移</li></ol><blockquote><p>有符号的右移操作符由两个大于号（&gt;&gt;）表示，这个操作符会将数值向右移动，但保留符号位（即正负号标记），有符号的右移操作与左移操作恰好相反，即如果将64向右移动5位，结果将变回2.如下：</p></blockquote><pre><code>var oldnum = 64 // 二进制 1000000var newnum = oldnum &gt;&gt; 5    // 二进制 10 2注意：在移位的过程中，原数值也会出现空位，只不过这次空位出现在原数值的左侧、符号位的右侧，这时候ES就会用符号位的值来填充所有的空位，以便得到一个完整的值。</code></pre><ol start="7"><li>无符号右移</li></ol><blockquote><p>无符号右移操作符右三个大于号（&gt;&gt;&gt;）组成，这个操作符会将数值的所有32位都向右移动，对于正数来说，无符号右移的结果与有符号右移相同，如下</p></blockquote><pre><code>var oldnum = 64     // 二进制 1000000var newnum = oldnum &gt;&gt;&gt; 5   // 二进制 10  十进制 2</code></pre><p>注意：在负数下情况就不一样了，首先，无符号右移是<strong>以0来填充空位</strong>，而不是像有符号右移那样以<strong>符号位来填充空位</strong>。所以，对正数的无符号右移与有符号右移结果相同，但对负数的结果就不一样了。其次无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对值补码形式表示，因此就会导致无符号右移后的结果非常之大。如下：</p><pre><code>var oldnum = -64    // 二进制 11111111111111111111111111000000var newnum = oldnum &gt;&gt;&gt; 5   // 十进制 134217726</code></pre><p><img src="https://user-gold-cdn.xitu.io/2019/6/18/16b69606d7c1155c?w=258&amp;h=258&amp;f=jpeg&amp;s=26659" alt></p><p align="center" style="font-size:30px;color:#1c8a95"> 欢迎关注 公众号【小夭同学】 </p><p><strong>重学js系列</strong></p><p><a href="https://juejin.im/post/5ca2d96b6fb9a05e3d0a770f" target="_blank" rel="noopener">重学js之JavaScript简介</a></p><p><a href="https://juejin.im/post/5cebebe9f265da1b7638802c" target="_blank" rel="noopener">重学 JS 之在 HTML 中使用 JavaScript</a></p><p><a href="https://juejin.im/post/5cf3a9dbf265da1bc4143c29" target="_blank" rel="noopener">重学js之JavaScript基本概念（上）=&gt; 数据类型</a></p><p><strong>ES6入门系列</strong></p><p><a href="https://juejin.im/post/5ca2d96b6fb9a05e3d0a770f" target="_blank" rel="noopener">ES6入门之let、cont</a></p><p><a href="https://juejin.im/post/5cadf187518825710d76ced7" target="_blank" rel="noopener">ES6入门之变量的解构赋值</a></p><p><a href="https://juejin.im/post/5cb9c199518825329e7ea84a" target="_blank" rel="noopener">ES6入门之字符串的扩展</a></p><p><a href="https://juejin.im/post/5cbeff3a6fb9a03202221a68" target="_blank" rel="noopener">ES6入门之正则的扩展</a></p><p><a href="https://juejin.im/post/5cc30a935188252dcc14c68d" target="_blank" rel="noopener">ES6入门之数值的扩展</a></p><p><a href="https://juejin.im/post/5cc30b2551882562457fdc4b" target="_blank" rel="noopener">ES6入门之函数的扩展</a></p><p><a href="https://juejin.im/post/5cd2a392f265da038733b913" target="_blank" rel="noopener">ES6入门之数组的扩展</a></p><p><a href="https://juejin.im/post/5ce3f8d5518825685e02b99e" target="_blank" rel="noopener">ES6入门之对象的扩展</a></p><p><strong>Git教程</strong></p><p><a href="https://segmentfault.com/a/1190000018762537" target="_blank" rel="noopener">前端Git基础教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;注意：-本文章为-《重学js之JavaScript高级程序设计》系列第三章第二部分【操作符】。&quot;&gt;&lt;a href=&quot;#注意：-本文章为-《重学js之JavaScript高级程序设计》系列第三章第二部分【操作符】。&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="重学JS系列" scheme="https://jiaopianjun.cc/categories/%E9%87%8D%E5%AD%A6JS%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JavaScript" scheme="https://jiaopianjun.cc/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript之继承（未完待续）</title>
    <link href="https://jiaopianjun.cc/2019/06/11/JavaScript%E4%B9%8B%E7%BB%A7%E6%89%BF%EF%BC%88%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD%EF%BC%89.html"/>
    <id>https://jiaopianjun.cc/2019/06/11/JavaScript之继承（未完待续）.html</id>
    <published>2019-06-11T14:28:00.000Z</published>
    <updated>2019-06-11T14:33:47.684Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blogimg.lieme.cn/FlB0H5AuWXIQ86Wt5iWNY5wICbsJ" alt="微信图片_20190611223220.jpg" title>                </div>                <div class="image-caption" style="display:none;">微信图片_20190611223220.jpg</div>            </figure><p>#</p><h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h2><blockquote><p>从父级上继承，但是有个问题，如果有多个子类同时继承一个父类，如果改变其中一个子类，其余子类也会跟着改变，这种情况就和数组对象的浅拷贝一样。</p></blockquote><pre><code>function parents(){    this.name = [&apos;fuqin&apos;]}parents.prototype.getName = function() {    console.log(this.name)}function child(){}child.prototype = new parents()let child1 = new child()child1.getName() // [&apos;fuqin&apos;]let child2 = new child()child1.name.push(&apos;haha&apos;)let child3 = new child()child1.getName() //  =&gt; [&apos;fuqin&apos;, &apos;haha&apos;]child2.getName() //  =&gt; [&apos;fuqin&apos;, &apos;haha&apos;]child3.getName() //  =&gt; [&apos;fuqin&apos;, &apos;haha&apos;]</code></pre><h2 id="2-构造函数继承"><a href="#2-构造函数继承" class="headerlink" title="2. 构造函数继承"></a>2. 构造函数继承</h2><blockquote><p>改进了原型链继承的缺点，不会因为某个实例的更改而导致所有继承实例的变化，但是也有它的缺点就是每次创建实例都会创建一遍方法。</p></blockquote><pre><code>function parents(){    this.name = [&apos;brother&apos;]}function child(){    parents.call(this)}let child1 = new child()let child2 = new child()child1.name.push(&apos;haah&apos;)let child3 = new child()console.log(child1.name) // =&gt; [&apos;brother&apos;, &apos;haah&apos;]console.log(child2.name) // =&gt; [&apos;brother&apos;]console.log(child3.name) // =&gt; [&apos;brother&apos;]</code></pre><p>// 在构造函数继承中还可以通过call()传递参数</p><pre><code>function parents(name){    this.name = name}function child(name){    parents.call(this,name)}let child1 = new child(&apos;hh,我是1&apos;)let child2 = new child(&apos;hh,我是2&apos;)child1.name // =&gt; &apos;hh,我是1&apos;child2.name // =&gt; &apos;hh,我是2&apos;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
      
    
    </summary>
    
      <category term="Coding" scheme="https://jiaopianjun.cc/categories/Coding/"/>
    
    
      <category term="JavaScript" scheme="https://jiaopianjun.cc/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>周末闲逛</title>
    <link href="https://jiaopianjun.cc/2019/06/11/%E5%91%A8%E6%9C%AB%E9%97%B2%E9%80%9B.html"/>
    <id>https://jiaopianjun.cc/2019/06/11/周末闲逛.html</id>
    <published>2019-06-11T07:49:17.000Z</published>
    <updated>2019-06-11T07:49:17.947Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>重学JavaScript之基本概念(上) =&gt; 数据类型</title>
    <link href="https://jiaopianjun.cc/2019/06/02/%E9%87%8D%E5%AD%A6JavaScript%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5(%E4%B8%8A)%20=%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"/>
    <id>https://jiaopianjun.cc/2019/06/02/重学JavaScript之基本概念(上) = 数据类型.html</id>
    <published>2019-06-02T13:30:00.000Z</published>
    <updated>2019-06-11T14:58:13.274Z</updated>
    
    <content type="html"><![CDATA[<p>前提：任何语言的核心都会描述这门语言最基本的工作原理，通常描述的内容会涉及到这门语言的语法 、操作符、数据类型、内置功能等用于构建复杂解决方案的基本概念。</p><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h3><pre><code>1、js 中的变量、函数名和操作符都区分大小写，2、另外一些像typeof这些关键字也不能使用</code></pre><h3 id="2-标识符"><a href="#2-标识符" class="headerlink" title="2. 标识符"></a>2. 标识符</h3><blockquote><p>所谓标识符就是指变量、函数、属性的名字，或者函数的参数。</p></blockquote><pre><code>标识符的写法标准如下：1、第一个字符必须是一个字母、下划线或者一个美元符号2、其他字符可以是字母、下划线、美元符号或数字3、标识符中的字母采用驼峰大小写格式，例如：firstSecond、myCar</code></pre><h3 id="3-注释"><a href="#3-注释" class="headerlink" title="3. 注释"></a>3. 注释</h3><blockquote><p>js的注释包括单行注释和块级注释，单行注释两个反斜杠开头，块级注释则是以（/<em>）开始以（</em>/）结束 </p></blockquote><pre><code>单行注释// 注释块级注释/*    块级注释*/</code></pre><h3 id="4-语句"><a href="#4-语句" class="headerlink" title="4. 语句"></a>4. 语句</h3><blockquote><p>在js中语句是以分毫结尾但是不是必须的，但是推荐还是写上分号。因为这样在压缩代码的时候就不会出现不必要的问题。</p></blockquote><h3 id="5-关键字和保留字"><a href="#5-关键字和保留字" class="headerlink" title="5. 关键字和保留字"></a>5. 关键字和保留字</h3><blockquote><p>在js中有一些特定的关键字，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作等，关键字是语言特地保留的，所以不能用作标识符。另外在js中还有另外一些保留字，也是不能用来当作标识符。</p></blockquote><h3 id="6-变量"><a href="#6-变量" class="headerlink" title="6. 变量"></a>6. 变量</h3><blockquote><p>因为js的变量是松散类型的，松散类型就是可以用来保存任何类型的数据。每个变量仅仅是用来保存值的占位符而已，定义变量需要用到var，在之后的ES6中增加了let和const关键字来定义变量。</p></blockquote><pre><code>var a = 10 // 定义一个变量a 给它赋值 10</code></pre><p>注意：虽然省略 var 操作符可以定义全局变量，但是并不推荐这种做法，因为在局部作用域中定义全局变量会使得代码很难维护。</p><h3 id="7-数据类型"><a href="#7-数据类型" class="headerlink" title="7. 数据类型"></a>7. 数据类型</h3><blockquote><p>在js中有5种基本数据类型：Undefined、Null、Boolean、Number和String，复杂类型 Object。Object是一组由无序的名值对组成的。在ES中不支持任何创建自定义类型的机制。</p></blockquote><h3 id="8-typeof操作符"><a href="#8-typeof操作符" class="headerlink" title="8. typeof操作符"></a>8. typeof操作符</h3><blockquote><p>用来检测给定变量的数据类型，检测的返回值如下：</p></blockquote><pre><code>undefined -- 值未定义Boolean -- 布尔值string -- 字符串number -- 数值object -- 对象或者nullfunction -- 函数</code></pre><p>typeof操作符的操作数可以是变量，也可以是数值字面量，typeof是一个操作符而不是函数。</p><h3 id="9-undefined"><a href="#9-undefined" class="headerlink" title="9. undefined"></a>9. undefined</h3><blockquote><p>它只有一个特殊类型的值即undefined，如果变量在var后没有赋值，那么这个变量的值就是 undefined。</p></blockquote><pre><code>var message;message // undefined</code></pre><p>注意：未初始化的变量和未赋值的变量 typeof之后都是undefined，所以为了更好的判断undefined的来源到底是未赋值还是未初始化，建议所有的值都声明在使用。</p><h3 id="10-null类型"><a href="#10-null类型" class="headerlink" title="10. null类型"></a>10. null类型</h3><blockquote><p>null 是第二个只有一个值的数据类型，值为 null，从表面看 null 表示的是一个空对象指针，而这个真是typeof 检测 null 返回值为 “object”的原因。</p></blockquote><p>如果你想定义一个变量用来保存对象，那么最好的做法就是将变量赋值 null 这样检测 null 就知道 相应的变量是否保存了一个对象的引用。</p><p>注意：null == undefined 为 true，尽管这样两者的用途并不相同。无论任何情况下都没有必要将一个变量的值显式的设置为 undefined，而null则是如果<strong>保存对象的变量没有真正保存对象</strong>，那么就应该明确的让变量保存null值。这样可以进一步的区分 null 和 undefined。</p><h3 id="11-Boolean类型"><a href="#11-Boolean类型" class="headerlink" title="11. Boolean类型"></a>11. Boolean类型</h3><blockquote><p>boolean类型有两个字面值：ture 和 false,另外这两个值和数字值不是一回事，ture 不一定等于1，false也不一定等于0.</p></blockquote><p>注意：true 和  false 是区分大小写的，True 和 Flase 只是标识符。</p><p>我们可以通过函数<strong> Boolean()</strong> 将一个值转换为Boolean类型。 如下：</p><pre><code>var message = &apos;haha,nihao&apos;;var zh = Boolean(message)</code></pre><p>各种类型的转换规则如下：</p><table><thead><tr><th>数据类型</th><th>转换为true的值</th><th>转换为false的值</th></tr></thead><tbody><tr><td>Boolean</td><td>true</td><td>false</td></tr><tr><td>String</td><td>任何非空字符串</td><td>“” (空字符串)</td></tr><tr><td>Number</td><td>任何非零数字值（包括无穷大）</td><td>0 和 NaN</td></tr><tr><td>Object</td><td>任何对象</td><td>null</td></tr><tr><td>Undefined</td><td>不适用</td><td>undefined</td></tr></tbody></table><h3 id="12-number类型"><a href="#12-number类型" class="headerlink" title="12. number类型"></a>12. number类型</h3><blockquote><p>在js中广泛使用的数据类型，有整数和浮点数值。可以通过十进制、八进制、十六进制的字面来表示。</p></blockquote><pre><code>var bjz = 070   // 八进制 56var sjz = 56    // 十进制 56var sljz = 0xA  // 十六进制 10</code></pre><h4 id="12-1-浮点数值"><a href="#12-1-浮点数值" class="headerlink" title="12.1 浮点数值"></a>12.1 浮点数值</h4><blockquote><p>就是该数值中必须包含一个小数点，并且小数点后面至少有一位数字。</p></blockquote><pre><code>var f = 1.1</code></pre><p><strong>注意</strong>：由于保存浮点数的内存空间是保存整数的两倍，所以以下情况会自动将浮点转换为整数保存，如下：</p><pre><code>var f = 1.  // 小数点后没有数字 保存为 1var b = 10.0 // 保存为 10</code></pre><p>另外对于 过大 或者过小的值可以通过 e（科学计数法）表示，如下：</p><pre><code>var f = 3.125e7   // 3.125 * 10^7 =&gt; 31250000var f = 3e-17     // js 会将小数点后面超过6个0的浮点数值转换为科学计数法</code></pre><p><strong>注意</strong>：0.1 + 0.2 ！= 0.3</p><h4 id="12-2-数值范围"><a href="#12-2-数值范围" class="headerlink" title="12.2 数值范围"></a>12.2 数值范围</h4><blockquote><p>js中由于内存的限制并不能保存所有的数值，js能够表示的最小值为 5e-324,最大值为 1.7976931348623157e + 308。如果某次计算数值超过最大 就转换为Infinity，最小为 -Infinity。如果出现这两个值，那么该值就不能在参与之后的运算了。</p></blockquote><h4 id="12-3-NaN"><a href="#12-3-NaN" class="headerlink" title="12.3 NaN"></a>12.3 NaN</h4><blockquote><p>js 中的非数值，是一个特殊的值。主要是为了防止抛出错误，用来表示一个本来返回数值的操作数未返回数值的情况。</p></blockquote><p>NaN 有两个特定，1、任何涉及NaN的操作都会返回NaN，2、NaN与任何值都不相等包括其本身。针对这两个特点，ES定义了<strong>isNaN()</strong> 函数，这个函数接受一个参数，该参数可以是任何类型，而该函数会帮我们确定这个参数是否 “不是数值”，isNaN()接受参数之后会尝试将这个值转换为数值，某些不是数值的值会直接转为数值。如下：</p><pre><code>isNaN(NaN)      // trueisNaN(10)       // false (10是一个数值)isNaN(&quot;10&quot;)     // false (可以被转换成数值10)isNaN(&apos;blue&apos;)   // true (不能转换成数值)isNaN(true)     // flase (可以被转换成数值 1)</code></pre><blockquote><p>注意：isNaN()也可以用于对象，在基于对象调用的时候，首先会调用 valueOf()方法，然后确定该方法的返回值是否可以转换为数值，如果不能则基于这个返回值在调用 toString() 方法,在测试返回值。</p></blockquote><h4 id="12-4-数值转换"><a href="#12-4-数值转换" class="headerlink" title="12.4 数值转换"></a>12.4 数值转换</h4><blockquote><p>有3个函数可以把非数值转换为数值：Number()、parseInt()、parseFloat()，第一个函数可以用于任何数据类型。另外两个函数用于将字符串转换为数值。</p></blockquote><pre><code>Number()转换规则如下：    Boolean值  =&gt; true or flase =&gt; 1 or 0    number =&gt; 传入和返回    null =&gt; 返回 0     undefined =&gt; 返回null    字符串        如果包含十进制数值 则 &apos;123&apos; =&gt; 123 ，&apos;012&apos; =&gt; 12        如果是浮点字符串 则 &apos;1.1&apos; =&gt; 1.1 ， &apos;01.1&apos; =&gt; 1.1        如果包含十六进制 则 &apos;0xf&apos; =&gt; 相同的十进制        如果为空 则 &apos;&apos; =&gt; 0        如果包含除了上述格式 则 &apos;&apos; =&gt; NaN        如果是对象，则调用对象的 valueOf()方法，在按照之前的规则转换返回值，    如果转换对象是NaN，则调用对象的 toString() 方法，在按照之前的规则返回字符串    值。parseInt()转换规则如下：    它会忽略字符串前面的空格，如果第一个字符不是数字或者负号则返回NaN。    如果是其他进制，则转换为响应的十进制数值。    var n = parseInt(&apos;1234blue&apos;)    =&gt; 1234    var m = parseInt(&apos;&apos;)            =&gt; NaNparseFloat()转换规则如下：    从第一个字符开始解析每个字符，知道遇到第一个无效的浮点数字字符为止    也就是说字符串中第一个小数点是有效的，第二个小数点就无效的了。因此    它后面的字符串就被忽略了。    var n = parseFloat(&apos;1234blue&apos;)    =&gt; 1234    var m = parseFloat(&apos;0xA&apos;)         =&gt; 0    var c = parseFloat(&apos;22.21.2&apos;)     =&gt; 22.21    var b = parseFloat(&apos;22.4&apos;)        =&gt; 22.4</code></pre><h3 id="13-string类型"><a href="#13-string类型" class="headerlink" title="13. string类型"></a>13. string类型</h3><blockquote><p> 用于表示由零或者多个16位 Unicode字符组成的字符序列，即字符串。由双引号（””）或者单引号 （’’）包裹而成</p></blockquote><pre><code>var a = &apos;124&apos;var b = &quot;123&quot;// 注意：双引号开头必须双引号结尾！</code></pre><h4 id="13-1-字符字面量"><a href="#13-1-字符字面量" class="headerlink" title="13.1 字符字面量"></a>13.1 字符字面量</h4><blockquote><p>一些特殊的字符字面量，即转义序列。用于表示非打印字符，或者具有其他用途的字符。</p></blockquote><table><thead><tr><th>字面量</th><th>含义</th></tr></thead><tbody><tr><td>\n</td><td>换行</td></tr><tr><td>\t</td><td>制表</td></tr><tr><td>\b</td><td>空格</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\f</td><td>进纸</td></tr><tr><td>\</td><td>斜杠</td></tr><tr><td>\’</td><td>单引号</td></tr><tr><td>\”</td><td>双引号</td></tr></tbody></table><p>这些字符可以出现在字符串冲的任意位置，而且也会被当作一个字符来解析。</p><p>任何字符串的长度都可以通过 <strong>length</strong> 属性来获取。</p><pre><code>let b = &apos;1kljk&apos;b.length // 5</code></pre><h4 id="13-2-字符串的特点"><a href="#13-2-字符串的特点" class="headerlink" title="13.2 字符串的特点"></a>13.2 字符串的特点</h4><blockquote><p>在 ES 中字符串是不可变的。字符串一旦被创建，它的值将不能被改变。如果要改变某个字符串的值则需要销毁原本的值，在重新赋值</p></blockquote><pre><code>var lang = &apos;shanghai&apos;lang = lang + &apos;daxue&apos;// shanghaidaxue</code></pre><h4 id="13-3-转换为字符串"><a href="#13-3-转换为字符串" class="headerlink" title="13.3 转换为字符串"></a>13.3 转换为字符串</h4><blockquote><p>如果想将一个值转换为字符串有两种方法。一、通过toString(),如下：</p></blockquote><pre><code>var age = 11;var agestring = age.toString() // &apos;11&apos;var b = truevar bstring = b.toString() // &apos;true&apos;</code></pre><p>大多数数据类型（数值、布尔值、对象和字符串值）都有<strong> toString</strong>方法，但是 null 和 undefined 没有。大多数情况下 <strong>toString</strong> 是不需要传递参数的。默认是以十进制格式返回数值的字符串表示。但是其实是可以传递八进制、二进制、十六进制参数的。</p><pre><code>var num = 10;num.toString()      // &apos;10&apos;num.toString(2)     // &apos;1010&apos;num.toString(8)     // &apos;12&apos;num.toString(10)    // &apos;10&apos;num.toString(16)    // &apos;a&apos;</code></pre><h3 id="14-object类型"><a href="#14-object类型" class="headerlink" title="14. object类型"></a>14. object类型</h3><blockquote><p>对象是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建的对象类型的名称来创建。创建的object类型的实例，可以为其添加属性和方法。</p></blockquote><pre><code>var o = new Object()</code></pre><blockquote><p>在ES中 Object类型是所有它的实例的基础，Object类型所具有的任何属性和方法也同样存在于更具体的对象中。</p></blockquote><h6 id="Object的每个实例都具有下列属性和方法："><a href="#Object的每个实例都具有下列属性和方法：" class="headerlink" title="Object的每个实例都具有下列属性和方法："></a>Object的每个实例都具有下列属性和方法：</h6><p><strong>constructor</strong> =&gt; 保存用于创建当前对象的函数</p><p><strong>hasOwnProperty（propertyName）</strong>=&gt; 用于检查给定的属性在当前对象实例中是否存在。propertyName必须以字符串形式指定。</p><p><strong>isPrototypeOf(object)</strong> =&gt; 用于检查传入的对象是否是另一个对象的原型。</p><p><strong>propertyIsEnumerable(propertyName)</strong> =&gt; 用于检查给的属性是否能够使用 for-in语句来枚举，与hasOwnProperty()方法一样，作为参数的属性名必须以字符串指定。</p><p><strong>toString()</strong> =&gt; 返回对象的字符串表示</p><p><strong>valueOf()</strong> =&gt; 返回对象的字符串、数值或布尔值表示。·</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前提：任何语言的核心都会描述这门语言最基本的工作原理，通常描述的内容会涉及到这门语言的语法 、操作符、数据类型、内置功能等用于构建复杂解决方案的基本概念。&lt;/p&gt;
&lt;h3 id=&quot;1-语法&quot;&gt;&lt;a href=&quot;#1-语法&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="重学JS系列" scheme="https://jiaopianjun.cc/categories/%E9%87%8D%E5%AD%A6JS%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JavaScript" scheme="https://jiaopianjun.cc/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>周末，天气很棒，瞎溜达</title>
    <link href="https://jiaopianjun.cc/2019/06/02/%E5%A4%A9%E6%B0%94%E5%BE%88%E5%A5%BD%EF%BC%8C%E5%91%A8%E6%9C%AB%E7%9A%84%E7%9E%8E%E6%BA%9C%E8%BE%BE.html"/>
    <id>https://jiaopianjun.cc/2019/06/02/天气很好，周末的瞎溜达.html</id>
    <published>2019-06-02T08:14:58.000Z</published>
    <updated>2019-06-11T15:49:11.033Z</updated>
    
    <content type="html"><![CDATA[<pre><code>周末天气很好呀，不能一直闷在家里，能得的好天气，肯定要出去玩耍的啦。周围夏天的气息越来越浓烈，乘着温度还没有那么高，带着帐篷，与大自然来一次亲密的接触。周围的风景也是很好，很安静，夕阳很美呀。</code></pre><h5 id="夕阳西下"><a href="#夕阳西下" class="headerlink" title="夕阳西下"></a>夕阳西下</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blogimg.lieme.cn/FvHtW8KSZyfJJZtM5-lmP16ve1J_" alt="夕阳西下" title>                </div>                <div class="image-caption" style="display:none;">夕阳西下</div>            </figure><h5 id="野花很漂亮呀"><a href="#野花很漂亮呀" class="headerlink" title="野花很漂亮呀"></a>野花很漂亮呀</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blogimg.lieme.cn/FieRiahc7SVPPVlTeCHQf_FzsHIY" alt="野花很漂亮呀" title>                </div>                <div class="image-caption" style="display:none;">野花很漂亮呀</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blogimg.lieme.cn/Fjxw0vq4qNBRWZlH6nCnqmbK8MYk" alt="微信图片_20190611231511.jpg" title>                </div>                <div class="image-caption" style="display:none;">微信图片_20190611231511.jpg</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blogimg.lieme.cn/Fsg6SlcNSzyHYI4CyWbpc4O_TD3C" alt="微信图片_20190611231604.jpg" title>                </div>                <div class="image-caption" style="display:none;">微信图片_20190611231604.jpg</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blogimg.lieme.cn/FlSdPFrtct5XqpetuuC6Ri6o2t4s" alt="微信图片_20190611231534.jpg" title>                </div>                <div class="image-caption" style="display:none;">微信图片_20190611231534.jpg</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blogimg.lieme.cn/lj769ZWcKjmTW3sIhftOXyE76Sxm" alt="微信图片_20190611231614.jpg" title>                </div>                <div class="image-caption" style="display:none;">微信图片_20190611231614.jpg</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blogimg.lieme.cn/lry4vcGlYZCp0JbnN2cO2buo_4Z6" alt="微信图片_20190611231519.jpg" title>                </div>                <div class="image-caption" style="display:none;">微信图片_20190611231519.jpg</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blogimg.lieme.cn/liRsEulYgQ-1bU6cmhpocJkTpRjR" alt="微信图片_20190611231600.jpg" title>                </div>                <div class="image-caption" style="display:none;">微信图片_20190611231600.jpg</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blogimg.lieme.cn/lnvfOMPst93Oj81EA3WwG5ISb07f" alt="微信图片_20190611231543.jpg" title>                </div>                <div class="image-caption" style="display:none;">微信图片_20190611231543.jpg</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blogimg.lieme.cn/lixswSHd0TF97rVAzlFWN45MQ6_s" alt="微信图片_20190611231527.jpg" title>                </div>                <div class="image-caption" style="display:none;">微信图片_20190611231527.jpg</div>            </figure><h5 id="太阳快下山了"><a href="#太阳快下山了" class="headerlink" title="太阳快下山了"></a>太阳快下山了</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blogimg.lieme.cn/lpNJJFlKMGEsuUUYwdtCD6zqe1Ut" alt="微信图片_20190611231552.jpg" title>                </div>                <div class="image-caption" style="display:none;">微信图片_20190611231552.jpg</div>            </figure><h5 id="回家吃晚饭啦"><a href="#回家吃晚饭啦" class="headerlink" title="回家吃晚饭啦"></a>回家吃晚饭啦</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blogimg.lieme.cn/luEgbOMraRHbYUnoAVIm5QyRDBb-" alt="微信图片_20190611231504.jpg" title>                </div>                <div class="image-caption" style="display:none;">微信图片_20190611231504.jpg</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;周末天气很好呀，不能一直闷在家里，能得的好天气，肯定要出去玩耍的啦。

周围夏天的气息越来越浓烈，乘着温度还没有那么高，带着帐篷，与大自然来一次亲密的接触。

周围的风景也是很好，很安静，夕阳很美呀。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;夕阳西下&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Life" scheme="https://jiaopianjun.cc/categories/Life/"/>
    
    
      <category term="周末" scheme="https://jiaopianjun.cc/tags/%E5%91%A8%E6%9C%AB/"/>
    
      <category term="郊游" scheme="https://jiaopianjun.cc/tags/%E9%83%8A%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Node.js内置模块</title>
    <link href="https://jiaopianjun.cc/2019/05/30/Node.js-%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97.html"/>
    <id>https://jiaopianjun.cc/2019/05/30/Node.js-内置模块.html</id>
    <published>2019-05-30T11:19:00.000Z</published>
    <updated>2019-06-11T15:01:12.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-http模块"><a href="#1-http模块" class="headerlink" title="1. http模块"></a>1. http模块</h2><blockquote><p>用来搭建本地服务器 </p></blockquote><pre><code>const http = require(&apos;http&apos;), http.createServer创建一个服务。</code></pre><h2 id="2-fs文件系统模块"><a href="#2-fs文件系统模块" class="headerlink" title="2. fs文件系统模块"></a>2. fs文件系统模块</h2><blockquote><p>赋予node读取本地文件的能力</p></blockquote><pre><code>const fs = require(&apos;fs&apos;);fs.writeFile(path, fileData, cb) // 写入文件fs.readFile(path, cb) // 读取文件</code></pre><h2 id="3-path路径模块"><a href="#3-path路径模块" class="headerlink" title="3. path路径模块"></a>3. path路径模块</h2><blockquote><p>用来处理路径相关</p></blockquote><pre><code>const path = require(&apos;path&apos;)let str = &apos;/c/dir/index.html&apos;console.log(path.dirname(str))path.resolve() // 路径解析，用来拼合路径，返回一个绝对路径</code></pre><h2 id="4-ur模块"><a href="#4-ur模块" class="headerlink" title="4. ur模块"></a>4. ur模块</h2><blockquote><p>用来处理网址相关，或者用来获取地址路径或参数</p></blockquote><pre><code>const url = require(&apos;url&apos;)let site = &apos;http://www.a.cn/a/b/index.html?a=1&amp;b=2&apos;let {pathname, query} = url.parse(site, true) //解析网址 true就是将参数解析为对象console.log(pathname, query)// &apos;/a/b/index.html&apos; {a: &apos;1&apos;, n: &apos;2&apos;}</code></pre><h2 id="5-querystring-查询字符串模块"><a href="#5-querystring-查询字符串模块" class="headerlink" title="5. querystring 查询字符串模块"></a>5. querystring 查询字符串模块</h2><blockquote><p>主要用来将参数拼接字符串解析为对象</p></blockquote><pre><code>const queryString = require(&apos;querystring&apos;)let str = &apos;a=1&amp;b=2&amp;c=3&apos;let obj = queryString.parse(str)console.log(obj, obj.a) //{a:&apos;1&apos;,b:&apos;2&apos;,c:&apos;3&apos;}, &apos;1&apos; let o = queryString.stringify(obj)console.log(0) // &apos;a=1&amp;b=2&amp;c=3&apos;</code></pre><h2 id="6-assert-断言"><a href="#6-assert-断言" class="headerlink" title="6. assert 断言"></a>6. assert 断言</h2><blockquote><p>判断条件是正确，如果正确则继续执行，如果错误则抛出异常</p></blockquote><pre><code>const assert = require(&apos;assert&apos;)// assert.deepEqual(变量，预期值，错误信息)   变量 == 预期值// assert.deepStrictEqual(变量，预期值，错误信息)  变量 === 预期值// 同样也是错误的时候抛出信息，正确的时候继续默默执行const obj = {a: {b: 1}}const obj1 = {a: {b: 1}}assert.deepEqual(obj, obj1, &apos;不等&apos;) // true</code></pre><h2 id="7-stream-流"><a href="#7-stream-流" class="headerlink" title="7. stream 流"></a>7. stream 流</h2><blockquote><p>以工作流的模式，读取文件，使得文件的读取跟水流一样。一边读取一边使用。合理分配内存，避免内存爆掉的风险</p></blockquote><pre><code>const fs = require(&apos;fs&apos;)// 读取流：fs.createReadStream();// 写入流：fs.createWriteStream();let rs = fs.createReadStream(a.txt)     // 读取的文件let ws = fs.createWriteStream(a2.txt)   // 写入的文件rs.pipe(ws) // pipe将rs 和 ws 连接起来，使得读取流的数据传输到输出流rs.on(&apos;error&apos;, err =&gt; {  console.log(err);});ws.on(&apos;finish&apos;, () =&gt; {  console.log(&apos;成功&apos;);})</code></pre><h2 id="8-zlib压缩"><a href="#8-zlib压缩" class="headerlink" title="8. zlib压缩"></a>8. zlib压缩</h2><blockquote><p>用来将文件压缩</p></blockquote><pre><code>const fs = require(&apos;fs&apos;)const zlib = require(&apos;zlib&apos;)let rs = fs.createReadStream(&apos;a.jpg&apos;)let gz = zlib.createGzip()let ws = fs.createWriteStream(&apos;a.jpg.gz&apos;)rs.pipe(gz).pipe(ws) // 原始文件 =&gt; 压缩 =&gt; 写入rs.on(&apos;error&apos;, err =&gt; {  console.log(err);});ws.on(&apos;finish&apos;, () =&gt; {  console.log(&apos;成功&apos;);})</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-http模块&quot;&gt;&lt;a href=&quot;#1-http模块&quot; class=&quot;headerlink&quot; title=&quot;1. http模块&quot;&gt;&lt;/a&gt;1. http模块&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;用来搭建本地服务器 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="Node系列" scheme="https://jiaopianjun.cc/categories/Node%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="node学习" scheme="https://jiaopianjun.cc/tags/node%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>重学 JS 之在 HTML 中使用 JavaScript</title>
    <link href="https://jiaopianjun.cc/2019/05/27/%E9%87%8D%E5%AD%A6%20JS%20%E4%B9%8B%E5%9C%A8%20HTML%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20JavaScript.html"/>
    <id>https://jiaopianjun.cc/2019/05/27/重学 JS 之在 HTML 中使用 JavaScript.html</id>
    <published>2019-05-27T13:32:00.000Z</published>
    <updated>2019-06-11T14:57:09.927Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2019/5/27/16af9942dbd2148c?w=1200&h=894&f=jpeg&s=342233" alt title>                </div>                <div class="image-caption" style="display:none;"></div>            </figure><p>#</p><h2 id="1-如何在页面中使用JavaScript"><a href="#1-如何在页面中使用JavaScript" class="headerlink" title="1. 如何在页面中使用JavaScript"></a>1. 如何在页面中使用JavaScript</h2><blockquote><p>现在在HTML中使用JS 的方法主要是通过在页面插入 <script> 标签 引入外部文件，另外一种是为 <script> 指定type属性然后把js代码放在<script>闭合标签中即可。如下：</p></blockquote><p>参数：</p><pre><code>charset - 指定 src 属性的代码字符集，一般为utf-8defer - 表示代码可以延迟到DOM完成加载之后在执行src - 外部引入js文件的路径type - 表示代码使用的脚本语言类型，一般为 text/javascript</code></pre><p>外部引入：</p><blockquote><script type="text/javascirpt" src="a.js" defer charset="utf-8"></script></p></blockquote><p>元素内部使用方法：</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;    alert(&apos;abc&apos;)    &lt;/script&gt;</code></pre><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><p>1、包含在 script 中的代码将依次从上往下依次执行</p><p>2、值得注意的是在js代码解析的过程中页面中其他内容将不会被加载和解析，直到该段js执行完成。</p><p>3、在书写的过程要注意，在script代码块中，不能在代码闭合标签  之前在出现闭合标签，这样会导致代码产生错误。</p><p>4、外部引用js的时候闭合标签可以省略，但是为了在IE中正确执行，建议不省略</p><p>5、如果你使用的是<strong>src</strong>引入外部js，那么在script标签之间不能再有内嵌js块</p><p>6、src引用外域js文件的时候要注意安全，因为这样可能会被替换js文件而导致安全问题。</p><p>7、js 代码块在页面中是顺序执行的，只有第一个全部执行完成之后才会顺序执行后面的。</p><h2 id="2-标签的位置"><a href="#2-标签的位置" class="headerlink" title="2. 标签的位置"></a>2. 标签的位置</h2><blockquote><p>一般按照惯例js代码的引入应该放在 <head><meta name="generator" content="Hexo 3.8.0"> 之中，但是由于 js 代码在执行的时候页面其他元素将不能被加载这样会导致页面的交互性很差，所以现在一般将js代码放在闭合标签之前，所有页面html 之后，这样可以不会因为js的加载而影响页面的加载。</head></p></blockquote><pre><code>&lt;html&gt;    &lt;head&gt;        &lt;title&gt;demo&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;a.js&quot;&gt;&lt;/script&gt;    &lt;/body&gt;&lt;/html</code></pre><h2 id="3-延迟脚本-defer-async"><a href="#3-延迟脚本-defer-async" class="headerlink" title="3. 延迟脚本 defer async"></a>3. 延迟脚本 defer async</h2><p><strong>defer</strong>： 脚本在执行的时候不会影响页面的构造，因为js的执行会被延迟到页面全部加载之后才运行</p><p><strong>async</strong>： 脚本和页面的加载将同步执行。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><blockquote><p>在页面中使用Javascript有两种方式，一种通过src引入外部脚本，一种是在script标签之间插入js代码。</p></blockquote><p>1、 使用这两种方式都需要把 type 设置 为 text/javascript</p><p>2、 在包含外部js文件的时候，必须将src 设置为指向相应文件的url</p><p>3、 所有 script 代码会按照他们在页面的顺序按序执行，只有之前的被执行完成后续的才会被执行</p><p>4、 浏览器在呈现内容之前，必须先解析html之前的script代码，所以一定要将script代码放在页面的最后</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
      
    
    </summary>
    
      <category term="重学JS系列" scheme="https://jiaopianjun.cc/categories/%E9%87%8D%E5%AD%A6JS%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JavaScript" scheme="https://jiaopianjun.cc/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Node.js EventEmitter 和 Buffer</title>
    <link href="https://jiaopianjun.cc/2019/05/26/Node-js-EventEmitter-%E5%92%8C-Buffer.html"/>
    <id>https://jiaopianjun.cc/2019/05/26/Node-js-EventEmitter-和-Buffer.html</id>
    <published>2019-05-26T11:19:00.000Z</published>
    <updated>2019-05-26T11:20:25.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Node-js-EventEmitter"><a href="#1-Node-js-EventEmitter" class="headerlink" title="1. Node.js EventEmitter"></a>1. Node.js EventEmitter</h1><blockquote><p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。Node.js 中许多对象都会分发事件。一个net.Server对象会在每次有新连接时触发一个事件，而另外一个 fs.readStream对象会在文件被打开的时候触发一个事件，所有的这些产生的事件对象都是 events.EventEmitter的实例。</p></blockquote><h3 id="EventEmitter-类"><a href="#EventEmitter-类" class="headerlink" title="EventEmitter 类"></a>EventEmitter 类</h3><blockquote><p>events 模块只提供了一个对象：events.EventEmitter。events.EventEmitter的核心就是事件触发和事件监听器功能的封装。你可以通过 require(‘events’)来使用该模块，如下：</p></blockquote><pre><code>// 引入 events 模块var events = require(&apos;events&apos;);// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter();</code></pre><p>EventEmitter对象如果在实例化的时候发生错误，将会触发 <strong>error</strong> 事件。当添加新的监听器的时候，newListener事件会被触发，当该监听器被移除的时候，removeListener 将会被触发。</p><pre><code>案例：//event.js 文件var EventEmitter = require(&apos;events&apos;).EventEmitter; var event = new EventEmitter(); event.on(&apos;some_event&apos;, function() {     console.log(&apos;1s后 some_event 事件触发&apos;); }); setTimeout(function() {     event.emit(&apos;some_event&apos;); }, 1000); // node event.js// 1s 后执行 </code></pre><p>EventEmitter 的每个事件由一个 <strong>事件名</strong> 和 若干个 <strong>参数</strong> 组成，事件名是一个字符串，通常表达一个的意思，对于每个事件，EventEmitter支持多个事件监听器。当事件触发的时候，注册到这个事件上的事件监听器将依次被调用，事件参数作为回调函数参数传递。如下：</p><pre><code> // event.js 文件var events = require(&apos;events&apos;); var emitter = new events.EventEmitter(); emitter.on(&apos;someEvent&apos;, function(arg1, arg2) {     console.log(&apos;listener1&apos;, arg1, arg2); }); emitter.on(&apos;someEvent&apos;, function(arg1, arg2) { console.log(&apos;listener2&apos;, arg1, arg2); }); emitter.emit(&apos;someEvent&apos;, &apos;arg1 参数&apos;, &apos;arg2 参数&apos;); // node event.jslistener1 arg1 参数 arg2 参数listener2 arg1 参数 arg2 参数</code></pre><p>在上面例子中，emitter为事件someEvent注册了两个事件监听器，然后触发了someEvent事件，从运行结果中可以看到 两个事件监听器的回调函数 先后被调用。</p><p>EventEmitter提供了多个属性，如 on 和 emit  。 on 函数用来绑定事件函数，emit 用来触发一个事件，具体参数如下：</p><table><thead><tr><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>addListener(event, listener)</td><td><strong>为指定事件添加一个监听器到监听器数组的尾部</strong></td></tr><tr><td>on(event, listener)</td><td><strong>为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数</strong></td></tr><tr><td>once(event, listener)</td><td><strong>为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器</strong></td></tr><tr><td>removeListener(event, listener)</td><td><strong>移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称</strong></td></tr><tr><td>removeAllListeners([event])</td><td><strong>移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器</strong></td></tr><tr><td>setMaxListeners(n)</td><td><strong>用于提高监听器的默认限制的数量</strong></td></tr><tr><td>listeners(event)</td><td><strong>返回指定事件的监听器数组</strong></td></tr><tr><td>emit(event, [arg1], [arg2], […])</td><td><strong>按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false</strong></td></tr><tr><td>listenerCount(emitter, event)</td><td><strong>返回指定事件的监听器数量</strong></td></tr><tr><td>newListener</td><td><strong>该事件在添加新监听器时被触发</strong></td></tr><tr><td>removeListener</td><td><strong>当指定监听器被删除的时候触发，注意：该触发器之后的监听器</strong></td></tr></tbody></table><p>实例：</p><pre><code>var events = require(&apos;events&apos;);var eventEmitter = new events.EventEmitter();// 监听器 #1var listener1 = function listener1() {   console.log(&apos;监听器 listener1 执行。&apos;);}// 监听器 #2var listener2 = function listener2() {  console.log(&apos;监听器 listener2 执行。&apos;);}// 绑定 connection 事件，处理函数为 listener1 eventEmitter.addListener(&apos;connection&apos;, listener1);// 绑定 connection 事件，处理函数为 listener2eventEmitter.on(&apos;connection&apos;, listener2);var eventListeners = eventEmitter.listenerCount(&apos;connection&apos;);console.log(eventListeners + &quot; 个监听器监听连接事件。&quot;);// 处理 connection 事件 eventEmitter.emit(&apos;connection&apos;);// 移除监绑定的 listener1 函数eventEmitter.removeListener(&apos;connection&apos;, listener1);console.log(&quot;listener1 不再受监听。&quot;);// 触发连接事件eventEmitter.emit(&apos;connection&apos;);eventListeners = eventEmitter.listenerCount(&apos;connection&apos;);console.log(eventListeners + &quot; 个监听器监听连接事件。&quot;);console.log(&quot;程序执行完毕。&quot;);// 执行结果：$ node main.js2 个监听器监听连接事件。监听器 listener1 执行。监听器 listener2 执行。listener1 不再受监听。监听器 listener2 执行。1 个监听器监听连接事件。程序执行完毕</code></pre><h2 id="error-事件"><a href="#error-事件" class="headerlink" title="error 事件"></a>error 事件</h2><blockquote><p>  执行error事件，当error被触发的时候，EventEmitter 规定如果没有响应的监听器，那么node.js就将它当作异常，退出程序并输出错误信息。所以我们要为error设置监听器，避免因为错误导致程序崩溃。如下：</p></blockquote><pre><code>var events = require(&apos;events&apos;); var emitter = new events.EventEmitter(); emitter.emit(&apos;error&apos;); </code></pre><h2 id="继承-EventEmitter"><a href="#继承-EventEmitter" class="headerlink" title="继承 EventEmitter"></a>继承 EventEmitter</h2><blockquote><p>大多数时候不会在node中直接使用EventEmitter，而是在对象中继承去使用它，例如 fs、net、http等，只要是支持事件响应的核心模块都是EventEmitter的子类这样做的原因有两点，如下：</p></blockquote><p><strong>1、具有某个实体功能的对象实现事件符合语义，事件的监听和发生应该是一个对象的方法</strong></p><p><strong>2、另外，因为JavaScript的对象机制是基于原型的，支持部分多重继承，继承EventEmitter不会打乱对象原有的继承关系</strong></p><h1 id="2-Node-js-Buffer-缓冲区"><a href="#2-Node-js-Buffer-缓冲区" class="headerlink" title="2. Node.js Buffer(缓冲区)"></a>2. Node.js Buffer(缓冲区)</h1><blockquote><p>因为JavaScript只有字符串数据类型没有二进制数据类型。但是在处理TCP流或文件流时，必须使用二进制数据。所以在node.js定义了一个Buffer类，该类用来创建一个专门存放二进制数据的缓存区。</p></blockquote><p>在node.js中,Buffer类是随Node内核一起发布的核心库，Buffer库可以让nodejs处理二进制数据，一个Buffer类似一个整数数组。</p><h2 id="Buffer与字符编码"><a href="#Buffer与字符编码" class="headerlink" title="Buffer与字符编码"></a>Buffer与字符编码</h2><blockquote><p>Buffer实例一般用于表示编码字符的序列，比如 UTF-8, Base64, 或十六进制编码的数据，通过使用显示的字符编码，就可以在Buffer实例与普通的JavaScript字符串之间进行相互转换。如下：</p></blockquote><pre><code>const buf = Buffer.from(&apos;runoob&apos;, &apos;ascii&apos;);// 输出 72756e6f6f62console.log(buf.toString(&apos;hex&apos;));// 输出 cnVub29iconsole.log(buf.toString(&apos;base64&apos;));</code></pre><p>nodejs支持的字符编码：</p><pre><code>ascii -- 仅支持7位ASCII数据utf8 -- 多字节编码的Unicode字符utf16le -- 2 或 4 个字节ucs2base64latin1binaryhex</code></pre><h2 id="创建-Buffer类"><a href="#创建-Buffer类" class="headerlink" title="创建 Buffer类"></a>创建 Buffer类</h2><blockquote><p>Buffer提供下面多个api来创建Buffer类</p></blockquote><table><thead><tr><th>Api类名</th><th>说明</th></tr></thead><tbody><tr><td>Buffer.alloc(size[, fill[, encoding]])</td><td>返回一个指定大小的 Buffer 实例</td></tr><tr><td>Buffer.allocUnsafe(size)</td><td>返回一个指定大小的 Buffer 实例</td></tr><tr><td>Buffer.allocUnsafeSlow(size)</td><td></td></tr><tr><td>Buffer.from(array)</td><td>返回一个被 array 的值初始化的新的 Buffer 实例</td></tr><tr><td>Buffer.from(arrayBuffer[, byteOffset[, length]])</td><td>返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer</td></tr><tr><td>Buffer.from(buffer)</td><td>复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例</td></tr><tr><td>Buffer.from(string[, encoding])</td><td>返回一个被 string 的值初始化的新的 Buffer 实例</td></tr></tbody></table><p><em>案例：</em></p><pre><code>// 创建一个长度为 10、且用 0 填充的 Buffer。const buf1 = Buffer.alloc(10);// 创建一个长度为 10、且用 0x1 填充的 Buffer。 const buf2 = Buffer.alloc(10, 1);// 创建一个长度为 10、且未初始化的 Buffer。// 这个方法比调用 Buffer.alloc() 更快，// 但返回的 Buffer 实例可能包含旧数据，// 因此需要使用 fill() 或 write() 重写。const buf3 = Buffer.allocUnsafe(10);// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。const buf4 = Buffer.from([1, 2, 3]);// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。const buf5 = Buffer.from(&apos;tést&apos;);// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。const buf6 = Buffer.from(&apos;tést&apos;, &apos;latin1&apos;);</code></pre><h2 id="写入缓冲区"><a href="#写入缓冲区" class="headerlink" title="写入缓冲区"></a>写入缓冲区</h2><p><strong>语法：</strong></p><p>写入node缓冲区的语法如下：</p><blockquote><p>bur.write(string[, offset[, length]][, encoding])</p></blockquote><p><strong>参数：</strong></p><pre><code>string - 写入缓冲区的字符串offset - 缓冲区开始写入的索引值，默认为0length - 写入的字节数，默认为buffer.lengthencoding - 使用的编码，默认 ‘utf8’</code></pre><blockquote><p>根据encoding的字符编码写入 string 到 buf中 offset位置，length参数是写入的字节数，如果buf没有足够的空间保存整个字符串，那么只会写入string的一部分，只部分解码的字符不会被写入。</p></blockquote><p><strong>返回值：</strong><br>返回值实际写入的大小，如果buffer空间不足，则只会写入部分字符串</p><p><strong>实例</strong></p><pre><code>buf = Buffer.alloc(256);len = buf.write(&quot;www.runoob.com&quot;);console.log(&quot;写入字节数 : &quot;+  len);// 结果$node main.js写入字节数 : 14</code></pre><h2 id="从缓冲区读取数据"><a href="#从缓冲区读取数据" class="headerlink" title="从缓冲区读取数据"></a>从缓冲区读取数据</h2><p><strong>语法：</strong></p><blockquote><p>buf.toString([encoding[, start[, end]]])</p></blockquote><p><strong>参数：</strong></p><pre><code>encoding - 使用的编码start - 指定开始读取的索引位置end - 结束位置，默认为缓冲区的末尾</code></pre><p><strong>返回值：</strong><br>解码缓冲区数据并使用指定的编码返回字符串</p><p><strong>实例：</strong></p><pre><code>buf = Buffer.alloc(26);for (var i = 0 ; i &lt; 26 ; i++) {  buf[i] = i + 97;}console.log( buf.toString(&apos;ascii&apos;));       // 输出: abcdefghijklmnopqrstuvwxyzconsole.log( buf.toString(&apos;ascii&apos;,0,5));   // 输出: abcdeconsole.log( buf.toString(&apos;utf8&apos;,0,5));    // 输出: abcdeconsole.log( buf.toString(undefined,0,5)); // 使用 &apos;utf8&apos; 编码, 并输出: abcde// 结果$ node main.jsabcdefghijklmnopqrstuvwxyzabcdeabcdeabcde</code></pre><h2 id="将-Buffer-转换为-JSON对象"><a href="#将-Buffer-转换为-JSON对象" class="headerlink" title="将 Buffer 转换为 JSON对象"></a>将 Buffer 转换为 JSON对象</h2><p><strong>语法：</strong></p><blockquote><p>buf.toJSON()</p></blockquote><p>注意：当字符串化一个 Buffer 实例时，JSON.stringify()会隐式地调用该toJSON()</p><p><strong>返回值：</strong><br>返回JSON对象</p><p><strong>实例：</strong></p><pre><code>const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);const json = JSON.stringify(buf);// 输出: {&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]}console.log(json);const copy = JSON.parse(json, (key, value) =&gt; {  return value &amp;&amp; value.type === &apos;Buffer&apos; ?    Buffer.from(value.data) :    value;});// 输出: &lt;Buffer 01 02 03 04 05&gt;console.log(copy);// 结果{&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]}&lt;Buffer 01 02 03 04 05&gt;</code></pre><h2 id="缓冲区合并"><a href="#缓冲区合并" class="headerlink" title="缓冲区合并"></a>缓冲区合并</h2><p><strong>语法：</strong></p><blockquote><p>Buffer.concat(list[, totalLength])</p></blockquote><p><strong>参数：</strong></p><pre><code>list - 用于合并的 Buffer 对象数组列表totalLength - 指定合并后 Buffer 对象的总长度</code></pre><p><strong>返回值</strong>：</p><p>返回一个多个成员合并的新 Buffer 对象。</p><p><strong>实例：</strong></p><pre><code>var buffer1 = Buffer.from((&apos;1&apos;));var buffer2 = Buffer.from((&apos;2&apos;));var buffer3 = Buffer.concat([buffer1,buffer2]);console.log(&quot;gogo 内容: &quot; + buffer3.toString());// 结果gogo 内容: 12</code></pre><h2 id="缓冲区比较"><a href="#缓冲区比较" class="headerlink" title="缓冲区比较"></a>缓冲区比较</h2><p><strong>语法：</strong></p><blockquote><p>buf.compare(otherBuffer)</p></blockquote><p><strong>参数：</strong></p><p>ohterBuffer - 与 buf 对象比较的另外一个 Buffer 对象</p><p><strong>返回值：</strong></p><blockquote><p>返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同</p></blockquote><p><strong>实例：</strong></p><pre><code>var buffer1 = Buffer.from(&apos;ABC&apos;);var buffer2 = Buffer.from(&apos;ABCD&apos;);var result = buffer1.compare(buffer2);if(result &lt; 0) {   console.log(buffer1 + &quot; 在 &quot; + buffer2 + &quot;之前&quot;);}else if(result == 0){   console.log(buffer1 + &quot; 与 &quot; + buffer2 + &quot;相同&quot;);}else {   console.log(buffer1 + &quot; 在 &quot; + buffer2 + &quot;之后&quot;);// 结果ABC在ABCD之前</code></pre><h2 id="拷贝缓冲区"><a href="#拷贝缓冲区" class="headerlink" title="拷贝缓冲区"></a>拷贝缓冲区</h2><p><strong>语法：</strong></p><blockquote><p>buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</p></blockquote><p><strong>参数：</strong></p><pre><code>targetBuffer - 要拷贝的Buffer对象targetStart - 数字，默认 0sourceStart - 数字，默认 0sourceEnd - 数字，默认： buffer.length</code></pre><p><strong>实例：</strong></p><pre><code>var buf1 = Buffer.from(&apos;abcdefghijkl&apos;);var buf2 = Buffer.from(&apos;RUNOOB&apos;);//将 buf2 插入到 buf1 指定位置上buf2.copy(buf1, 2);console.log(buf1.toString());// 结果abRUNOOBijkl</code></pre><h2 id="缓冲区裁剪"><a href="#缓冲区裁剪" class="headerlink" title="缓冲区裁剪"></a>缓冲区裁剪</h2><blockquote><p>buf.slice([start[, end]])</p></blockquote><p><strong>参数：</strong></p><pre><code>start - 数字 可选，默认 0 end - 数字 可选 默认： buffer.length</code></pre><p><strong>返回值：</strong></p><p>返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。</p><p><strong>实例：</strong></p><pre><code>var buffer1 = Buffer.from(&apos;cui&apos;);// 剪切缓冲区var buffer2 = buffer1.slice(0,2);console.log(&quot;buffer2 content: &quot; + buffer2.toString());// 结果buffer2 content: cu</code></pre><h2 id="缓冲区长度"><a href="#缓冲区长度" class="headerlink" title="缓冲区长度"></a>缓冲区长度</h2><p><strong>语法：</strong></p><blockquote><p>buf.length</p></blockquote><p><strong>返回值：</strong><br>返回 Buffer 对象所占据的内存长度</p><p><strong>实例：</strong></p><pre><code>var buffer = Buffer.from(&apos;1&apos;);//  缓冲区长度console.log(&quot;buffer length: &quot; + buffer.length);// 结果buffer length: 1</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Node-js-EventEmitter&quot;&gt;&lt;a href=&quot;#1-Node-js-EventEmitter&quot; class=&quot;headerlink&quot; title=&quot;1. Node.js EventEmitter&quot;&gt;&lt;/a&gt;1. Node.js EventEmi
      
    
    </summary>
    
      <category term="Node系列" scheme="https://jiaopianjun.cc/categories/Node%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="node学习" scheme="https://jiaopianjun.cc/tags/node%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门之对象的新增方法</title>
    <link href="https://jiaopianjun.cc/2019/05/21/ES6%E5%85%A5%E9%97%A8%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95.html"/>
    <id>https://jiaopianjun.cc/2019/05/21/ES6入门之对象的新增方法.html</id>
    <published>2019-05-21T13:16:00.000Z</published>
    <updated>2019-06-11T15:12:00.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Object-is"><a href="#1-Object-is" class="headerlink" title="1. Object.is()"></a>1. Object.is()</h2><blockquote><p>用来解决在ES5中 两种相等运算符的缺点。用来比较两个值是否严格相等，行为和（===）基本一致。</p></blockquote><p>在ES5中判断两个值是否相等，只能用（==）相等运算符和（===）严格相等运算符，但是这两货都有缺点，前者 两边的值都会转换数据类型，后者 NaN不等于自身还有 +0 == -0。</p><pre><code>Object.is(&apos;foo&apos;, &apos;foo&apos;)  // trueObject.is({}, {})  // false// 在 Object.is()+0 === -0  // trueNaN === NaN // falseObject.is(+0, -0)   // falseObject.is(NaN, NaN) // true </code></pre><h2 id="2-Object-assign"><a href="#2-Object-assign" class="headerlink" title="2. Object.assign()"></a>2. Object.assign()</h2><blockquote><p>用于对象的合并，将源对象的所有可枚举属性，复制到目标对象，现在常用来进行浅拷贝。</p></blockquote><pre><code>const t = {a: 1}const s1 = {b: 2}const s2= {c: 3}Object.assign(t, s2, s2)// t  {a:1, b:2, c:3}// 在上面中第一个参数t是目标对象，s1 s2是源对象</code></pre><p>注意：如果目标对象和源对象有同名属性，或者多个同名，那么在后面的属性会将前面的覆盖。</p><pre><code>const t = {a: 1, b: 2}const s1 = {b: 3, c: 4}const s2 = {c: 5}Object.assign(t, s1, s2)t // {a:1, b:3, c:5}</code></pre><blockquote><p>如果Object.assign的参数只有一个，那么就返回该参数，另外如果该参数不是对象，那么Object.assign会将其转为对象在返回</p></blockquote><pre><code>const t = {a: 2}Object.assign(t)t // {a: 2}Object.assigin(2)// &quot;object&quot;</code></pre><blockquote><p>另外由于null 和 undefined 无法转换位对象，那么如果他们作为第一个参数就会报错，如果不是在第一个参数则不会有这个问题</p></blockquote><pre><code>Object.assign(undefined)    // 报错Object.assign(null)     //报错这样就不会报错：如下const t = {a: 2}Object.assign(t, undefined)     // trueObject.assign(t, null)      // true</code></pre><blockquote><p>其他（数值，字符串，布尔值）数值不再第一个也不会报错，但是字符串会以数组的形式被拷入目标对象，两外两个则不会做任何操作。</p></blockquote><pre><code>const a = &apos;abc&apos;const b = trueconst c = 12const o = Object.assign({}, a, b, c)o // {&quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot;}// 因为布尔值number 的原始值都在对象的内部属性[[PrimitiveValue]]上面，这个属性不能别Object.assign拷贝</code></pre><p>Obeject.assign 拷贝的属性是有限制的，只能拷贝源对象的自身属性，也不能拷贝不可枚举的属性，另外 Symbol值的属性也能被拷贝</p><h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><h5 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="1. 浅拷贝"></a>1. 浅拷贝</h5><blockquote><p>Object.assign 实现的是浅拷贝，也就是说如果源对象的某个属性值是对象，那么目标对象拷贝得到的是这个对象的引用</p></blockquote><h5 id="2-同名属性的替换"><a href="#2-同名属性的替换" class="headerlink" title="2. 同名属性的替换"></a>2. 同名属性的替换</h5><blockquote><p>如果遇到同名属性，那Object.assign的处理方法是替换还不是追加</p></blockquote><h5 id="3-数组的处理"><a href="#3-数组的处理" class="headerlink" title="3. 数组的处理"></a>3. 数组的处理</h5><blockquote><p>在处理数组的时候，Object.assign是将其是为对象来处理，如果下标相同则是覆盖而不是追加</p></blockquote><pre><code>Object.assign([1, 2, 3], [4, 5])// [4, 5, 3]</code></pre><h5 id="4-取值函数的处理"><a href="#4-取值函数的处理" class="headerlink" title="4. 取值函数的处理"></a>4. 取值函数的处理</h5><blockquote><p>Object.assign 只能进行值的复制，如果复制的值是一个函数，那么就等函数求值执行完在进行值的复制</p></blockquote><h4 id="常见用途："><a href="#常见用途：" class="headerlink" title="常见用途："></a>常见用途：</h4><pre><code>1. 为对象添加属性2. 为对象添加方法3. 克隆对象4. 合并多个对象5. 为属性指定默认值</code></pre><h2 id="3-Object-getOwnPropertyDescriptors"><a href="#3-Object-getOwnPropertyDescriptors" class="headerlink" title="3. Object.getOwnPropertyDescriptors()"></a>3. Object.getOwnPropertyDescriptors()</h2><blockquote><p>用来返回指定对象所有自身属性（非继承属性）的描述对象</p></blockquote><pre><code>const o = {    left: 123,    top() {        return &apos;new&apos;    }}Object.getOwnPropertyDescriptors(o)// {    left:{        configurable: true        enumerable: true        value: 123        writable: true    },    top: {        configurable: true        enumerable: true        value: ƒ top()        writable: true    }}Object.getOwnPropertyDescriptors() 返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</code></pre><h2 id="4-proto属性，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#4-proto属性，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="4. proto属性，Object.setPrototypeOf()，Object.getPrototypeOf()"></a>4. <strong>proto</strong>属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h2><h3 id="4-1-proto属性"><a href="#4-1-proto属性" class="headerlink" title="4.1.  proto属性"></a>4.1.  <strong>proto</strong>属性</h3><blockquote><p>用来读取或设置当前对象的prototype对象，另外这是一个内部属性。<strong>proto</strong>是调用的 Object.prototype.<strong>proto</strong> 方法</p></blockquote><pre><code>//es5 写法const o = {    method: function() {}}o.__proto__ = someOtherObj//es6 写法var o = Object.create(someOtherObj)o.method = function(){}</code></pre><h3 id="4-2-Object-setPrototypeOf"><a href="#4-2-Object-setPrototypeOf" class="headerlink" title="4.2 Object.setPrototypeOf()"></a>4.2 Object.setPrototypeOf()</h3><blockquote><p>作用和 <strong>proto</strong>相同，用来设置一个对象的prototype对象，返回参数本身</p></blockquote><pre><code>// 格式Object.setPrototypeOf(object, prototype)// 用法const o = Object.setPrototypeOf({}, null)=== 以下写法function setPrototyoeOf(obj, proto) {    obj.__proto__ = proto    return obj}// 例子let proto = {}let o = {    x: 10}Object.setPrototypeOf(o, proto)proto.y = 20proto.z = 40o.x // 10o.y // 20o.z // 40// 上面 将proto设为 o 对象的原型，所以可以从o 中读取proto 的属性</code></pre><p><strong>注意：如果第一参数不是对象，将自动转换为对象，由于返回的还是第一个参数，所以这个操作不会产生任何效果，另外由于 undefined 和 null 无法转换为对象，所以第一个参数如果是这两个则会报错</strong></p><pre><code>Object.setPrototypeOf(1, {}) === 1 // trueObject.setPrototypeOf(&apos;foo&apos;, {}) === &apos;foo&apos; // trueObject.setPrototypeOf(true, {}) === true // trueObject.setPrototypeOf(undefined, {})// TypeError: Object.setPrototypeOf called on null or undefinedObject.setPrototypeOf(null, {})// TypeError: Object.setPrototypeOf called on null or undefined</code></pre><h3 id="4-3-Object-getPrototypeOf"><a href="#4-3-Object-getPrototypeOf" class="headerlink" title="4.3 Object.getPrototypeOf()"></a>4.3 Object.getPrototypeOf()</h3><blockquote><p>用于读取一个对象的原型对象和Object.setPrototypeOf 配套使用。所有的特性也和 上面一样，第一个参数如果不是对象将转换为对象，undefined和null 会报错</p></blockquote><h2 id="5-Object-keys-，Object-values-，Object-entries"><a href="#5-Object-keys-，Object-values-，Object-entries" class="headerlink" title="5. Object.keys()，Object.values()，Object.entries()"></a>5. Object.keys()，Object.values()，Object.entries()</h2><h3 id="5-1-Object-keys"><a href="#5-1-Object-keys" class="headerlink" title="5.1 Object.keys()"></a>5.1 Object.keys()</h3><blockquote><p>用于返回一个数组，成员的参数是对象自身的所有可遍历属性的键名</p></blockquote><pre><code>let obj = {    x: 1,    y: &apos;b&apos;}Object.keys(obj)// [&quot;x&quot;, &quot;y&quot;]</code></pre><h3 id="5-2-Object-values"><a href="#5-2-Object-values" class="headerlink" title="5.2 Object.values()"></a>5.2 Object.values()</h3><blockquote><p>返回值是一个数组，成员是对象自身的（不含继承的）所有可遍历属性的值。Objet.values只返回对象自身的可遍历属性。</p></blockquote><pre><code>let obj = {    x: 1,    y: &apos;b&apos;}Object.keys(obj)// [1, &quot;b&quot;]</code></pre><p>另外Object.values遍历的时候如果遇到属性名为数值的属性，那么将按照数值大小，从小到大遍历，如下：</p><pre><code>const obj = { 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; };Object.values(obj)// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]</code></pre><p>注意：Object.values 会过滤属性名为 Symbol的属性</p><pre><code>Object.values({ [Symbol()]: 123, foo: &apos;abc&apos; });// [&apos;abc&apos;]</code></pre><p>如果Object.values的参数是一个<strong>字符串</strong> 那么将返回字符串拆解的数组</p><pre><code>Object.values(&apos;symbol&apos;)[&quot;s&quot;, &quot;y&quot;, &quot;m&quot;, &quot;b&quot;, &quot;o&quot;, &quot;l&quot;]</code></pre><p>注意： 如果Object.values 的参数为boolean值或者number，那么返回值是一个空数组，</p><pre><code>Object.values(true)[]Object.values(2,null)[]</code></pre><h3 id="5-3-Object-entries"><a href="#5-3-Object-entries" class="headerlink" title="5.3 Object.entries()"></a>5.3 Object.entries()</h3><blockquote><p>返回一个数组，成员是对象自身（不含继承的）所有可遍历属性的键值对数组，同样 Symbol 属性的值会被过滤。</p></blockquote><pre><code>const p = { f: &apos;b&apos;, az: 22 };Object.entries(p)// [ [&quot;f&quot;, &quot;b&quot;], [&quot;az&quot;, 22] ]Object.entries({ [Symbol()]: 456, o: &apos;c&apos; });// [ [ &apos;o&apos;, &apos;c&apos;] ]</code></pre><p>Object.entries 可以用来遍历对象的属性</p><p>Object.entries 将对象转为真正的Map结构</p><pre><code>const obj = { foo: &apos;bar&apos;, baz: 42 };const map = new Map(Object.entries(obj));map // Map { foo: &quot;bar&quot;, baz: 42 }</code></pre><h1 id="6-Object-fromEntries"><a href="#6-Object-fromEntries" class="headerlink" title="6. Object.fromEntries()"></a>6. Object.fromEntries()</h1><blockquote><p>是Object.entries 的逆操作，将一个键值对数组转为对象。主要是将键值对的数据结构还原为对象，适用于将Map结构转为对象</p></blockquote><pre><code>Object.fromEntries([  [&apos;foo&apos;, &apos;bar&apos;],  [&apos;baz&apos;, 42]])// { foo: &quot;bar&quot;, baz: 42 }// 例二 将Map结构转为对象const map = new Map().set(&apos;foo&apos;, true).set(&apos;bar&apos;, false);Object.fromEntries(map)// { foo: true, bar: false }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Object-is&quot;&gt;&lt;a href=&quot;#1-Object-is&quot; class=&quot;headerlink&quot; title=&quot;1. Object.is()&quot;&gt;&lt;/a&gt;1. Object.is()&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;用来解决在ES5中 两种相等运
      
    
    </summary>
    
      <category term="ES6入门系列" scheme="https://jiaopianjun.cc/categories/ES6%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="ECMAScript6" scheme="https://jiaopianjun.cc/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门之对象的扩展</title>
    <link href="https://jiaopianjun.cc/2019/05/15/ES6%E5%85%A5%E9%97%A8%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95.html"/>
    <id>https://jiaopianjun.cc/2019/05/15/ES6入门之对象的扩展.html</id>
    <published>2019-05-15T13:19:00.000Z</published>
    <updated>2019-06-11T15:12:04.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-属性的简洁表示法"><a href="#1-属性的简洁表示法" class="headerlink" title="1. 属性的简洁表示法"></a>1. 属性的简洁表示法</h2><blockquote><p>在ES6中 允许直接写入变量和函数，作为对象的属性和方法，使得代码的书写更为简洁。</p></blockquote><pre><code>const f = &apos;a&apos;const b = {f}b  // {f: &apos;a&apos;}等同于const b = {f: f}</code></pre><p>在ES6中允许在对象内直接写变量，这时候属性名为变量名，属性值就是变量值</p><pre><code>function u(x, y){    return {x, y}}// ====function u(x, y){    return {x: x, y: y }}u(1, 2)   // {x:1, y: 2}或者一下写法：function o() {    const x = 1;    const x = 2;    return {x, y}}o() // {x:1, y:2}</code></pre><h2 id="2-属性名表达式"><a href="#2-属性名表达式" class="headerlink" title="2. 属性名表达式"></a>2. 属性名表达式</h2><blockquote><p>在JavaScript中属性名的表达式的方法有两种，一种 直接用标识符作为属性名，第二种用表达式作为属性名。第二种写的时候表达式要放在方括号之内</p></blockquote><pre><code>//一obj.foo = true//二obj[&apos;a&apos; + &apos;bc&apos;] = 123//三let t = &apos;m&apos;let obj = {    [t]: true,    [&apos;a&apos; + &apos;bc&apos;]: 123}</code></pre><p>表达式还可以用来定义方法名(注意：属性名表达式不能和简洁表示法同时使用)</p><pre><code>let obj = {    [&apos;h&apos; + &apos;ello&apos;]() {        return &apos;hi&apos;    }}obj.hello() // hi</code></pre><p>如果属性名表达式是一个对象，则默认情况下会自动将对象转为字符串[object Object]</p><pre><code>const ka = {a: 1}const kb = {b: 2}const myObj = {    [ka]: &apos;va&apos;,    [kb]: &apos;vc&apos;}myObj // Object {[object Object]: &apos;vc&apos;}</code></pre><h2 id="3-方法的-name-属性"><a href="#3-方法的-name-属性" class="headerlink" title="3. 方法的 name 属性"></a>3. 方法的 name 属性</h2><blockquote><p>函数的name 属性，返回函数名，对象方法也是函数，因此也由name 属性</p></blockquote><pre><code>const p = {    n() {        console.log(&apos;h&apos;)    }}p.n.name // n</code></pre><p>特殊情况  getter 和 setter  属性是在 get 和 set上面</p><pre><code>const obj = {    get foo() {},    set fod() {}}obj.foo.name // undefinedconst d = Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;)d.get.name // get food.set.name // set fod</code></pre><p>特殊情况 bind创造的函数  name 属性返回  bound 加上原有函数的名字</p><pre><code>var do = function(){}do.bind().name // bound do</code></pre><p>特殊情况 Function构造函数创造的函数，name 返回 anonymous</p><pre><code>(new Function()).name // anonymous</code></pre><p>如果对象的方法是一个Symbol  那么name  返回这个 Symbol的描述</p><pre><code>const k = Symbol(&apos;描述&apos;)k.name // &quot;[描述]&quot;</code></pre><h2 id="4-属性的可枚举性和遍历"><a href="#4-属性的可枚举性和遍历" class="headerlink" title="4. 属性的可枚举性和遍历"></a>4. 属性的可枚举性和遍历</h2><h4 id="可枚举性"><a href="#可枚举性" class="headerlink" title="可枚举性"></a>可枚举性</h4><blockquote><p>对象的每个属性都有一个描述对象，用来控制该属性的行为，Object.getOwnPropertyDescriptor 方法可以获取该属性的描述对象</p></blockquote><pre><code>let obj = {f: 234}Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;)//  {//    value: 234,//    writable: true,//    enumerable: true,//    configurable: true//  }</code></pre><p>描述对象的 enumerable 属性，称为 “可枚举性”，如果该属性为true就表示某些操作会忽略当前操作</p><pre><code>有四个操作会忽略 enumerate 为 false 的属性- for...in循环： 只遍历对象自身和继承的可枚举的属性- Object.keys()：返回对象自身的所有可枚举的属性的键名- JSON.stringify(): 只串行化对象自身的可枚举的属性- Object.assign(): 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性</code></pre><p>ES6中 所有class 的原型的方法都是不可枚举的</p><h4 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h4><blockquote><p>ES6一共有5种方法可以遍历对象的属性。</p></blockquote><pre><code>（1）for...infor...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。（2）Object.keys(obj)Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。（3）Object.getOwnPropertyNames(obj)Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。（4）Object.getOwnPropertySymbols(obj)Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。（5）Reflect.ownKeys(obj)Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 1）for..in以上五种方法遍历对象的键名，都遵循同样的属性遍历的次序股则    首先遍历所有数值键，按照数值升序排列。    其次遍历所有字符串键，按照加入时间升序排列。    最后遍历所有 Symbol 键，按照加入时间升序排列。</code></pre><h2 id="5-super关键字"><a href="#5-super关键字" class="headerlink" title="5. super关键字"></a>5. super关键字</h2><blockquote><p>this的关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字 super，指向当前对象的原型对象</p></blockquote><p>注意：super关键字表示原型对象时，只能用在对象的方法之中，用在其他他地方都会报错。</p><pre><code>// 报错const obj = {  foo: super.foo}// 报错const obj = {  foo: () =&gt; super.foo}// 报错const obj = {  foo: function () {    return super.foo  }}</code></pre><p>上面三种super的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是super用在属性里面，第二种和第三种写法是super用在一个函数里面，然后赋值给foo属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-属性的简洁表示法&quot;&gt;&lt;a href=&quot;#1-属性的简洁表示法&quot; class=&quot;headerlink&quot; title=&quot;1. 属性的简洁表示法&quot;&gt;&lt;/a&gt;1. 属性的简洁表示法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在ES6中 允许直接写入变量和函数，作为对象的
      
    
    </summary>
    
      <category term="ES6入门系列" scheme="https://jiaopianjun.cc/categories/ES6%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="ECMAScript6" scheme="https://jiaopianjun.cc/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 回调函数和事件循环</title>
    <link href="https://jiaopianjun.cc/2019/05/14/Node.js%20%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html"/>
    <id>https://jiaopianjun.cc/2019/05/14/Node.js 回调函数和事件循环.html</id>
    <published>2019-05-14T13:33:00.000Z</published>
    <updated>2019-06-11T15:00:01.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-node-js-回调函数"><a href="#1-node-js-回调函数" class="headerlink" title="1. node.js 回调函数"></a>1. node.js 回调函数</h1><blockquote><p>node.js 的异步编程思想最直接的体现就是回调，在node中大量使用了回调函数，所有的API都支持回调函数，回调函数一般作为最后一个参数出现，正因为这样node在执行代码的时候就没有阻塞或者等待的操作，提高了node的性能，可以处理大量的并发请求。</p></blockquote><pre><code>function f1(name, age, callback){}function f2(name, callback, callback2){}</code></pre><h3 id="阻塞代码实例"><a href="#阻塞代码实例" class="headerlink" title="阻塞代码实例"></a>阻塞代码实例</h3><p>创建一个文件input.txt内容如下：</p><blockquote><p>这是一个阻塞代码的实例</p></blockquote><p>创建 node.js：</p><pre><code>var  fs = require(&apos;fs&apos;);var  data = fs.readFileSync(&apos;input.txt&apos;)console.log(data.toString())console.log(&apos;程序执行结束！&apos;)</code></pre><p>结果如下：</p><pre><code>这是一个阻塞代码的实例程序执行结束！</code></pre><blockquote><p>如上：阻塞代码就是需要等待前面的代码执行完成后才能继续往后执行。</p></blockquote><h3 id="非阻塞代码实例"><a href="#非阻塞代码实例" class="headerlink" title="非阻塞代码实例"></a>非阻塞代码实例</h3><p>创建一个文件input.txt内容如下：</p><blockquote><p>这是一个非阻塞代码的实例</p></blockquote><p>创建 node.js：</p><pre><code>var fs = require(&apos;fs&apos;)fs.readFile(&apos;input.txt&apos;, function(err, data){    if (err) return console.log(err)    console.log(data.toString())})console.log(&apos;over&apos;)</code></pre><p>结果如下：</p><pre><code>over这是一个阻塞代码的实例</code></pre><blockquote><p>如上，就是程序不必等到读取操作而直接执行后面的代码，等到读取完成后在执行读取文档的相关操作。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>阻塞是按顺序执行的，而非阻塞是不需要按照顺序的，需要处理的事件就写在回调函数之内即可。</p></blockquote><h1 id="node-js-事件循环"><a href="#node-js-事件循环" class="headerlink" title="node.js 事件循环"></a>node.js 事件循环</h1><blockquote><p>node.js 是单进程单线程应用程序，但是因为V8引擎提供的异步执行回调接口，通过这些接口可以处理大量并发，所以性能非常高，在nodejs中所有的事件机制都是用设计模式中观察者模式实现</p></blockquote><blockquote><p>node.js 单线程进入一个 while 的事件循环，知道没有事件观察者退出，每个异步事件都生成一个事件观察者，如果事件发生就调用该回调函数 </p></blockquote><h3 id="node-js-事件驱动程序"><a href="#node-js-事件驱动程序" class="headerlink" title="node.js 事件驱动程序"></a>node.js 事件驱动程序</h3><blockquote><p>node.js 使用事件驱动模型，当web server 接受到请求，就把它关闭然后处理，在去处理下一个web请求。当这个请求完成后，它会被放回到处理队列的开头，并将这个结果返回给用户。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/5/14/16ab5cd2e93c2663?w=769&amp;h=231&amp;f=png&amp;s=66390" alt></p><blockquote><p>node.js 的事件驱动扩展性非常强，因为web server一直在接受请求，而不进行任何等待操作，效率非常的高。整个流程类型观察者模式，事件相当于一个主题，所有注册到这个事件上的处理函数相当于观察者。</p></blockquote><h4 id="内置实例"><a href="#内置实例" class="headerlink" title="内置实例"></a>内置实例</h4><pre><code>// 引入 events 模块var events = require(&apos;events&apos;);// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter();</code></pre><p>绑定事件：</p><pre><code>// 绑定事件及事件的处理程序eventEmitter.on(&apos;eventName&apos;, eventHandler);</code></pre><p>触发事件：</p><pre><code>// 触发事件eventEmitter.emit(&apos;eventName&apos;);</code></pre><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre><code>// 引入 events 模块var events = require(&apos;events&apos;);// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter();// 创建事件处理程序var connectHandler = function connected() {   console.log(&apos;连接成功。&apos;);   // 触发 data_received 事件    eventEmitter.emit(&apos;data_received&apos;);}// 绑定 connection 事件处理程序eventEmitter.on(&apos;connection&apos;, connectHandler);// 使用匿名函数绑定 data_received 事件eventEmitter.on(&apos;data_received&apos;, function(){   console.log(&apos;数据接收成功。&apos;);});// 触发 connection 事件 eventEmitter.emit(&apos;connection&apos;);console.log(&quot;程序执行完毕。&quot;);</code></pre><p>执行结果：</p><pre><code>连接成功数据接受成功程序执行完毕</code></pre><h4 id="node-应用程序如何工作"><a href="#node-应用程序如何工作" class="headerlink" title="node 应用程序如何工作"></a>node 应用程序如何工作</h4><blockquote><p>在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。</p></blockquote><p>具体案例可以看上文的 <strong>非阻塞代码的实例</strong>：</p><pre><code>正常执行结果就如上</code></pre><blockquote><p>如果把input.txt删除，那么就导致程序读取错误，就会走到代码的 err部分，就会出现如下结果：</p></blockquote><pre><code>overError: ENOENT, open &apos;input.txt&apos;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-node-js-回调函数&quot;&gt;&lt;a href=&quot;#1-node-js-回调函数&quot; class=&quot;headerlink&quot; title=&quot;1. node.js 回调函数&quot;&gt;&lt;/a&gt;1. node.js 回调函数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;node.js
      
    
    </summary>
    
      <category term="Node系列" scheme="https://jiaopianjun.cc/categories/Node%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="node学习" scheme="https://jiaopianjun.cc/tags/node%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>重学JavaScript之DOM级别</title>
    <link href="https://jiaopianjun.cc/2019/05/09/%E9%87%8D%E5%AD%A6JavaScript%E4%B9%8BDOM%E7%BA%A7%E5%88%AB.html"/>
    <id>https://jiaopianjun.cc/2019/05/09/重学JavaScript之DOM级别.html</id>
    <published>2019-05-09T13:32:00.000Z</published>
    <updated>2019-06-11T14:57:49.532Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JavaScript是一种专门为网页交互而设计的脚本语言，主要由三个不同的部分组成。</p></blockquote><h2 id="1-ECMAScript"><a href="#1-ECMAScript" class="headerlink" title="1. ECMAScript"></a>1. ECMAScript</h2><p>由ECMA-262 定义，提供核心语言功能</p><h2 id="2-文档对象模型DOM（提供访问和操作网页内容的方法和接口）"><a href="#2-文档对象模型DOM（提供访问和操作网页内容的方法和接口）" class="headerlink" title="2. 文档对象模型DOM（提供访问和操作网页内容的方法和接口）"></a>2. 文档对象模型DOM（提供访问和操作网页内容的方法和接口）</h2><blockquote><p>DOM 是针对于XML和已经扩展用于HTML的应用程序，DOM把整个页面映射为一个多层节点结构，这些节点又包含不同类型的数据，通过DOM的创建，我们可以获得页面的控制权，删除、添加、替换任何节点。</p></blockquote><h3 id="2-1-DOM级别"><a href="#2-1-DOM级别" class="headerlink" title="2.1 DOM级别"></a>2.1 DOM级别</h3><h5 id="2-1-1-DOM1"><a href="#2-1-1-DOM1" class="headerlink" title="2.1.1  DOM1"></a>2.1.1  DOM1</h5><p>由DOM核心和DOM HTML组成， DOM核心规定如何映射基于XML的文档结构，DOM HTML 则在DOM核心的基础上加以扩展，添加针对HTML的对象和方法。</p><h5 id="2-1-2-DOM2"><a href="#2-1-2-DOM2" class="headerlink" title="2.1.2  DOM2"></a>2.1.2  DOM2</h5><p>DOM2在DOM1的基础上增加了 DOM视图、事件、样式、遍历和范围等功能</p><h5 id="2-1-3-DOM3"><a href="#2-1-3-DOM3" class="headerlink" title="2.1.3  DOM3"></a>2.1.3  DOM3</h5><p>DOM3在DOM2的基础上进一步的引入了统一方式加载和文档保存的方法</p><h2 id="3-浏览器对象模型（BOM）"><a href="#3-浏览器对象模型（BOM）" class="headerlink" title="3. 浏览器对象模型（BOM）"></a>3. 浏览器对象模型（BOM）</h2><blockquote><p>BOM 只处理浏览器窗口和框架，提供浏览器交互和方法，以及如下功能：</p></blockquote><ul><li>弹窗新浏览器窗口的功能</li><li>移动、缩放和关闭浏览器窗口的功能</li><li>提供浏览器详细信息的navigator对象</li><li>提供浏览器加载页面信息的对象 location</li><li>提供 显示器分辨率属性 screen</li><li>对 cookie 支持</li><li>对 XMLHttpRequest 和 IE 的 ActiveXObject 自定义对象</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;JavaScript是一种专门为网页交互而设计的脚本语言，主要由三个不同的部分组成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-ECMAScript&quot;&gt;&lt;a href=&quot;#1-ECMAScript&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="重学JS系列" scheme="https://jiaopianjun.cc/categories/%E9%87%8D%E5%AD%A6JS%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JavaScript" scheme="https://jiaopianjun.cc/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Flex布局入门</title>
    <link href="https://jiaopianjun.cc/2019/05/09/Flex%E5%B8%83%E5%B1%80%E5%85%A5%E9%97%A8.html"/>
    <id>https://jiaopianjun.cc/2019/05/09/Flex布局入门.html</id>
    <published>2019-05-09T13:31:00.000Z</published>
    <updated>2019-05-21T13:19:30.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-flex-弹性布局"><a href="#1-flex-弹性布局" class="headerlink" title="1. flex (弹性布局)"></a>1. flex (弹性布局)</h2><blockquote><p>主要提供简便、完整、响应式布局解决方法，设置flex布局后元素的 float、clear、vertical-align属性将失效</p></blockquote><h3 id="主要参数："><a href="#主要参数：" class="headerlink" title="主要参数："></a>主要参数：</h3><ul><li><p>flex-direaction</p><ul><li><p>决定主轴的方向</p><pre><code>- 参数：    - row(默认值):      主轴为水平方向，起点在左端    - row-reverse：     同上，起点在右端    - column：          主轴为垂直方向，起点在上方    - column-reverse：  同上，起点在下方</code></pre></li></ul></li><li><p>flex-wrap</p><ul><li><p>如果默认轴线排序不下，则换行</p><pre><code>- 参数：    - nowrap(默认):     不换行    - wrap：            换行，第一行在上方    - wrap-reverse：    换行，第一行在下方</code></pre></li></ul></li><li><p>flex-flow</p><ul><li>是flex-direaction 和 flex-wrap的简写</li></ul></li><li><p>justify-content</p><ul><li><p>在主轴（水平）上的对齐方式</p><pre><code>- 参数：    - flex-start(默认值): 左对齐    - flex-end：          右对齐    - center：            居中    - space-between：     两端对齐，项目之间间隔相等    - space-around：      项目两侧有间隔，类似margin后的效果</code></pre></li></ul></li><li><p>align-items   </p><ul><li><p>定义项目交叉（垂直）轴上如何对齐</p><pre><code>- 参数：    - flex-start:       起点对齐    - flex-end:         重点对齐    - center:           重点对齐    - baseline:         第一行文字的基线对齐    - stretch:          如果项目未设置高度或者auto，将占满整个容器</code></pre></li></ul></li><li><p>align-content</p><ul><li><p>多根轴线的对齐方式，单一不起作用</p><pre><code>- 参数：    - flex-start:       交叉轴 起点对齐    - flex-end:         交叉轴 终点对齐    - center:           交叉轴 中点对齐    - space-between:    交叉轴两端对齐，轴线之间平均分布    - sapce-around:     同margin    - stretch:          占满整个交叉轴</code></pre></li></ul></li></ul><h3 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h3><ul><li><p>order</p><pre><code>定义上项目的排列顺序，数值越小，排列越靠前，默认为0</code></pre></li><li><p>flex-grow</p></li><li><pre><code>定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</code></pre></li><li>flex-shrink</li><li><pre><code>定义项目的缩小比例，默认为1，空间不足，该项目将缩小</code></pre></li><li>flex-basis</li><li><pre><code>在分配多余空间之前，先计算是否有多余空间</code></pre></li><li>flex</li><li><pre><code>上面三个的简写</code></pre></li><li>align-self</li><li><pre><code>    允许单个项目和其他项目有不一样的对齐方式，可覆盖align-items属性，默认auto，表示继承父元素的align-items属性，如果没有父元素则等同于stretch</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-flex-弹性布局&quot;&gt;&lt;a href=&quot;#1-flex-弹性布局&quot; class=&quot;headerlink&quot; title=&quot;1. flex (弹性布局)&quot;&gt;&lt;/a&gt;1. flex (弹性布局)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;主要提供简便、完整、响应式布局
      
    
    </summary>
    
      <category term="Coding" scheme="https://jiaopianjun.cc/categories/Coding/"/>
    
    
      <category term="css" scheme="https://jiaopianjun.cc/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门之数组的扩展</title>
    <link href="https://jiaopianjun.cc/2019/05/08/ES6%E5%85%A5%E9%97%A8%E4%B9%8B%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95.html"/>
    <id>https://jiaopianjun.cc/2019/05/08/ES6入门之数组的扩展.html</id>
    <published>2019-05-08T08:35:00.000Z</published>
    <updated>2019-06-11T15:12:12.623Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-扩展运算符"><a href="#1-扩展运算符" class="headerlink" title="1. 扩展运算符"></a>1. 扩展运算符</h3><blockquote><p>…表示，将一个数组转为用逗号分隔的参数序列，如下：</p></blockquote><pre><code>console.log(...[1,2,3]) // 1 2 3console.log(1, ...[2,3,4], 5) // 1 2 3 4 5[...document.querySelectorAll(&apos;div&apos;)] // [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]function add(x, y){    return x + y}const n = [3, 5]add(...n) // 8</code></pre><h6 id="扩展运算符可以和正常函数结合使用，如下："><a href="#扩展运算符可以和正常函数结合使用，如下：" class="headerlink" title="扩展运算符可以和正常函数结合使用，如下："></a>扩展运算符可以和正常函数结合使用，如下：</h6><pre><code>function f(a,b,c,d,e){    console.log(a,b,c,d,e)}const age = [0,1]f(-1,...age,2,...[3]) // -1 0 1 2 3</code></pre><h6 id="扩展运算符后面也可以是表达式，如下："><a href="#扩展运算符后面也可以是表达式，如下：" class="headerlink" title="扩展运算符后面也可以是表达式，如下："></a>扩展运算符后面也可以是表达式，如下：</h6><pre><code>const x = 10const arr = [    ...(x &gt; 0 ? [&apos;a&apos;] : []), &apos;b&apos;,]arr // [&apos;a&apos;, &apos;b&apos;]</code></pre><h6 id="重要：如果扩展运算符后面是一个空数组，将不会有任何效果。另外只有在函数调用的时候扩展函数在放在圆括号之内，其他的则会报错。"><a href="#重要：如果扩展运算符后面是一个空数组，将不会有任何效果。另外只有在函数调用的时候扩展函数在放在圆括号之内，其他的则会报错。" class="headerlink" title="重要：如果扩展运算符后面是一个空数组，将不会有任何效果。另外只有在函数调用的时候扩展函数在放在圆括号之内，其他的则会报错。"></a>重要：如果扩展运算符后面是一个空数组，将不会有任何效果。另外只有在函数调用的时候扩展函数在放在圆括号之内，其他的则会报错。</h6><h6 id="替代函数的apply方法"><a href="#替代函数的apply方法" class="headerlink" title="替代函数的apply方法"></a>替代函数的apply方法</h6><blockquote><p>扩展函数可以展开数组，所以将不需要apply方法来将数组转换为函数的参数。</p></blockquote><pre><code>function f(x, y, z){    console.log(x, y, z)}var a = [1,2,4]// ES5 f.apply(null, args)// ES6f(...a)// Math.max方法//ES5Math.max.apply(null, [14, 3, 99])//ES6Math.max(...[12, 4, 55])//等同于Math.max(12, 4, 55)// push方法的应用var a = [0,1,2]var b = [3,4,5]//ES5Array.prototype.push.apply(a,b) // 0,1,2,3,4,5//ES6a.push(...b)</code></pre><h6 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h6><ol><li><p>复制数组</p><pre><code>因为数组是复合的数据类型，直接的复制只是复制数组在堆内存中的指针地址const a1 = [1,2]const a2 = a1a2[0] = 3a1 // [3,2]// ES5 通过变通方法来复制const a1 = [1,2]const a2 = a1.concat()a2[0] = 23a1 // [1,2]// ES6写法const b1 = [1,3]const b2 = [...b1] or [...b2] = b1</code></pre></li><li><p>合并数组</p><pre><code>const a1 = [&apos;b&apos;, &apos;c&apos;]const a2 = [&apos;d&apos;]const a3 = [&apos;x&apos;, &apos;y&apos;]// ES5中合并数组a1.concat(a2, a3)// ES6中合并数组[...a1, ...a2, ...a3]//以上两种都是浅拷贝，修改原数组和同步新数组</code></pre></li><li><p>与解构赋值一起使用,扩展只能放在最后一位，不然会报错</p><pre><code>// ES5a = list[0], rest = list.slice(1)// ES6[a,...rest] = list// 其他const [a,...c] = [1,2,4,5,4,6] // a 1   c 2,4,5,4,6const [a,...c] = [] // a undefined   c []const [a,...c] = [&apos;a&apos;] // a &apos;a&apos;   c []  </code></pre></li><li><p>字符串，将字符串转换为数组</p><pre><code>[...&apos;hello&apos;] // [h,e,l,l,0]</code></pre></li><li><p>实现了Iterator接口的对象</p><pre><code>任何定义了遍历器接口对象，都可以用扩展运算符转为真正的数组let nodelist = document.querySelectorAll(&apos;div&apos;)let array = [...nodelist]// querySelectorAll 返回的是一个类数组，通过扩展运算符将其转换为一个真正的数组</code></pre></li><li><p>Map 和 Set 解构，Generator函数</p><pre><code>扩展运算符调用的是数据解构的Iterator接口，只要有Iterator接口的对象，都可以使用扩展运算符// Maplet map = new Map([    [1, &apos;a&apos;],    [2, &apos;b&apos;],    [3, &apos;c&apos;],])let arr = [...map.keys()] // 1, 2, 3let arr = [...map.values()] // &apos;a&apos;, &apos;b&apos;, &apos;c&apos;//Generator函数const go = function*(){    yield 1;    yield 2;    yield 3;}[...go()] // [1, 2, 3]</code></pre></li></ol><h3 id="2-Array-from"><a href="#2-Array-from" class="headerlink" title="2. Array.from()"></a>2. Array.from()</h3><blockquote><p>Array.from 方法用于将两类对象转为真正的数组。1、类似数组对象 和 可遍历的对象（包裹Set和Map），如下：</p></blockquote><pre><code>let arrLike = {    &apos;0&apos;: &apos;a&apos;,    &apos;1&apos;: &apos;b&apos;,    &apos;2&apos;: &apos;c&apos;,    length: 3}// ES5 var a1 = [].slice.call(arrLike)// ES6var a2 = Array.from(arrLike)</code></pre><p>在实际中，像获取dom后返回的Nodelist集合，以及函数内部的arguments对象就是类数组，通过 Array.from将它们转换为真正的数组。</p><pre><code>// NodeList 对象let ps = document.querySelectorAll(&apos;p&apos;)Array.from(ps).filter(p =&gt; {    return p.textContent.length &gt; 100})// arguments 对象function foo(){    var arg = Array.from(arguments)}// 只要部署了Iterator接口的数据解构，Array.from都能将其转成数组Array.from(&apos;hello&apos;) // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]let nl = new Set([1, 2])Array.from(nl) // [1, 2]// 如果是真数组则返回一样的Array.from([1, 2, 3]) // [1, 2, 3]</code></pre><blockquote><p>… 扩展运算符也可以将某些类数组转换为数组，如arguments和NodeList集合</p></blockquote><blockquote><p>拥有lenght属性的对象都可以通过Array.from转换为数组，而扩展运算符则不行。</p></blockquote><pre><code>Array.from({lenght:3}) // [undefined, undefined, undefined]</code></pre><blockquote><p>对于低版本的浏览器，可以通过 <strong>Array.prototype.slice</strong> 方法替代</p></blockquote><p><strong>Array.from 还可以接受第二个参数如同map一样，用来对每个元素进行操作，并将处理后的值放入返回的数组中。</strong></p><pre><code>const arrlike = new Set([1,2,3])Array.from(arrlike, x =&gt; x * x)   // =Array.from(arrlike).map(x =&gt; x * x)   // [1, 4, 9]//注意： 如果map中用到了this，可以传入Array.from的第三个参数，用来绑定this</code></pre><p>Array.from 可以将各种值转换为真正的数组，并且还提供map相关功能，这样代表如果有个原始数据结构，可以先将他转换为数组，然后使用数组相关的方法。</p><h3 id="3-Array-of"><a href="#3-Array-of" class="headerlink" title="3. Array.of()"></a>3. Array.of()</h3><blockquote><p>用于将一组值，转换为数组。主要用来弥补Array函数因为参数个数不同而导致的差异</p></blockquote><pre><code>Array.of(3,11,6) // [3, 11, 6]Array.of(3) // [3]Array.of(4).length // 1</code></pre><h3 id="4-数组的实例-copyWithin"><a href="#4-数组的实例-copyWithin" class="headerlink" title="4. 数组的实例 copyWithin()"></a>4. 数组的实例 copyWithin()</h3><blockquote><p>将当前数组中指定位置的元素复制到另外一个位置，并且会覆盖那个位置的原有元素，会修改当前数组  </p></blockquote><pre><code>// 有三个参数1. target(必须)：从该位置开始替换数据，如果是负值，则倒数2. start(可选)：从该位置读取数据，默认0，负值同上3. end(可选)：到这个位置停止读取数据，默认等于数组长度，负值同上let p = [1,2,3,4,5,6,7]p.copyWithin(0,5,7)[6, 7, 3, 4, 5, 6, 7]</code></pre><h3 id="5-数组实例的-find-和-findIndex"><a href="#5-数组实例的-find-和-findIndex" class="headerlink" title="5. 数组实例的 find() 和 findIndex()"></a>5. 数组实例的 find() 和 findIndex()</h3><blockquote><p>find 用来找出数组中符合条件的成员，它的参数是一个回调函数，找到一个返回值为true的返回，如果没有则返回undefined</p></blockquote><pre><code>let s = [1,2,3,4,5,6]s.find(x =&gt; x &gt; 4)// 5find 方法的回调函数有三个参数    value // 当前值    index // 当前的位置    arr // 原数组</code></pre><blockquote><p>findIndex 同find方法类似，只不过都不符合返回的是 -1,而且符合是返回符合条件值的位置而不是值。</p></blockquote><pre><code>let s = [1,2,3,4,5,6]s.find(x =&gt; x &gt; 4)// 4</code></pre><blockquote><p>find 和 findIndex 都可以接受第二个参数</p></blockquote><pre><code>function o(p){    return p &gt; this.age}const u = {name: &apos;cx&apos;, age: 11}const y = [8,11,22,2,4]y.find(o, u) // 22  返回的值y.findIndex(o, u) // 2  返回值的位置</code></pre><h3 id="6-数组实例的-fill"><a href="#6-数组实例的-fill" class="headerlink" title="6. 数组实例的 fill()"></a>6. 数组实例的 fill()</h3><blockquote><p>通过给定值，填充一个数组</p></blockquote><pre><code>let sz = [1,2,3,4,5,6]sz.fill(1) // [1,1,1,1,1,1]sz.fill(1,0,3) // 接受三个参数，第一个为填充值，第二个为起始位置，第三个为截至位置sz.fill(1,3)// 如果省略最后一个参数，则默认从起始位置到数组默认长度结束</code></pre><h3 id="7-数组实例的-entries-keys-values"><a href="#7-数组实例的-entries-keys-values" class="headerlink" title="7. 数组实例的 entries(), keys(), values()"></a>7. 数组实例的 entries(), keys(), values()</h3><blockquote><p>三种方法主要用于遍历数组，可以用 for…of…进行遍历，keys()对应键名，values对应键值,entries()对键值对的遍历</p></blockquote><pre><code>let bo = [&apos;a&apos;, &apos;c&apos;]for(let r of bo.keys()){    console.log(r) // 0 1}// 0 1for(let n of bo.values()){    console.log(n) }// a cfor(let s of bo.entries()){    console.log(s)}// [0, &quot;a&quot;]// [1, &quot;c&quot;]</code></pre><h3 id="8-数组实例的-includes"><a href="#8-数组实例的-includes" class="headerlink" title="8. 数组实例的 includes()"></a>8. 数组实例的 includes()</h3><blockquote><p>用来表示某个数组是否包含给定的值，返回一个布尔值</p></blockquote><pre><code>let i = [&apos;a&apos;,1,2,3]i.includes()  // falsei.includes(1) // truei.includes(10) // false</code></pre><blockquote><p>indexOf 和includes 的区别</p></blockquote><pre><code>indexOf // 不够语义化，它的作用是找到参数出现的第一个位置，所以要比较是否为 -1,另外由于 内部使用的是 ===  则导致NaN的误判。// [NaN].indexOf(NaN) // -1includes // 使用的是不一样的算法，则不会有这个问题// [NaN].includes(NaN) // true</code></pre><blockquote><p>Map 和 Set 的has 方法和includes的区别</p></blockquote><pre><code>Map 的has 方法是用来查找键名的Set 的has 方法是用来查找值的</code></pre><h3 id="9-数组的实例-flat-flatMap"><a href="#9-数组的实例-flat-flatMap" class="headerlink" title="9. 数组的实例 flat(), flatMap()"></a>9. 数组的实例 flat(), flatMap()</h3><blockquote><p>flat() 将嵌套的二维数组变成一维数组，如果需要拉平多维数组，则flat(多维数量) 或者使用 Infinity 直接转为一维数组</p></blockquote><pre><code>let rw = [1,2,3,[4,5,6],7]rw.flat()  // [1, 2, 3, 4, 5, 6, 7]let dw =  [1,2,3,[4,5,6,[7,8],[2,[&apos;a&apos;,&apos;b&apos;],4,5]],[5,6,]]dw.flat(3) // [1, 2, 3, 4, 5, 6, 7, 8, 2, &quot;a&quot;, &quot;b&quot;, 4, 5, 5, 6]// 如果你不知道是多少层嵌套而都想转成一维，可以使用 Infinitydw.flat(Infinity) // [1, 2, 3, 4, 5, 6, 7, 8, 2, &quot;a&quot;, &quot;b&quot;, 4, 5, 5, 6]</code></pre><blockquote><p>flatMap() 对数组执行map，然后对返回值组成的数组 执行flat，不会改变原数组。flatMap只能展开一层数组。</p></blockquote><pre><code>let mp = [2,3,4,5]mp.flatMap((item) =&gt; [item, item* 2])// [2, 4, 3, 6, 4, 8, 5, 10]====mp.map((item) =&gt; [item, item*2])// [[2,4],[3,6],[4,8],[5,10]]mp.flat()// [2, 4, 3, 6, 4, 8, 5, 10]    </code></pre><h3 id="10-数组的空位-避免出现空位"><a href="#10-数组的空位-避免出现空位" class="headerlink" title="10. 数组的空位(避免出现空位)"></a>10. 数组的空位(避免出现空位)</h3><blockquote><p>数组的空位指的是该数组中某一个位置没有任何值。另外空位不是undefined，如果一个位置的值是undefined，那么这个位置还是有值的。</p></blockquote><pre><code>Array(3) // [, , ,]</code></pre><blockquote><p>ES5中大多数情况中对待空位都是会忽略</p></blockquote><pre><code>- forEach(), filter(), reduce(), every() 和 some() 都会跳过空位- map() 跳过但保留这个值- join() 和 toString() 中 空位 === undefined，而 undefined和null会被处理成空字符串</code></pre><blockquote><p>ES6 中 空位则转换为undefined</p></blockquote><pre><code>- Array.from([1,,2]) // [1, undefined, 2]- [...[&apos;a&apos;,,&apos;b&apos;]]    // [ &quot;a&quot;, undefined, &quot;b&quot; ]entries()keys()values()find()findIndex()  // 都会将空位处理成undefined。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-扩展运算符&quot;&gt;&lt;a href=&quot;#1-扩展运算符&quot; class=&quot;headerlink&quot; title=&quot;1. 扩展运算符&quot;&gt;&lt;/a&gt;1. 扩展运算符&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;…表示，将一个数组转为用逗号分隔的参数序列，如下：&lt;/p&gt;
&lt;/blo
      
    
    </summary>
    
      <category term="ES6入门系列" scheme="https://jiaopianjun.cc/categories/ES6%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="ECMAScript6" scheme="https://jiaopianjun.cc/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>重学Javascript之基础知识</title>
    <link href="https://jiaopianjun.cc/2019/05/05/%E9%87%8D%E5%AD%A6JavaScript%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE.html"/>
    <id>https://jiaopianjun.cc/2019/05/05/重学JavaScript之基础数据.html</id>
    <published>2019-05-05T13:32:00.000Z</published>
    <updated>2019-06-11T14:57:39.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-javascript字符串"><a href="#第一章-javascript字符串" class="headerlink" title="第一章 javascript字符串"></a>第一章 javascript字符串</h1><h6 id="1-0、字符串基本数据类型"><a href="#1-0、字符串基本数据类型" class="headerlink" title="1.0、字符串基本数据类型"></a>1.0、字符串基本数据类型</h6><pre><code>1、javascript字符串可以是一个基本数据类型或者一个对象2、与JavaScript中其他四种数据类型并列：数字、布尔、null 和 undefined3、作为基本数据类型，字符串也是JavaScript直接量：这是一个集合，包含数字 数组 对象和正则表达式、数字和布尔值的直接量格式</code></pre><h6 id="1-0、字符串对象"><a href="#1-0、字符串对象" class="headerlink" title="1.0、字符串对象"></a>1.0、字符串对象</h6><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、字符串对象叫做<span class="built_in">string</span>，与其他JavaScript对象一样，它拥有预先构建到对象类型中的一组属性</span><br><span class="line"><span class="number">2</span>、可以使用JavaScript的<span class="literal">new</span>运算符来实例化一个<span class="built_in">string</span>对象，从而创建一个新的对象实例：</span><br><span class="line"></span><br><span class="line">   <span class="built_in">var</span> city = <span class="literal">new</span> <span class="built_in">String</span>(<span class="string">"This is pin"</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、一旦实例化了，可用的字符串属性的任何一个，都可以通过字符串进行访问，例如：</span><br><span class="line"></span><br><span class="line">   <span class="built_in">var</span> lcCity = city.toLowerCase(); <span class="comment">// 将字符串中的大写字母转换成小写   结果：this is pin</span></span><br><span class="line">   </span><br><span class="line"><span class="number">4</span>、如果你没有使用<span class="literal">new</span>来访问<span class="built_in">String</span>构造函数，将会创建一个字符串直接量，而不是一个<span class="built_in">String</span>对象</span><br><span class="line"></span><br><span class="line">    <span class="built_in">var</span> city = <span class="built_in">String</span>(<span class="string">"Ar. louis"</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、如果需要在一个直接量上访问<span class="built_in">String</span> 对象方法：让JavaScript引擎创建了一个<span class="built_in">String</span>对象，用它包含了字符串直接量，执行方法调用，然后丢弃掉<span class="built_in">string</span>对象</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、与使用字符串直接量相比，使用<span class="built_in">String</span>的时候，要依赖于具体环境，除非你计划使用<span class="built_in">String</span>对象属性，否则应该尽可能地使用字符串直接量，如果你要使用<span class="built_in">String</span>方法，那么将字符串创建为对象。</span><br></pre></td></tr></table></figure><h6 id="1-1、连接两个或多个-字符串"><a href="#1-1、连接两个或多个-字符串" class="headerlink" title="1.1、连接两个或多个 字符串"></a>1.1、连接两个或多个 字符串</h6><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、问题：想要把两个或者多个字符串合并为一个</span><br><span class="line">   解决方案：</span><br><span class="line">       使用相加（+）运算符来连接字符串</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">var</span> str1 = <span class="string">'ming tian'</span>;</span><br><span class="line">       <span class="keyword">var</span> str2 = <span class="string">'qu na li'</span>;</span><br><span class="line">       <span class="keyword">var</span> str3 = str1 + str2;    <span class="comment">// ming tian qu na li</span></span><br><span class="line">       </span><br><span class="line"><span class="number">2</span>、有一个内建的<span class="keyword">string</span> 方法，可以连接多个字符串，这就是concat,它接受一个或者多个字符串参数，其中每一个都连接到字符串对象的末尾；</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">""</span> .concat(<span class="string">"ni"</span>,<span class="string">"shi"</span>,<span class="string">"yi"</span>,<span class="string">"zhu"</span>)  <span class="comment">//ni shi yi zhu</span></span><br></pre></td></tr></table></figure><h6 id="1-2、连接字符串和另一种数据类型"><a href="#1-2、连接字符串和另一种数据类型" class="headerlink" title="1.2、连接字符串和另一种数据类型"></a>1.2、连接字符串和另一种数据类型</h6><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、问题：想要把一个字符串和另一种数据类型（如数字）连接起来</span><br><span class="line">   解决方案：</span><br><span class="line">   </span><br><span class="line">   使用与连接字符串的时候完全相同的运算符  +  或者 += </span><br><span class="line">   <span class="selector-tag">var</span> num = <span class="number">131</span></span><br><span class="line">   <span class="selector-tag">var</span> str = <span class="string">"ni shi shui"</span></span><br><span class="line">   <span class="selector-tag">var</span> strr2 = str + num  <span class="comment">//ni shi shui 131</span></span><br><span class="line">   </span><br><span class="line"><span class="number">2</span>、注意点：</span><br><span class="line"></span><br><span class="line">    当把一个字符串和其他数据类型相加的时候，过程有所不同。在其他数据类型的情况下，如布尔或者数字，   js引擎先将其他数据转换为一个字符串，然后在将其连接</span><br></pre></td></tr></table></figure><h6 id="1-3、条件比较字符串"><a href="#1-3、条件比较字符串" class="headerlink" title="1.3、条件比较字符串"></a>1.3、条件比较字符串</h6><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、问题：想要比较两个字符串看看是否相同</span><br><span class="line"></span><br><span class="line">   解决方案：</span><br><span class="line">   </span><br><span class="line">   使用 ==  运算符来判断</span><br><span class="line">   </span><br><span class="line">   如果遇到大小写混合的例子可以先使用 toLowerCase 或 toUpperCase 将字符串转换为大写或者小写来比对，这两个方法不接受任何参数。</span><br><span class="line">   </span><br><span class="line"><span class="number">2</span>、有时候，不想让自动数据发生转化，想要在比较的值拥有不同的数据类型时，比较失败，如果一个值是字符直接量，e</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章-javascript字符串&quot;&gt;&lt;a href=&quot;#第一章-javascript字符串&quot; class=&quot;headerlink&quot; title=&quot;第一章 javascript字符串&quot;&gt;&lt;/a&gt;第一章 javascript字符串&lt;/h1&gt;&lt;h6 id=&quot;1-0、字
      
    
    </summary>
    
      <category term="重学JS系列" scheme="https://jiaopianjun.cc/categories/%E9%87%8D%E5%AD%A6JS%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JavaScript" scheme="https://jiaopianjun.cc/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Python基础教程之dict和set</title>
    <link href="https://jiaopianjun.cc/2019/04/30/Python%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Bdict%E5%92%8Cset.html"/>
    <id>https://jiaopianjun.cc/2019/04/30/Python基础教程之dict和set.html</id>
    <published>2019-04-30T14:36:00.000Z</published>
    <updated>2019-06-11T15:09:57.138Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-dict"><a href="#1-dict" class="headerlink" title="1. dict"></a>1. dict</h3><blockquote><p>Python中的dict等于js中的 map ，使用键-值（key-value）存储，具有极快的查找速度。</p></blockquote><p>如果 我们要根据同学的姓名去查找他的成绩在不用dict的情况下。就需要两个list:</p><pre><code>names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]scores = [95, 75, 85]// 通过一个名字，去查找对应的位置，再从scores中取出对应的成绩这样导致list的越来越长，速度越来越慢// 如果通过dict实现，只需要“名字-成绩”就行，无论这个表多大，查找速度都不会变慢，如下：&gt;&gt;&gt; d = {&apos;Michael&apos;: 95, &apos;Bob&apos;: 75, &apos;Tracy&apos;: 85}&gt;&gt;&gt; d[&apos;Michael&apos;]95</code></pre><blockquote><p>原理： 因为dict是通过索引去查找的而不是通过遍历的方式去找的。</p></blockquote><pre><code>// 除了初始化指定外，还可以通过key放入：&gt;&gt;&gt; d[&apos;Adam&apos;] = 67&gt;&gt;&gt; d[&apos;Adam&apos;]67// 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：&gt;&gt;&gt; d[&apos;Jack&apos;] = 90&gt;&gt;&gt; d[&apos;Jack&apos;]90&gt;&gt;&gt; d[&apos;Jack&apos;] = 88&gt;&gt;&gt; d[&apos;Jack&apos;]88</code></pre><blockquote><p>如果key不存在，dict将会报错。 可以通过in判断key是否存在<br>    或者通过get()方法</p></blockquote><pre><code>// in 方法&gt;&gt;&gt; &apos;Thomas&apos; in dFalse//  get() key不存在返回None&gt;&gt;&gt; d.get(&apos;Thomas&apos;)&gt;&gt;&gt; d.get(&apos;Thomas&apos;, -1)-1// 删除key 通过 pop()方法&gt;&gt;&gt; d.pop(&apos;Bob&apos;)75&gt;&gt;&gt; d{&apos;Michael&apos;: 95, &apos;Tracy&apos;: 85}</code></pre><blockquote><p>注意点：</p></blockquote><pre><code>1. dict 内部存放的顺序和key的放入顺序没有关系2. 和list比较    2.1 查找和插入速度极快，不会随着key的增加而变慢    2.2 需要占用大量的内存，内存浪费多3. 和list相反    3.1 查找和插入时间随着元素的增加而增加    3.2 占用空间小，浪费内存少4. dict是一种以空间换时间的方法5. dict的key必须是不可变对象6. 字符串和整数等不可变，可以作为key，而list的则不行。</code></pre><h3 id="2-set"><a href="#2-set" class="headerlink" title="2. set"></a>2. set</h3><blockquote><p>和dict类似，但是不存储value，key不重复。创建set，需要提供一个list作为输入集合，如下：</p></blockquote><pre><code>&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s{1, 2, 3}// 传入的参数[1, 2, 3]是一个list，而显示的{1, 2,3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的// set中重复将会被过滤&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])&gt;&gt;&gt; s{1, 2, 3}// 通过add(key)可以向set中添加元素，可以重复添加但无效果&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s{1, 2, 3, 4}&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s{1, 2, 3, 4}// 通过remove(key)删除元素&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; s{1, 2, 3}</code></pre><blockquote><p>set和dict的区别仅在于没有存储对应的value。</p></blockquote><h3 id="3-不可变对象"><a href="#3-不可变对象" class="headerlink" title="3. 不可变对象"></a>3. 不可变对象</h3><blockquote><p>对于可变对象，对它进行操作，对象本想将会变化</p></blockquote><pre><code>&gt;&gt;&gt; a = [&apos;c&apos;, &apos;b&apos;, &apos;a&apos;]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</code></pre><blockquote><p>对于不可变对象，对象本身不会变化</p></blockquote><pre><code>&gt;&gt;&gt; a = &apos;abc&apos;&gt;&gt;&gt; a.replace(&apos;a&apos;, &apos;A&apos;)&apos;Abc&apos;&gt;&gt;&gt; a&apos;abc&apos;</code></pre><blockquote><p>所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。    </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-dict&quot;&gt;&lt;a href=&quot;#1-dict&quot; class=&quot;headerlink&quot; title=&quot;1. dict&quot;&gt;&lt;/a&gt;1. dict&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Python中的dict等于js中的 map ，使用键-值（key-value
      
    
    </summary>
    
      <category term="Python系列" scheme="https://jiaopianjun.cc/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Python" scheme="https://jiaopianjun.cc/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础教程之条件判断和循环</title>
    <link href="https://jiaopianjun.cc/2019/04/25/Python%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF.html"/>
    <id>https://jiaopianjun.cc/2019/04/25/Python基础教程之条件判断和循环.html</id>
    <published>2019-04-25T09:36:00.000Z</published>
    <updated>2019-06-11T15:09:45.526Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-条件判断"><a href="#1-条件判断" class="headerlink" title="1. 条件判断"></a>1. 条件判断</h3><blockquote><p>计算机之所以能做很多自动化的任务，是因为它可以自己做条件判断如下：</p></blockquote><pre><code>age = 20if age &gt;= 18:    print(&apos;your age is&apos;, age)    print(&apos;adult&apos;)// 如果age &gt;= 18 那么就会执行下面的语句，反之则不会执行。age = 3if age &gt;= 18:    print(&apos;your age is&apos;, age)    print(&apos;adult&apos;)else:    print(&apos;your age is&apos;, age)    print(&apos;teenager&apos;)// 注意 ：号，还可以用更详细的方法来执行如下：age = 3if age &gt;= 18:    print(&apos;adult&apos;)elif age &gt;= 6:    print(&apos;teenager&apos;)else:    print(&apos;kid&apos;)// 注意 if 的执行是自上而下执行的，而且如果第一个条件执行成功，将不会在执行后续的 elif </code></pre><h3 id="2-循环"><a href="#2-循环" class="headerlink" title="2. 循环"></a>2. 循环</h3><blockquote><p>Python 中的循环有两种，一种是for…in 循环，依次把list或者tuple中的每个元素迭代出来。第二种是while循环，只要条件满足就不断循环，条件不满足则退出。</p></blockquote><pre><code>&gt;&gt;&gt; 1 + 2 + 36 // 几个数的计算可以直接这样写。// 如果要计算未知数就需要用循环，就是遍历的概念names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]for name in names:print(name)MichaelBobTracy// 比如求和sum = 0for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:    sum = sum + xprint(sum)</code></pre><blockquote><p>在Python中可以通过range()函数，生成整数序列，在通过list()函数转换为list，然后通过循环去遍历相加，如下：</p></blockquote><pre><code>&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4]sum = 0for x in range(101):    sum = sum + xprint(sum)// 遍历100 求和</code></pre><blockquote><p>while循环</p></blockquote><pre><code>sum = 0n = 99while n &gt; 0:    sum = sum + n    n = n - 2print(sum)// while循环可以通过break提前终止循环n = 1while n &lt;= 100:    if n &gt; 10: # 当n = 11时，条件满足，执行break语句        break # break语句会结束当前循环    print(n)    n = n + 1print(&apos;END&apos;)// while循环也可以通过continue跳过当前，执行之后的循环n = 0while n &lt; 10:    n = n + 1    if n % 2 == 0: # 如果n是偶数，执行continue语句        continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行    print(n)</code></pre><blockquote><p>循环是让计算机做重复任务最有效的方法。另外请不要滥用 break 和 continue 这样会造成代码执行逻辑分叉过多，容易出错。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-条件判断&quot;&gt;&lt;a href=&quot;#1-条件判断&quot; class=&quot;headerlink&quot; title=&quot;1. 条件判断&quot;&gt;&lt;/a&gt;1. 条件判断&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;计算机之所以能做很多自动化的任务，是因为它可以自己做条件判断如下：&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Python系列" scheme="https://jiaopianjun.cc/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Python" scheme="https://jiaopianjun.cc/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Node.js REPL</title>
    <link href="https://jiaopianjun.cc/2019/04/19/Node-js-REPL.html"/>
    <id>https://jiaopianjun.cc/2019/04/19/Node-js-REPL.html</id>
    <published>2019-04-19T13:33:00.000Z</published>
    <updated>2019-05-26T11:18:20.949Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Node-js-REPL"><a href="#Node-js-REPL" class="headerlink" title="Node.js REPL"></a>Node.js REPL</h3><blockquote><p>Node.js REPL (交互式解释器)，表示一个电脑的环境，类似window的终端或者shell,使的我们可以在终端中输入名，并接受系统的响应。Node自带了交互式解释器，可以执行下面任务：</p></blockquote><pre><code>1. 读取 - 读取用户输入，解析输入了JavaScript数据结构并存储到内存中。2. 执行 - 执行输入的数据结构3. 打印 - 输出结果4. 循环 - 循环操作以上步骤直到用户按下两次Ctrl-c 退出</code></pre><blockquote><p>我们在安装Node后 可以通过输入node启动终端</p></blockquote><h6 id="1-简单的表达式运算"><a href="#1-简单的表达式运算" class="headerlink" title="1. 简单的表达式运算"></a>1. 简单的表达式运算</h6><pre><code>$ node&gt; 1 +45&gt; 5 / 22.5&gt; 3 * 618&gt; 4 - 13&gt; 1 + ( 2 * 3 ) - 43&gt;ctrl + c - 退出当前终端。</code></pre><h6 id="2-使用变量"><a href="#2-使用变量" class="headerlink" title="2. 使用变量"></a>2. 使用变量</h6><blockquote><p>你可以将数据存储在变量中，并在你需要的时候使用它。</p></blockquote><p>变量声明需要使用 var 关键字，如果没有使用 var 关键字变量会直接打印出来。</p><p>使用 var 关键字的变量可以使用 console.log() 来输出变量。</p><pre><code>$ node&gt; x = 1010&gt; var y = 10undefined&gt; x + y20&gt; console.log(&quot;Hello World&quot;)Hello Worldundefined&gt; console.log(&quot;www.runoob.com&quot;)www.runoob.comundefined</code></pre><h6 id="3-多行表达式"><a href="#3-多行表达式" class="headerlink" title="3. 多行表达式"></a>3. 多行表达式</h6><blockquote><p>Node REPL 支持输入多行表达式，这就有点类似 JavaScript。接下来让我们来执行一个 do-while 循环：</p></blockquote><pre><code>$ node&gt; var x = 0undefined&gt; do {... x++;... console.log(&quot;x: &quot; + x);... } while ( x &lt; 5 );x: 1x: 2x: 3x: 4x: 5undefined&gt;ctrl + c 按下两次 - 退出 Node REPL。// ... 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式。</code></pre><h6 id="4-下划线-变量"><a href="#4-下划线-变量" class="headerlink" title="4. 下划线(_)变量"></a>4. 下划线(_)变量</h6><blockquote><p>你可以使用下划线(_)获取上一个表达式的运算结果：</p></blockquote><pre><code>$ node&gt; var x = 10undefined&gt; var y = 20undefined&gt; x + y30&gt; var sum = _undefined&gt; console.log(sum)30undefined&gt;</code></pre><h6 id="5-REPL-命令"><a href="#5-REPL-命令" class="headerlink" title="5. REPL 命令"></a>5. REPL 命令</h6><pre><code>ctrl + d - 退出 Node REPL.向上/向下 键 - 查看输入的历史命令tab 键 - 列出当前命令.help - 列出使用命令.break - 退出多行表达式.clear - 退出多行表达式.save filename - 保存当前的 Node REPL 会话到指定文件.load filename - 载入当前 Node REPL 会话的文件内容。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Node-js-REPL&quot;&gt;&lt;a href=&quot;#Node-js-REPL&quot; class=&quot;headerlink&quot; title=&quot;Node.js REPL&quot;&gt;&lt;/a&gt;Node.js REPL&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Node.js REPL (交互式
      
    
    </summary>
    
      <category term="Node系列" scheme="https://jiaopianjun.cc/categories/Node%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="node学习" scheme="https://jiaopianjun.cc/tags/node%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python基础教程之list和tuple</title>
    <link href="https://jiaopianjun.cc/2019/04/19/Python%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E4%B9%8Blist%E5%92%8Ctuple.html"/>
    <id>https://jiaopianjun.cc/2019/04/19/Python基础教程之list和tuple.html</id>
    <published>2019-04-19T03:36:00.000Z</published>
    <updated>2019-06-11T15:09:36.797Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-list"><a href="#1-list" class="headerlink" title="1. list"></a>1. list</h3><blockquote><p>Python内置的一种数据类型是列表，list 它是一种有序的集合，可以随时添加和删除其中的元素。</p></blockquote><pre><code>&gt;&gt;&gt; classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]&gt;&gt;&gt; classmates[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]// 变量 classmates就是一个list，可以通过len(classmates)来查看classmates的长度。</code></pre><blockquote><p>可以通过索引来访问list中每一个位置的元素，索引从0开始。</p></blockquote><pre><code>&gt;&gt;&gt; classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]&gt;&gt;&gt; classmates[0] // &apos;Michael&apos;&gt;&gt;&gt; classmates[1] // &apos;Bob&apos;&gt;&gt;&gt; classmates[2] // &apos;Tracy&apos;// 如果索引超过list的范围，将会报错。所以我们将最后一个索引的元素设置为 len(classmates) -1,如果要取最后一个元素，除了索引，我们可以通过-1直接获取最后一个元素。&gt;&gt;&gt; classmates[-1]// &apos;Tracy&apos;&gt;&gt;&gt; classmates[-2]// &apos;Bob&apos;&gt;&gt;&gt; classmates[-3]// &apos;Michael&apos;</code></pre><blockquote><p>list 是一个有序列表，我们可以往list中追加元素到末尾，也可以把元素插入的指定的位置。</p></blockquote><pre><code>&gt;&gt;&gt; classmates.append(&apos;Adam&apos;)&gt;&gt;&gt; classmates[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, &apos;Adam&apos;]// 插入 索引为1的位置&gt;&gt;&gt; classmates.insert(1, &apos;Jack&apos;)&gt;&gt;&gt; classmates[&apos;Michael&apos;, &apos;Jack&apos;, &apos;Bob&apos;, &apos;Tracy&apos;, &apos;Adam&apos;]// 删除末尾的元素 用pop()&gt;&gt;&gt; classmates.pop()&apos;Adam&apos;&gt;&gt;&gt; classmates[&apos;Michael&apos;, &apos;Jack&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]// 删除指定位置 pop(i)&gt;&gt;&gt; classmates.pop(1)&apos;Jack&apos;&gt;&gt;&gt; classmates[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]// 替换指定位置元素&gt;&gt;&gt; classmates[1] = &apos;Sarah&apos;&gt;&gt;&gt; classmates[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;]// list中的元素数据类型可以不同&gt;&gt;&gt; L = [&apos;Apple&apos;, 123, True]// 也可以放入另外一个list&gt;&gt;&gt; s = [&apos;python&apos;, &apos;java&apos;, [&apos;asp&apos;, &apos;php&apos;], &apos;scheme&apos;]&gt;&gt;&gt; len(s)4// 它只有4个长度，因为里面的list 算一个整体的。</code></pre><h3 id="2-tuple"><a href="#2-tuple" class="headerlink" title="2. tuple"></a>2. tuple</h3><blockquote><p>Python 中还有一种有序列表叫元组：tuple，tuple和list非常类似，但是tuple一旦初始化，将不能修改而且一旦定义就必须赋值，也可以为空。所以这样将更安全。可以理解为常量的概念。写法如下：</p></blockquote><pre><code>&gt;&gt;&gt; classmates = (&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;)&gt;&gt;&gt; t = (1, 2)&gt;&gt;&gt; t(1, 2)&gt;&gt;&gt; t = () // 为空&gt;&gt;&gt; t = (1) // 定义一个元素但是这样比不是一个tuple&gt;&gt;&gt; t = (1,) // 这样才是一个元素的tuple,必须要加 , 号&gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;, [&apos;A&apos;, &apos;B&apos;])&gt;&gt;&gt; t[2][0] = &apos;X&apos;&gt;&gt;&gt; t[2][1] = &apos;Y&apos;&gt;&gt;&gt; t(&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;])// 其他的写法  这时候是可以修改里面列表的值如上</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-list&quot;&gt;&lt;a href=&quot;#1-list&quot; class=&quot;headerlink&quot; title=&quot;1. list&quot;&gt;&lt;/a&gt;1. list&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Python内置的一种数据类型是列表，list 它是一种有序的集合，可以随时添
      
    
    </summary>
    
      <category term="Python系列" scheme="https://jiaopianjun.cc/categories/Python%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Python" scheme="https://jiaopianjun.cc/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门之函数的扩展</title>
    <link href="https://jiaopianjun.cc/2019/04/18/ES6%E5%85%A5%E9%97%A8%E4%B9%8B%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95.html"/>
    <id>https://jiaopianjun.cc/2019/04/18/ES6入门之函数的扩展.html</id>
    <published>2019-04-18T13:35:00.000Z</published>
    <updated>2019-06-11T15:12:08.207Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2019/4/26/16a59e37f9bb0d7b?w=1080&h=1920&f=jpeg&s=671019" alt title>                </div>                <div class="image-caption" style="display:none;"></div>            </figure><p>#</p><h3 id="1-函数参数的默认值"><a href="#1-函数参数的默认值" class="headerlink" title="1. 函数参数的默认值"></a>1. 函数参数的默认值</h3><hr><h5 id="1-1-用法"><a href="#1-1-用法" class="headerlink" title="1.1 用法"></a>1.1 用法</h5><blockquote><p>在ES6之前是不能为函数的参数指定默认值的，要想实现默认值只能通过判断赋值的方式来实现，在ES6中允许函数为参数设置默认值，主要是为了提高代码的可阅读性，有利于代码的优化。另外注意的是在参数赋值的时候，该参数不能重复使用，不能使用let const 进行定义。</p></blockquote><pre><code>// ES6 之前实现function log(x, y) {  y = y || &apos;World&apos;;  if (typeof y === &apos;undefined&apos;) {      y = &apos;World&apos;;  }  console.log(x, y);}log(&apos;Hello&apos;) // Hello Worldlog(&apos;Hello&apos;, &apos;China&apos;) // Hello Chinalog(&apos;Hello&apos;, &apos;&apos;) // Hello World// ES6 中实现function log(x, y = &apos;World&apos;) {  console.log(x, y);}log(&apos;Hello&apos;) // Hello Worldlog(&apos;Hello&apos;, &apos;China&apos;) // Hello Chinalog(&apos;Hello&apos;, &apos;&apos;) // Hellofunction Point(x = 0, y = 0) {  this.x = x;  this.y = y;}const p = new Point();p // { x: 0, y: 0 }function foo(x = 5,x) {   let x = 1; // 报错，不能同名参数，不能对参数进行let const 定义  const x = 2;}</code></pre><h5 id="1-2-与解构赋值一起使用"><a href="#1-2-与解构赋值一起使用" class="headerlink" title="1.2 与解构赋值一起使用"></a>1.2 与解构赋值一起使用</h5><blockquote><p>如果函数在调用的时候没有提供参数，内部变量就不会产生，就会产生错误，通过提供函数的默认值可以解决这种问题，如下：</p></blockquote><pre><code>function foo({x, y = 5}) {  console.log(x, y);}foo() // 报错foo({x:1}) // 1 5foo({x:2,y:3) // 2 3foo({}) // undefined 5function foo ({x,y = 5} = {}){    console.log(x,y)}foo() // undefined 5 这样就是如果没有在调用的时候传值 就默认赋空对象。</code></pre><blockquote><p>如下例子：</p></blockquote><pre><code>function post(url, {b = &apos;&apos;,type=&apos;get&apos;,h={}}){    console.log(type)}post(&apos;w.b.c&apos;,{}) // getpost(&apos;w.b.c&apos;)    // 报错// 改成这样就可以了function post(url, {b = &apos;&apos;,type=&apos;get&apos;,h={}} = {}){    console.log(type)}post(&apos;w.b.c&apos;,{}) // getpost(&apos;w.b.c&apos;)    // get</code></pre><blockquote><p>下面例子的区别</p></blockquote><pre><code>// 写法一function m1({x = 0, y = 0} = {}) {  return [x, y];}// 写法二function m2({x, y} = { x: 0, y: 0 }) {  return [x, y];}两个都是有默认值在调用的时候都传值或者都不传值的时候情况是一样的。但是如果传空值，或者不传值的情况会有差异如下：m1({}) // 因为本身有默认值 所以为 [0,0]m2({}) // 默认值为空 解构赋值没有传值 所以 [undefined,undefined]// 其他情况同上m1({x: 3}) // [3, 0]m2({x: 3}) // [3, undefined]m1({z: 3}) // [0, 0]m2({z: 3}) // [undefined, undefined]</code></pre><h5 id="1-3-参数默认值的位置"><a href="#1-3-参数默认值的位置" class="headerlink" title="1.3 参数默认值的位置"></a>1.3 参数默认值的位置</h5><blockquote><p>如果定义了默认值的参数，应该是函数的尾参数。而且这个参数是无法省略的，除非输入undefined</p></blockquote><h5 id="1-4-函数的-length-属性"><a href="#1-4-函数的-length-属性" class="headerlink" title="1.4 函数的 length 属性"></a>1.4 函数的 length 属性</h5><blockquote><p>函数参数指定了默认值之后，函数的length属性将会减去指定了默认值的参数个数。因为该属性认为，指定了默认值的参数将不包含在预期参数个数中。如下：</p></blockquote><pre><code>(function (a) {}).length // 1(function (a = 5) {}).length // 0(function (a, b, c = 5) {}).length // 2</code></pre><h5 id="1-5-作用域"><a href="#1-5-作用域" class="headerlink" title="1.5 作用域"></a>1.5 作用域</h5><blockquote><p>如果函数中的参数设置了默认值，那么函数在声明初始化的时候，参数会形成一个单独的作用域，初始化完成后这个作用域就会消失，这种情况只在参数设置了默认值的情况下。如下：</p></blockquote><pre><code>var x = 1;function f(x, y = x) {  console.log(y);}f(2) // 2// 因为 设置了默认值 所以在调用 f 的时候就形成了作用域，这时候因为将x赋值给y 传入的x 为 2  所以y是2，如果这时候 调用的时候不传值，那么x将指向全局，所以y = 1</code></pre><h5 id="1-6-应用"><a href="#1-6-应用" class="headerlink" title="1.6 应用"></a>1.6 应用</h5><blockquote><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就报错，如下</p></blockquote><pre><code>function throwIfMissing() {  throw new Error(&apos;Missing parameter&apos;);}function foo(mustBeProvided = throwIfMissing()) {  return mustBeProvided;}foo()// Error: Missing parameterfoo(2) // 2</code></pre><h3 id="2-rest-参数"><a href="#2-rest-参数" class="headerlink" title="2. rest 参数"></a>2. rest 参数</h3><blockquote><p>ES6 中 增加了 rest 参数（…变量名），用于获取函数多余的参数，rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p></blockquote><pre><code>function add(...values) {  let sum = 0;  for (var val of values) {    sum += val;  }  return sum;}add(2, 5, 3) // 10// 注意：rest 参数之后不能再有其他参数，另外rest参数也不计算在函数的length属性中。</code></pre><h3 id="3-严格模式"><a href="#3-严格模式" class="headerlink" title="3. 严格模式"></a>3. 严格模式</h3><blockquote><p>ES6 中，如果函数参数使用了默认值，解构赋值，或者扩展运算符，那么函数内部将不能显式设定为严格模式，否则会报错。因为函数执行的时候 先执行函数参数，在执行函数体，但是因为只有在函数体中才能知道参数是否以严格模式执行，但是参数却应该先于函数执行。有两种方法可以规避：一、 设置全局严格模式，二、把函数包在一个无参数的立即执行函数里面。</p></blockquote><h3 id="4-name属性"><a href="#4-name属性" class="headerlink" title="4. name属性"></a>4. name属性</h3><blockquote><p>返回函数的函数名，如下：</p></blockquote><pre><code>function foo(){}foo.name // foovar f = function(){}// ES5f.name // &apos;&apos;// ES6f.name // fvar f = function c(){}f.name // c</code></pre><h3 id="5-箭头函数"><a href="#5-箭头函数" class="headerlink" title="5. 箭头函数"></a>5. 箭头函数</h3><blockquote><p>ES6 允许使用 “箭头” （=&gt;）定义函数</p></blockquote><pre><code>var f = v =&gt; v;// 等同于var f = function (v) {  return v;};var f = () =&gt; 5;// 等同于var f = function () { return 5 };var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) {  return num1 + num2;};// 如果箭头函数后面的语句较多就要用大括号包裹起来 并return返回var sum = (num1, num2) =&gt; { return num1 + num2; //rest 参数与箭头函数结合的例子。const numbers = (...nums) =&gt; nums;numbers(1, 2, 3, 4, 5)// [1,2,3,4,5]const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5)// [1,[2,3,4,5]]</code></pre><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><pre><code>1. 函数体内的this对象，就是在定义时所在的对象，而不是使用时所在的对象。2. 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。3. 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。4. 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。5. 由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。</code></pre><h5 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h5><pre><code>1. 定义对象的方法，且该方法内部包括this2. 动态定义this 的场合，如点击事件中this 的指向</code></pre><h5 id="嵌套的箭头函数"><a href="#嵌套的箭头函数" class="headerlink" title="嵌套的箭头函数"></a>嵌套的箭头函数</h5><blockquote><p>箭头函数内部可以在嵌套使用箭头函数。</p></blockquote><h3 id="6-尾调用优化"><a href="#6-尾调用优化" class="headerlink" title="6. 尾调用优化"></a>6. 尾调用优化</h3><h5 id="什么是尾调用"><a href="#什么是尾调用" class="headerlink" title="什么是尾调用"></a>什么是尾调用</h5><blockquote><p>函数式编程的一个重要概念，指某个函数的最后一步是调用另一个函数</p></blockquote><pre><code>function f(x){  return g(x);}// 一下都不属于// 情况一function f(x){  let y = g(x);  return y;}// 情况二function f(x){  return g(x) + 1;}// 情况三function f(x){  g(x);}</code></pre><h5 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h5><blockquote><p>只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p></blockquote><pre><code>function f() {  let m = 1;  let n = 2;  return g(m + n);}f();// 等同于function f() {  return g(3);}f();// 等同于g(3);</code></pre><p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p><h5 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h5><blockquote><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p></blockquote><h5 id="ES6-的尾调用优化只在严格模式下开启，正常模式是无效的。"><a href="#ES6-的尾调用优化只在严格模式下开启，正常模式是无效的。" class="headerlink" title="ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。"></a>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</h5><h5 id="尾递归优化的实现"><a href="#尾递归优化的实现" class="headerlink" title="尾递归优化的实现"></a>尾递归优化的实现</h5><blockquote><p>在正常模式下，可以使用减少调用栈，采用循环换掉递归的方法</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
      
    
    </summary>
    
      <category term="ES6入门系列" scheme="https://jiaopianjun.cc/categories/ES6%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="ECMAScript6" scheme="https://jiaopianjun.cc/tags/ECMAScript6/"/>
    
  </entry>
  
</feed>
